[{"categories":["deploy"],"content":"工具 https 的场景运用越来越广泛，有时在开发环境中也需要使用 https 来进行开发或测试，这时自签名证书就成了快速应对这一场景的省时省力的好帮手。 常见的自签名方案有通过 OpenSSL 来生成，不过现在有更快捷方便的工具 https://github.com/FiloSottile/mkcert。 ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:1:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"生成证书 Windows 下能够下载对应的工具 https://github.com/FiloSottile/mkcert/releases，使用命令生成本地域名证书 mkcert-v1.4.3-windows-amd64.exe localhost 127.0.0.1 ::1 10.13.69.59 192.168.1.80 ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:2:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"安装证书 mkcert-v1.4.3-windows-amd64.exe -install ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:3:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"配置 nginx ssl_certificate \"/etc/nginx/conf.d/localhost+4.pem\"; ssl_certificate_key \"/etc/nginx/conf.d/localhost+4-key.pem\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; 到此，浏览器应该能够使用 https 正常访问网页，不过期间有个小插曲，因为我的 Windows 电脑安装的 VMware，这玩意有个 VMwareHostd 服务监听了 443 端口，导致我的浏览器一直在报 NET:ERR_CERT_AUTHORITY_INVALID 这个错误，但是我更换 nginx 代理暴露的端口后又能正常访问，这一度让我以为 443 端口对浏览器来说有某种神秘力量，好在后来停掉 nginx 后发现 443 依旧可以 telnet 通，这才知道原来是被 VMwareHostd 占用了，停掉这个服务后就一切正常了。 ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:4:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"复用根证书 通过命令 mkcert -CAROOT 查看根证书的位置，查看到证书位置后取一份计算机的证书，复制到其他计算机后运行 mkcert -install 就可以达到不同计算机都能识别相同的自签证书的目的。 ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:5:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"介绍 Janus 是由 Meetecho 开发的 WebRTC 服务器。因此，除了实现与浏览器建立 WebRTC 媒体通信、与其交换 JSON 消息以及在浏览器和服务器端应用程序逻辑之间中继 RTP/RTCP 和消息的方法之外，它本身不提供任何功能。任何特定的功能和应用程序都由服务器端插件提供，浏览器可以通过 Janus 联系以利用它们提供的功能。此类插件的示例可以是应用程序的实现，例如回声测试、会议桥、媒体记录器、SIP 网关等。 ","date":"2021-09-04","objectID":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/:1:0","tags":["deploy","janus","webrtc"],"title":"Janus 的搭建与 WebRTC 使用","uri":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"部署 我使用了一个 docker hub 镜像 来部署 janus 的后台，部署方法可参考 https://janus.conf.meetecho.com/docs/deploy，再搭配一个 nginx 来做后台 API 的转发，docker-compose 配置如下： version: '2.1' services: janus-gateway: image: 'canyan/janus-gateway' container_name: janus_gateway command: [\"/usr/local/bin/janus\", \"-F\", \"/usr/local/etc/janus\"] volumes: - \"./etc/janus/janus.jcfg:/usr/local/etc/janus/janus.jcfg\" # - \"./etc/janus/janus.eventhandler.sampleevh.jcfg:/usr/local/etc/janus/janus.eventhandler.sampleevh.jcfg\" restart: always network_mode: 'host' janus_nginx: image: nginx:alpine container_name: janus_nginx restart: always network_mode: 'host' volumes: - ./conf.d/:/etc/nginx/conf.d - ./html:/dist 有一点需要注意，如果 janus 安装在 nat 转换后的内网需要 trun 来帮助客户端和服务端打洞，部署复杂，而且失败率很高，因此将 janus 的服务部署为与主机共享网络的 host 模式，当然前提是你要有一台有公网 ip 的服务器。 虽然部署在公网，但是还是需要一个 stun 服务，在 janus.jcfg 配置中需要取消 stun 的注释： stun_server = \"stun.voip.eutelia.it\" stun_port = 3478 nginx 配置如下，里面我使用了对应域名的 https 证书： server { listen 80; server_name web_dist; location / { root /dist; index index.html index.htm; } } server { listen 80 default_server; listen [::]:80 default_server; server_name localhost; rewrite ^(.*)$ https://$host$1 permanent; root /dist; } # api server upstream api_server{ server 127.0.0.1:8088; } map $http_upgrade $connection_upgrade { default upgrade; '' close; } upstream websocket { server 127.0.0.1:8188; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name localhost; root /dist; underscores_in_headers on; ssl_certificate \"/etc/nginx/conf.d/ctxy.frhello.comert.pem\"; ssl_certificate_key \"/etc/nginx/conf.d/txy.frhello.com.key\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # error_page 497 301 =307 location / { } # 后台接口 location /janus/ { proxy_pass http://api_server/janus/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Server $host; } # ws location /ws { proxy_pass http://websocket; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } } nginx 中的 web 前端使用的是官网 github 项目中的演示 html 文件夹，整理好整个工程的目录：","date":"2021-09-04","objectID":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/:2:0","tags":["deploy","janus","webrtc"],"title":"Janus 的搭建与 WebRTC 使用","uri":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"JavaScript API 在源代码下有一个 html 文件夹下有演示 demo，在每个页面对应的 js 文件下可以配置服务地址的 websocket 地址：server = \"wss://\" + window.location.hostname + \"/ws\";，然后在 nginx 中修改配置做为这个 web 服务的代理。 最后打开 Video Room 的效果： Video RoomVideo Room \" Video Room ","date":"2021-09-04","objectID":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/:3:0","tags":["deploy","janus","webrtc"],"title":"Janus 的搭建与 WebRTC 使用","uri":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/"},{"categories":["base"],"content":"概念 UUIDs (Universally Unique IDentifier)，也称为 GUIDs (Globally 唯一标识符）。一个 UUID 是 128 位长，并且可以保证空间和时间上的唯一性。 使用 UUID 的主要原因之一是无需集中的管理，并且 UUID 的生成算法要求它支持单台每秒超过百万次的生成速率。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:1:0","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"布局和字节顺序 UUID 呈现的格式为：f81d4fae-7dec-11d0-a765-00a0c91e6bf6 字段 数据类型 字节 注释 time_low unsigned 32 bit integer 0-3 低域位整数时间戳 time_mid unsigned 16 bit integer 4-5 中间字段位整数时间戳 time_hi_and_version unsigned 16 bit integer 6-7 高场位整数时间戳 clock_seq_hi_and_reserved unsigned 8 bit integer 8 整数时钟序列与多路复用 clock_seq_low unsigned 8 bit integer 9 低域位整数时钟序列 node unsigned 48 bit integer 10-15 空间唯一位整数节点标识符 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:0","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"版本 版本号在时间戳的最高 4 位（time_hi_and_version 的 4-7 bit） UUID 的变体规则如下 Msb0 Msb1 Msb2 Msb3 版本 描述 0 0 0 1 v1 基于时间的版本 0 0 1 0 v2 DEC 安全版本 0 0 1 1 v3 基于名称的版本（本文件中规定使用 MD5 散列） 0 1 0 0 v4 随机或伪随机生成的版本 0 1 0 1 v5 基于名称的版本（本文件中规定使用 SHA-1 散列） 版本更准确地说应该叫子类型，称其为版本只是为了兼容性。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:1","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"时间戳 时间戳是一个 60 位的值，一般使用 UTC 时间表示，如果没有 UTC 时间可用本地时间，但是尽量不建议这样做，因为本地时间要生成 UTC 时间需要额外的时区信息。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:2","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"时间序列 时间序列用于帮助避免当时钟向后设置时可能出现的重复或者节点 ID 改变。如果已知时钟序列的先前值，则它智能递增，否则它应该设置为随机或者高质量的伪随机值。类似地，如果节点 ID 发生变化（例如，因为网卡在机器间移动），需要重新设置时间序列。 对于 UUID 的版本 3 或 5，时钟序列是 14 位根据名称描述构造的值。 对于 UUID 的版本 4，时钟序列是随机或伪随机的 14 位值。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:3","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"节点 对于 UUID 的版本 1，节点字段包含一个 IEEE 802 MAC 地址，通常是主机地址。 对于 UUID 的版本 3 或 5，节点字段是 48 位根据名称描述构造的值。 对于 UUID 的版本 4，节点字段是随机或伪随机生成 48 位值。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:4","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"nil UUID nil UUID 是 UUID 的特殊形式，是所有 128 位均设置为零。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:5","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"顺序 UUID 在数据库中存储，经常使用 UUID 作为主键，但是 UUID 有个致命缺陷，就是没有顺序。如果这种无顺序的 ID 当作主键在数据库中使用会严重影响数据库的性能。 现在有很多框架使用的算法支持生成递增的 UUID，例如 ABP 框架里的顺序 ID 参考了 https://github.com/jhtodd/SequentialGuid/blob/master/SequentialGuid/Classes/SequentialGuid.cs，这个顺序 ID 有个生成类型枚举 SequentialGuidType，SQL Server 使用 SequentialAtEnd 类型，因为 SQL Server 使用最低的有效 6 个字节来排序，其他大多数数据库应该传递 SequentialAsString 或 SequentialAsBinary。 UUID v1 也定义了基于时间的版本，但是该标准将时间戳拆分为几块，限制了其作为顺序 ID 的用途。因此这种顺序 UUID 与传统的 UUID 标准不兼容。 这个算法使用了 6 个字节 48 bit 来表示时间戳，精确到毫秒，大概能使用 5900 年，对于一般的应用足够了。 还有一个时间精度更高的实现方案：https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql/blob/ebe011a6f1b2a2a9709fe558cfc7ed3215b55c37/src/EFCore.MySql/ValueGeneration/Internal/MySqlSequentialGuidValueGenerator.cs，时间戳占 8 字节，精度到 100 ns，但是这个实现里有一些位移操作符，还结合了 UUID 的变体版本号，没有细看，猜测思路应该跟第一种顺序 UUID 也类似。 参考 https://www.ietf.org/rfc/rfc4122.txt ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:3:0","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["javascript"],"content":"Javascript 最常用的时间库 moment ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:0:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"初始化 moment 从 Date 初始化 let nowDate = new Date(); console.log('1.1 从 date 初始化：', nowDate, moment(nowDate)); 直接初始化 let nowMoment = moment(); console.log('1.2 直接初始化：', nowMoment); 从字符串初始化 const ISO8601_String = (new Date(1987, 8, 15 , 16, 15, 45)).toISOString(); console.log('1.3 从字符串初始化：', ISO8601_String, moment(ISO8601_String), new Date(Date.parse(ISO8601_String))) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:1:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"格式化 Format 格式化输出 console.log('2.1 Format 格式化输出：', nowMoment.format()) Format 默认格式化 moment.defaultFormat = 'YYYY-MM-DD HH:mm:ss:SSSS' console.log('2.2 Format 默认格式化输出：', nowMoment.format()) UTC Format 格式化输出 console.log('2.3 Format 格式化输出：', nowMoment.utc().format()) UTC Format 默认格式化 moment.defaultFormatUtc = 'YYYY-MM-DD HH:mm:ss:SSSS' console.log('2.4 UTC Format 默认格式化输出：', nowMoment.utc().format()) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:2:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"Unix 时间戳 ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:3:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"原生获取时间戳 console.log('3.1 原生获取时间戳：', nowDate.getTime(), new Date(nowDate.getTime())) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:3:1","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"moment 获取时间戳 console.log('3.1 moment 获取时间戳：', nowMoment.unix(), moment.unix(nowMoment.unix()), moment(nowDate.getTime())) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:3:2","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"时区 使用 Moment Timezone ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:4:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"猜测当前时区 console.log('4.1 获取当前时区：', moment.tz.guess(), moment.utc()) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:4:1","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"时间临界值 ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"获取当天最后一刻 console.log('5.1 获取当天最后一刻', moment().endOf('day')) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:1","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"获取本周最后一刻 console.log('5.2 获取本周最后一刻', moment().endOf('week').startOf('day')) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:2","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"获取本月第一天 console.log('5.3 获取本月第一天', moment().startOf('month')) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:3","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"获取明年第一天 console.log('5.4 获取明年第一天', moment().year(moment().year() + 1).startOf('year')) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:4","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"时长 ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:6:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"原生时长差值 const d1 = new Date(1987, 8, 15, 16, 15, 45) const d2 = new Date(1987, 8, 15, 17, 13, 45) console.log('6.1 原生时长差值（单位 ms）：', d2.getTime() - d1.getTime(), d1.getTime() - d2.getTime()) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:6:1","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"moment 时长差值减 console.log('6.3 moment 时长差值减：', duration.subtract(moment.duration(5, 'minute')).asMinutes()) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:6:2","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["docker"],"content":"制作 Dockerfile 比如要打包 mkcert 方便以后快速制作 https 证书的镜像，可使用如下步骤，任意目录下新建一个 mkcert 目录，新建 Dockerfile 文件，写入以下 Dockerfil : FROMhomebrew/brewRUN brew install mkcert ","date":"2021-08-28","objectID":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/:1:0","tags":["docker"],"title":"Dockerfile 制作镜像上传 Docker hub","uri":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/"},{"categories":["docker"],"content":"编译本地镜像 在刚才的 mkcert 目录下运行 docker build -t mkcert:v1 .，制作镜像 ","date":"2021-08-28","objectID":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/:2:0","tags":["docker"],"title":"Dockerfile 制作镜像上传 Docker hub","uri":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/"},{"categories":["docker"],"content":"上传镜像 制作完毕后可以上传镜像到 docker hub，重命名刚才的镜像，需要在前面加上你的 docker hub 的用户名： docker image tag mkcert:v1 {username}/mkcert:latest，最后一步上传：docker push {username}/mkcert:latest ","date":"2021-08-28","objectID":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/:3:0","tags":["docker"],"title":"Dockerfile 制作镜像上传 Docker hub","uri":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/"},{"categories":["linux"],"content":"文件夹新建 mkdir test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"文件新建 touch test.st ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"查看文件或文件夹信息 ls -l test.st ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:3:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"修改权限 # 递归修改为最高权限 chmod -R 777 test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:4:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"删除文件 rm -rf test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:5:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"压缩文件夹 tar zcvf ./t1.tar.gz test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:6:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"解压文件 # 解压到当前目录 tar zxvf t1.tar.gz # 解压到指定目录 tar zxvf t1.tar.gz -C /test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:7:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"拷贝文件 ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:8:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"本地拷贝 # 拷贝文件 scp t1.tar.gz t2.tar.gz # 拷贝文件夹 scp -r test test2 ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:8:1","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"远程拷贝 # 拷贝文件 scp ubuntu@txy.frhello.com:/home/ubuntu/t1.tar.gz d:\\ # 递归拷贝文件夹 scp -r ubuntu@txy.frhello.com:/home/ubuntu d:\\ ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:8:2","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"安装 CentOS 下载对应版本 http://centos.01link.hk/7.9.2009/isos/x86_64/CentOS-7-x86_64-Minimal-2009.iso 虚拟机安装，注意安装以太网并设置自动对时，使用 ip addr 可查看 ip 更新 yum，然后安装 net-tools yum update yum -y install epel-release yum install net-tool ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:1:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"网络 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:2:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"防火墙 查看防火墙状态 systemctl status firewalld 打开指定端口： firewall-cmd --add-port=3306/tcp --permanent firewall-cmd --reload firewall-cmd --add-port=3306/tcp --permanent firewall-cmd --reload systemctl status firewalld 查看打开的端口： firewall-cmd --list-ports 关于 firewall 的详细配置查看 https://wangchujiang.com/linux-command/c/firewall-cmd.html ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:2:1","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"安装 Telnet 工具 yum install telnet.x86_64 -y ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:2:2","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"静态 IP 参考 https://www.cnblogs.com/freeweb/p/5335973.html 打开配置文件进行编辑 vim /etc/sysconfig/network-scripts/ifcfg-${xxxx} 把 BOOTPROTO=\"dhcp\" 改成 BOOTPROTO=\"static\" BROADCAST=192.168.1.255 IPADDR=192.168.1.33 NETMASK=255.255.255.0 GATEWAY=192.168.1.1 配置 DNS，配置文件位置是：/etc/resolv.conf nameserver 114.114.114.114 nameserver 8.8.8.8 重启网络 service network restart ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:2:3","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"软件 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"安装 JDK 下载对应版本 https://www.oracle.com/cn/java/technologies/javase/javase-jdk8-downloads.html 拷贝包 scp E:\\Download\\jdk-8u281-linux-x64.rpm root@192.168.197.133:/tmp 添加执行权限 chmod +x /tmp/jdk-8u281-linux-x64.rpm rpm 安装 rpm -ivh /tmp/jdk-8u281-linux-x64.rpm chmod +x /tmp/jdk-8u281-linux-x64.rpm rpm -ivh /tmp/jdk-8u281-linux-x64.rpm ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:1","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"安装 MySQL 下载对应版本 https://dev.mysql.com/downloads/mysql/ 安装和配置参考：https://juejin.cn/post/6844903870053761037 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:2","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"安装 Node.js cd /usr/local/src/ wget https://nodejs.org/dist/v14.15.4/node-v14.15.4.tar.gz tar zxvf node-v14.15.4.tar.gz cd node-v14.15.4 ./configure --prefix=/usr/local/node/14.15.4 make make install 配置 NODE_HOME，进入 profile 编辑环境变量 vim /etc/profile 设置 nodejs 环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容: #set for nodejs export NODE_HOME=/usr/local/node/14.15.4 export PATH=$NODE_HOME/bin:$PATH ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:3","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"RabbitMQ 安装 安装参考 https://www.rabbitmq.com/install-rpm.html 安装 erlang 依赖 curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash sudo yum install erlang-23.2.6-1.el7.x86_64 -y 安装 rabbitmq rpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash sudo yum install rabbitmq-server.noarch -y 启动 rabbitmq systemctl enable rabbitmq-server.service systemctl start rabbitmq-server.service 启动管理页面 https://www.rabbitmq.com/management.html rabbitmq-plugins enable rabbitmq_management rabbitmq-plugins list 启动 stomp-web https://www.rabbitmq.com/web-stomp.html rabbitmq-plugins enable rabbitmq_web_stomp rabbitmq-plugins list 增加用户 rabbitmqctl add_user admin admin rabbitmqctl set_user_tags admin administrator rabbitmqctl set_permissions -p \"/\" \"admin\" \".*\" \".*\" \".*\" rabbitmqctl list_users 打开防火墙 firewall-cmd --add-port=15672/tcp --permanent firewall-cmd --add-port=5672/tcp --permanent firewall-cmd --add-port=15674/tcp --permanent firewall-cmd --reload firewall-cmd --list-port # intsall erlang curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash sudo yum install erlang-23.2.6-1.el7.x86_64 -y # install rabbitmq server rpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash sudo yum install rabbitmq-server.noarch -y # start rabbitmq server systemctl enable rabbitmq-server.service systemctl start rabbitmq-server.service # start management ui rabbitmq-plugins enable rabbitmq_management # start stomq-web rabbitmq-plugins enable rabbitmq_web_stomp # add user rabbitmqctl add_user admin admin rabbitmqctl set_user_tags admin administrator rabbitmqctl set_permissions -p \"/\" \"admin\" \".*\" \".*\" \".*\" # open firewall port firewall-cmd --add-port=15672/tcp --permanent firewall-cmd --add-port=5672/tcp --permanent firewall-cmd --add-port=15674/tcp --permanent firewall-cmd --reload ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:4","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"nginx 安装 参考 https://www.nginx.com/resources/wiki/start/topics/tutorials/install/ 在/etc/yum.repos.d目录下添加源文件nginx.repo，然后配置源： [nginx] name=nginx repo baseurl=https://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 执行命令安装，yum install nginx ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:5","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"设置常驻服务 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:4:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"Ubuntu https://www.jianshu.com/p/5ffccbd8ed1b https://blog.csdn.net/wojiaosha123/article/details/98784936 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:4:1","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"免密登陆 参考：https://zhuanlan.zhihu.com/p/35878555 https://docs.github.com/cn/github/authenticating-to-github/working-with-ssh-key-passphrases Windows 下添加ssh-agent：https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:5:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["efcore"],"content":"教程 https://docs.microsoft.com/en-us/ef/core/ ","date":"2021-05-10","objectID":"/entity-framework-core-%E7%AC%94%E8%AE%B0/:1:0","tags":["dotnet","efcore"],"title":"Entity Framework Core 笔记","uri":"/entity-framework-core-%E7%AC%94%E8%AE%B0/"},{"categories":["efcore"],"content":"Ef 命令使用 使用 EF CLI 安装 dotnet tool install --global dotnet-ef 使用 PMC (Package Manager Console，Visual Studio 推荐使用该方式，可以减少文件夹切换等操作) 安装 Install-Package Microsoft.EntityFrameworkCore.Tools ","date":"2021-05-10","objectID":"/entity-framework-core-%E7%AC%94%E8%AE%B0/:2:0","tags":["dotnet","efcore"],"title":"Entity Framework Core 笔记","uri":"/entity-framework-core-%E7%AC%94%E8%AE%B0/"},{"categories":["efcore"],"content":"核心 nuget 程序集 Microsoft.EntityFrameworkCore Microsoft.EntityFrameworkCore.Relational Microsoft.EntityFrameworkCore.database provider Microsoft.EntityFrameworkCore.Design （设计时，用于由 model 生成数据库或者反向， 可以不随生成发布） 程序集的各版本需要一致 ","date":"2021-05-10","objectID":"/entity-framework-core-%E7%AC%94%E8%AE%B0/:3:0","tags":["dotnet","efcore"],"title":"Entity Framework Core 笔记","uri":"/entity-framework-core-%E7%AC%94%E8%AE%B0/"},{"categories":["efcore"],"content":"自动生成 SQL 的相关命令 dotnet 命令 PowerShell 命令 作用 dotnet ef migrations add InitialCreate Add-Migration InitialCreate 对当前的 EF Model 的更改，增加一个 Migration 的配置文件 dotnet ef database update Update-Database 更新当前的 Migration 到数据库中 dotnet ef migrations remove Remove-Migration 删除一个最新的 Migration dotnet ef database update LastGoodMigartion Update-Database LastGoodMigration 指定一个 Migration 去更新数据库 dotnet ef migrations script Script-Migration 将当前的 Migrationn 生成 SQL 脚本，SQL 脚本可以直接拿来使用 使用命令前需要引用 Microsoft.EntityFrameworkCore.Tools 这个包 ","date":"2021-05-10","objectID":"/entity-framework-core-%E7%AC%94%E8%AE%B0/:4:0","tags":["dotnet","efcore"],"title":"Entity Framework Core 笔记","uri":"/entity-framework-core-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"参考：https://vmsdurano.com/apiboilerplate-and-identityserver4-access-control-for-apis/ ","date":"2021-05-03","objectID":"/identity-server-4/:0:0","tags":["dotnet","aspnetcore","identity","resource"],"title":"Identity Server 4","uri":"/identity-server-4/"},{"categories":["aspnetcore"],"content":"接口发现 Token Endpoint https://localhost:44354/.well-known/openid-configuration ","date":"2021-05-03","objectID":"/identity-server-4/:1:0","tags":["dotnet","aspnetcore","identity","resource"],"title":"Identity Server 4","uri":"/identity-server-4/"},{"categories":["aspnetcore"],"content":"Issuer 不一致导致验证失败 https://www.cnblogs.com/stulzq/p/10339024.html ","date":"2021-05-03","objectID":"/identity-server-4/:2:0","tags":["dotnet","aspnetcore","identity","resource"],"title":"Identity Server 4","uri":"/identity-server-4/"},{"categories":["aspnetcore"],"content":"框架介绍 旧版 Abp 框架，https://aspnetboilerplate.com/ 新版 Abp 框架，扩展了对微服务的支持，https://abp.io/ 结构介绍：https://docs.abp.io/en/abp/latest/Best-Practices/Module-Architecture ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:1:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"内置模块 https://docs.abp.io/en/abp/latest/Modules/Index ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:2:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"领域层 ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"EF Core https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Migrations ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:1","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"IRepository 内置方法 https://docs.abp.io/en/abp/latest/Repositories ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:2","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"异步查询执行 IAsyncQueryableExecuter.ToListAsync() https://docs.abp.io/en/abp/latest/Repositories ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:3","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"对象扩展 扩展 Abp 框架自带模块对应的数据库实体 https://docs.abp.io/en/abp/latest/Customizing-Application-Modules-Extending-Entities ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:4","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"实体变更通知 ILocalEventHandler\u003cEntityChangedEventData\u003c\u003e\u003e ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:5","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"应用层 ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:4:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"服务层 ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:5:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"替换内置 Service 和 Control https://docs.abp.io/en/abp/latest/Customizing-Application-Modules-Overriding-Services ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:5:1","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"权限 https://docs.abp.io/en/abp/latest/Authorization ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:5:2","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"基础设施 ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:6:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"配置 https://docs.abp.io/en/abp/latest/Configuration https://docs.abp.io/en/abp/latest/Settings ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:6:1","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"参考文章 https://www.cnblogs.com/myzony/p/11312928.html ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:7:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":"loader 处理特定后缀名的模块称为 loader thread-loader: 使用线程池加速打包过程 ","date":"2021-03-21","objectID":"/webpack-%E7%AC%94%E8%AE%B0/:1:0","tags":["package","webpack"],"title":"webpack 笔记","uri":"/webpack-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":"占位符 占位符名称 含义 [ext] 资源后缀名 [name] 文件名称 [path] 文件相对路径 [folder] 文件所在的文件夹 [contenthash] 文件的内容 hash，默认是 MD5 生成 [hash] 文件内容的 hash，默认是 MD5 生成 [emoji] 一个随机的指代文件内容的 emoji ","date":"2021-03-21","objectID":"/webpack-%E7%AC%94%E8%AE%B0/:1:1","tags":["package","webpack"],"title":"webpack 笔记","uri":"/webpack-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":"plugins 插件用于 bundle 文件的优化，资源管理和环境变量的注入 作用于整个构建过程，如：构建前删除 dist 目录 ","date":"2021-03-21","objectID":"/webpack-%E7%AC%94%E8%AE%B0/:2:0","tags":["package","webpack"],"title":"webpack 笔记","uri":"/webpack-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":"Mode Mode 用来指定当前的构建环境，production，development，none 设置 mode 可以使用 webpack 内置的函数，默认值为 production ","date":"2021-03-21","objectID":"/webpack-%E7%AC%94%E8%AE%B0/:3:0","tags":["package","webpack"],"title":"webpack 笔记","uri":"/webpack-%E7%AC%94%E8%AE%B0/"},{"categories":["docker"],"content":"账号权限 创建 docker 组 sudo groupadd docker 添加用户到该组 sudo usermod -aG docker ${USER} 重新登陆系统 ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:1:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"建立网络 docker network create -d bridge my-net -d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 Swarm mode 每一个 bridge 网络均为独立子网，如果要在 bridge 网络中的容器里访问宿主机网络需要使用 host.docker.internal 来解析宿主机真实地址 ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:2:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"基本命令 docker run -d -P \\ --rm \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html:ro \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\ --network my-net \\ nginx:alpine docker run -d -P --rm --name web --mount type=bind,source=D:\\src\\webapp12345free,target=/usr/share/nginx/html,readonly --network my-net nginx:alpine -P 随机映射暴露端口，使用-p 80:80 指定端口 --rm 容器停止后自动删除容器 --name 指定容器别名 ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"从 Container 拷贝文件到宿主机 # 使用 cp 命令 docker cp f0e212661cd5:/usr/local/etc/janus ./test ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:4:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"导出导入镜像 导出镜像 # docker save -o 要保存的文件名 要保存的镜像 docker save -o test.tar fengrui358/puppeteer_dotnet:aspnetcore5.0 导入镜像 # docker load --input 文件 docker load -i test.tar ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:5:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"常用 Docker 镜像 ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"postgres docker run -d --name er-db --rm -e POSTGRES_PASSWORD=1234 -v /home/free/datadir:/var/lib/postgresql/data -p 25435:5432 postgres:alpine ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:1","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"rabbitmq docker run -d --name er-mq --network er-network --rm -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_VHOST=er -e RABBITMQ_DEFAULT_USER=eruser -e RABBITMQ_DEFAULT_PASS=abc123 rabbitmq:management ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:2","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"Docker Ui Mananger portainer https://www.portainer.io/ docker volume create portainer_data docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer Seagull docker run -d -p 10086:10086 -v /var/run/docker.sock:/var/run/docker.sock tobegit3hub/seagull ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:3","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"npm ","date":"2021-02-12","objectID":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/:1:0","tags":["docker","deploy","resource"],"title":"Docker 国内源地址","uri":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/"},{"categories":["docker"],"content":"使用 nrm 管理 registry 地址 下载 nrm npm install -g nrm 添加 registry 地址 nrm add npm https://registry.npmjs.org nrm add taobao https://registry.npm.taobao.org 切换 npm registry 地址 nrm use taobao nrm use npm ","date":"2021-02-12","objectID":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/:1:1","tags":["docker","deploy","resource"],"title":"Docker 国内源地址","uri":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/"},{"categories":["docker"],"content":"docker 在 /etc/docker/daemon.json 中写入以下配置 { \"registry-mirrors\": [ \"https://mirror.ccs.tencentyun.com\", \"https://registry.cn-hangzhou.aliyuncs.com\", \"https://registry.docker-cn.com\", \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\" ] } 修改完成后重启服务 sudo systemctl daemon-reload sudo systemctl restart docker 参考：https://github.com/yeasy/docker_practice/blob/master/install/mirror.md ","date":"2021-02-12","objectID":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/:2:0","tags":["docker","deploy","resource"],"title":"Docker 国内源地址","uri":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/"},{"categories":["vuejs"],"content":"计算属性和方法的区别 计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值，如下示例，因为 Date.now() 不是响应式依赖，所以下面的计算属性不再更新： computed: { now: function () { return Date.now() } } 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 ","date":"2020-11-15","objectID":"/vuejs-%E7%AC%94%E8%AE%B0/:1:0","tags":["vuejs"],"title":"Vuejs 笔记","uri":"/vuejs-%E7%AC%94%E8%AE%B0/"},{"categories":["vuejs"],"content":"计算属性和侦听属性的区别 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，通常更好的做法是使用计算属性而不是命令式的 watch 回调。 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 ","date":"2020-11-15","objectID":"/vuejs-%E7%AC%94%E8%AE%B0/:2:0","tags":["vuejs"],"title":"Vuejs 笔记","uri":"/vuejs-%E7%AC%94%E8%AE%B0/"},{"categories":["vuejs"],"content":"组件 组件的 data 属性需要是个函数，只有是个函数每个组件实例才可以维护一份被返回的对象的独立的拷贝，如果不是函数所有组件都共享同样的数据。 模板必须位于一个根元素节点下。 prop 可以设置一个带校验规则的对象，包含类型和默认值以及自定义的校验规则。 ","date":"2020-11-15","objectID":"/vuejs-%E7%AC%94%E8%AE%B0/:3:0","tags":["vuejs"],"title":"Vuejs 笔记","uri":"/vuejs-%E7%AC%94%E8%AE%B0/"},{"categories":["vuejs"],"content":"命名规范 属性名推荐使用 camelCase 命名规范 事件名推荐使用 kebab-case 命名规范 ","date":"2020-11-15","objectID":"/vuejs-%E7%AC%94%E8%AE%B0/:4:0","tags":["vuejs"],"title":"Vuejs 笔记","uri":"/vuejs-%E7%AC%94%E8%AE%B0/"},{"categories":["i18n"],"content":"夏令时切换场景 在有些国家会存在夏令时切换的情况，当这种情况出现时会凭空的多出或少去一个小时，这种情况我们的程序是如何处理？又是如何计算时常的呢？ 我们以墨西哥城的时间为例： 墨西哥城的时间墨西哥城的时间 \" 墨西哥城的时间 在 2020 年的 4 月 5 日的凌晨 3 点，会进入夏令时，时间会向前调一个小时，也就是说墨西哥城不会存在 2020 年 4 月 5 日 2 点到 2020 年 4 月 5 日 2 点 59 分的任何时间值。 ","date":"2020-11-03","objectID":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/:1:0","tags":["dotnet","i18n"],"title":"夏令时切换时间如何计算","uri":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/"},{"categories":["i18n"],"content":"消失的一个小时 下面我们用代码验证一下这个猜想 ","date":"2020-11-03","objectID":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/:2:0","tags":["dotnet","i18n"],"title":"夏令时切换时间如何计算","uri":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/"},{"categories":["i18n"],"content":"C# var miss1 = new DateTime(2020, 4, 25, 2, 0, 0, DateTimeKind.Local); var miss2 = new DateTime(2020, 4, 25, 2, 59, 59, DateTimeKind.Local); 这两个时间都正常生成成功 （未完待续…） ","date":"2020-11-03","objectID":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/:2:1","tags":["dotnet","i18n"],"title":"夏令时切换时间如何计算","uri":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/"},{"categories":["deploy"],"content":"让 .netCore 2.0 的测试在 Azure DevOps 中正确运行需要注意几个地方 要增加 .netCore 的测试程序集目录； imgimg \" img 设置 Speceific location:C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\Common7\\IDE\\Extensions\\TestPlatform 设置 Other console options:/Framework:\".NETCoreApp,Version=v2.0\" imgimg \" img 默认配置会包含 xunit（我是使用的 xunit）的测试程序集，这个是不需要的，会导致测试过程报错，需要将其排除。 imgimg \" img ","date":"2020-10-21","objectID":"/azure-devops-%E8%B8%A9%E5%9D%91/:1:0","tags":["deploy"],"title":"Azure DevOps 踩坑","uri":"/azure-devops-%E8%B8%A9%E5%9D%91/"},{"categories":["deploy"],"content":"将程序集打包发布到 Nuget 并支持远程调试 程序集的项目文件需要加入打包相关配置： \u003c!-- Optional: Publish the repository URL in the built .nupkg (in the NuSpec \u003cRepository\u003e element) --\u003e \u003cPublishRepositoryUrl\u003etrue\u003c/PublishRepositoryUrl\u003e \u003c!-- Optional: Embed source files that are not tracked by the source control manager in the PDB --\u003e \u003cEmbedUntrackedSources\u003efalse\u003c/EmbedUntrackedSources\u003e \u003c!-- Optional: Build symbol package (.snupkg) to distribute the PDB containing Source Link --\u003e \u003cIncludeSymbols\u003etrue\u003c/IncludeSymbols\u003e \u003cSymbolPackageFormat\u003esnupkg\u003c/SymbolPackageFormat\u003e \u003cPackageLicenseExpression\u003eMIT\u003c/PackageLicenseExpression\u003e 特别是 License 节点，在本地 push 的时候不会出问题，在 Azure DevOps 环境下 Push 没有这个会出问题，不能够远程调试。 引入 SourceLink 程序集，下面是以代码提交到 GitHub 为例： \u003cItemGroup\u003e \u003cPackageReference Include=\"Microsoft.SourceLink.GitHub\" Version=\"1.0.0\" PrivateAssets=\"All\" /\u003e \u003c/ItemGroup\u003e 其他平台对应的 lib 可参考 https://github.com/dotnet/sourcelink 然后将程序集 push 到 nuget.org 时也会同时将 snupkg 文件 push 到符号服务器 要使用远程调试需要对 Visual Studio 做一些配置 imgimg \" img imgimg \" img ","date":"2020-10-21","objectID":"/azure-devops-%E8%B8%A9%E5%9D%91/:2:0","tags":["deploy"],"title":"Azure DevOps 踩坑","uri":"/azure-devops-%E8%B8%A9%E5%9D%91/"},{"categories":["router"],"content":"路由器型号，华硕 AC3100 梅林固件下载地址：https://www.asuswrt-merlin.net/download 具体下载地址格式：https://tenet.dl.sourceforge.net/project/asuswrt-merlin/RT-AC3100/Release/RT-AC3100_384.19_0.zip KoolShare 改版固件（带软件中心）：https://firmware.koolshare.cn/ AC3100（armv7 架构）梅林改下载地址：https://koolshare.cn/thread-164857-1-1.html SS 下载地址：https://github.com/hq450/fancyss_history_package ML 改的固件中的软件中心已经屏蔽了 ss 的离线安装，于是使用手动安装方式： 使用命令拷贝对应的文件到路由器 scp -P 45 E:\\Download\\shadowsocks.tar.gz admin@192.168.1.1:/tmp 具体命令如下： cd /tmp wget –no-check-certificate https://raw.githubusercontent.com/koolshare/koolshare.github.io/acelan_softcenter_ui/shadowsocks/shadowsocks.tar.gz tar -zxvf /tmp/shadowsocks.tar.gz chmod +x /tmp/shadowsocks/install.sh sh /tmp/shadowsocks/install.sh ","date":"2020-10-19","objectID":"/%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE/:0:0","tags":["router","deploy"],"title":"华硕路由器梅林固件设置","uri":"/%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE/"},{"categories":["router"],"content":"最新版 win10 访问路由器 USB 共享 需要设置注册表\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters \"AllowInsecureGuestAuth\"=dword:1 参考链接：https://huyangjia.com/merlin-firmware-installation-ss-plug-in-tutorial.html ","date":"2020-10-19","objectID":"/%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE/:1:0","tags":["router","deploy"],"title":"华硕路由器梅林固件设置","uri":"/%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE/"},{"categories":["package"],"content":"创建 npm 包 为了创建全平台适用的 npm 包，这里使用了一个第三方的脚手架 jslib 来创建项目工程。 使用 npm 全局安装 jslib，npm i -g @js-lib/cli。 运行 jslib new mylib 创建新的工程，会有一段交互式输入，按需填写。 在 src 目录下完成工程代码的逻辑编写。 ","date":"2020-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:1:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["package"],"content":"修改 version 提交所有修改，执行命令修改版本号。 # patch：这个是补丁的意思，补丁最合适； # minor：这个是小改； # major：这个是大改； npm version patch npm version minor npm version major ","date":"2020-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:2:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["package"],"content":"更改 registry 使用 npm config get registry 查看 registry 配置，如果不是 https://registry.npmjs.org，需要运行 npm config set registry https://registry.npmjs.org 进行修改，包上传完毕后修改为淘宝环境 https://registry.npm.taobao.org 加速 npm。 ","date":"2020-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:3:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["package"],"content":"登陆 npm 使用 npm login 进入交互式输入，输入用户名密码登陆。 ","date":"2020-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:4:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["package"],"content":"发布 使用 npm publish 发布包。 ","date":"2020-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:5:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["javascript"],"content":"类库 lodash：是一个通过 Lodash 限制操作频率的函数。 axios: Ajax 库。 ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:1:0","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"代码片段 ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:0","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"查看对象类型 使用 Object.prototype.toString 方法，通过第二个参数返回的构造函数判断对象类型 Object.prototype.toString.call(2); // \"[object Number]\" Object.prototype.toString.call(\"\"); // \"[object String]\" Object.prototype.toString.call(true); // \"[object Boolean]\" Object.prototype.toString.call(undefined); // \"[object Undefined]\" Object.prototype.toString.call(null); // \"[object Null]\" Object.prototype.toString.call(Math); // \"[object Math]\" Object.prototype.toString.call({}); // \"[object Object]\" Object.prototype.toString.call([]); // \"[object Array]\" ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:1","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"JavaScript 对象的元属性 { value: 123, writable: false, enumerable: true, configurable: false, get: undefined, set: undefined } ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:2","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"将类似于数组的对象转换为数组 slice() 方法的一个重要应用，是将类似数组的对象转为真正的数组。 Array.prototype.slice.call({ 0: \"a\", 1: \"b\", length: 2 }); // ['a', 'b'] Array.prototype.slice.call(document.querySelectorAll(\"div\")); Array.prototype.slice.call(arguments); ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:3","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"构造函数 为了保证构造函数必须与 new 命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上 use strict。这样的话，一旦忘了使用 new 命令，直接调用构造函数就会报错。 function Fubar(foo, bar) { \"use strict\"; this._foo = foo; this._bar = bar; } Fubar(); // TypeError: Cannot set property '_foo' of undefined 另一个解决办法，构造函数内部判断是否使用 new 命令，如果发现没有使用，则直接返回一个实例对象。 function Fubar(foo, bar) { if (!(this instanceof Fubar)) { return new Fubar(foo, bar); } this._foo = foo; this._bar = bar; } Fubar(1, 2)._foo( // 1 new Fubar(1, 2) )._foo; // 1 如果构造函数内部有 return 语句，而且 return 后面跟着一个对象，new 命令会返回 return 语句指定的对象；否则，就会不管 return 语句，返回 this 对象。 函数内部可以使用 new.target 属性。如果当前函数是 new 命令调用，new.target 指向当前函数，否则为 undefined。 ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:4","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"防止脚本篡改 为了防止攻击者篡改外部脚本，script 标签允许设置一个 integrity 属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。 \u003cscript src=\"/assets/application.js\" integrity=\"sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=\" \u003e\u003c/script\u003e ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:5","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"使用正则表达式提取解构值 用正则表达式的 exec() 方法匹配字符串会返回一个数组，该数组第一个值是完全匹配正则表达式的字符串，然后的值是匹配正则表达式括号内内容部分。解构赋值允许你轻易地提取出需要的部分，忽略完全匹配的字符串——如果不需要的话。 function parseProtocol(url) { var parsedURL = /^(\\w+)\\:\\/\\/([^\\/]+)\\/(.*)$/.exec(url); if (!parsedURL) { return false; } console.log(parsedURL); // [\"https://developer.mozilla.org/en-US/Web/JavaScript\", \"https\", \"developer.mozilla.org\", \"en-US/Web/JavaScript\"] var [, protocol, fullhost, fullpath] = parsedURL; return protocol; } console.log( parseProtocol(\"https://developer.mozilla.org/en-US/Web/JavaScript\") ); // \"https\" ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:6","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"匹配 Unicode 属性 // 匹配所有数字 const regex = /^\\p{Number}+$/u; regex.test('²³¹¼½¾') // true regex.test('㉛㉜㉝') // true regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true // 匹配所有空格 \\p{White_Space} // 匹配各种文字的所有字母，等同于 Unicode 版的 \\w [\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W [^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配 Emoji /\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu // 匹配所有的箭头字符 const regexArrows = /^\\p{Block=Arrows}+$/u; regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true //解构赋值 let {groups: {one, two}} = /^(?\u003cone\u003e.*):(?\u003ctwo\u003e.*)$/u.exec('foo:bar'); one // foo two // bar ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:7","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"尾递归优化技巧，蹦床函数（trampoline） function trampoline(f) { while (f \u0026\u0026 f instanceof Function) { f = f(); } return f; } 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要 f 执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 function sum(x, y) { if (y \u003e 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } 上面代码中，sum 函数的每次执行，都会返回自身的另一个版本。现在，使用蹦床函数执行 sum，就不会发生调用栈溢出。 ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:8","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":" 客户端下载，nuget.exe：https://www.nuget.org/downloads NuGetPackageExplorer（可视化的创建包管理器）：https://github.com/NuGetPackageExplorer/NuGetPackageExplorer nuspec.xsd 创建包的文件清单的 XML 架构文件：https://github.com/NuGet/NuGet.Client/blob/dev/src/NuGet.Core/NuGet.Packaging/compiler/resources/nuspec.xsd .nuspec 引用相关资料：https://docs.microsoft.com/zh-cn/nuget/schema/nuspec#replacement-tokens 依赖版本描述语义：https://docs.microsoft.com/zh-cn/nuget/reference/package-versioning#pre-release-versions 转换源代码和配置文件相关：https://docs.microsoft.com/zh-cn/nuget/create-packages/source-and-config-file-transformations PowerShell 参考：https://docs.microsoft.com/zh-cn/nuget/tools/powershell-reference ","date":"2020-07-15","objectID":"/nuget-%E8%B5%84%E6%BA%90/:0:0","tags":["dotnet","nuget","package"],"title":"NuGet 资源","uri":"/nuget-%E8%B5%84%E6%BA%90/"},{"categories":["dotnet"],"content":"RabbitMQ，提供负载均衡的消息队列功能，自动化的将消息按规则分配到不同消费者身上。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:0:0","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"安装 RabbitMQ 安装非常简单，首先安装 Erlang，然后安装服务端程序https://www.rabbitmq.com/install-windows.html。 安装完毕后启动可视化管理功能，在开始菜单中找到 RabbitMQ Server，运行 RabbitMQ Command Prompt，然后在控制台中执行两条命令： rabbitmq-plugins enable rabbitmq_management 然后通过链接地址：http://localhost:15672 即可在本地访问管理界面，默认本地访问的用户名和密码均为：guest。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:1:0","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"入门 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:0","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"ConnectionFactory Socket 链接的创建工厂，除了HostName、VirtualHost、UserName、Password几个常见参数外，还有个比较重要的自动重连参数：AutomaticRecoveryEnabled，该参数默认为false，与之相关的还有一个自动重连的尝试间隔NetworkRecoveryInterval，该参数默认值为 5 秒。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:1","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"IConnection 通过 ConnectionFactory 的 CreateConnection 可以构造一个 IConnection 的接口，一个这个接口的实例就代表了一个真正的 TCP Socket 链接。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:2","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"IModel 通过 IConnection 的 CreateModel 方法创建，抽象的信息通道，然后通过通道可创建和使用队列、交换机。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:3","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"EventingBasicConsumer 实例化一个事件消费者，构造时传入 IModel，然后可以异步订阅消息。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:4","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"BasicPublish 通过 IModel 的 BasicPublish 方法可以向交换机发送信息并指定路由标识。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:5","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"Tutorials https://github.com/rabbitmq/rabbitmq-tutorials ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:6","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["resource"],"content":"因受国内的环境影响，导致了很多速度起不来，所以需要安装国内镜像。 ","date":"2020-05-12","objectID":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/:0:0","tags":["npm","resource","package"],"title":"NPM 和 Yarn 使用国内淘宝镜像源提升各依赖安装速度","uri":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/"},{"categories":["resource"],"content":"配置 NPM 的淘宝镜像源加速 打开 poweshell 或 cmd 工具，输入以下命令： npm config set registry https://registry.npm.taobao.org npm config set disturl https://npm.taobao.org/dist npm config set electron_mirror https://npm.taobao.org/mirrors/electron/ npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ npm config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ 然后输入命令 npm get registry 得到返回结果为 https://registry.npm.taobao.org/ 说明注册成功。 ","date":"2020-05-12","objectID":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/:1:0","tags":["npm","resource","package"],"title":"NPM 和 Yarn 使用国内淘宝镜像源提升各依赖安装速度","uri":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/"},{"categories":["resource"],"content":"windows 下 Yarn 安装与使用 如果你还没有安装 Yarn，通过访问 https://classic.yarnpkg.com/latest.msi，下载安装包。双击安装后，输入命令 yarn -v 返回版本号 1.22.4 即表示成功。 ","date":"2020-05-12","objectID":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/:2:0","tags":["npm","resource","package"],"title":"NPM 和 Yarn 使用国内淘宝镜像源提升各依赖安装速度","uri":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/"},{"categories":["resource"],"content":"Yarn 注册淘宝镜像源加速 打开 poweshell 或 cmd 工具，输入以下命令： yarn config set registry https://registry.npm.taobao.org -g yarn config set disturl https://npm.taobao.org/dist -g yarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ -g yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -g yarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ -g yarn config set chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriver -g yarn config set operadriver_cdnurl https://cdn.npm.taobao.org/dist/operadriver -g yarn config set fse_binary_host_mirror https://npm.taobao.org/mirrors/fsevents -g 然后输入命令，查看当前地址源： yarn config get registry 得到返回结果为 https://registry.npm.taobao.org/ 说明注册成功。 本文作为资源记录，转载自：https://mp.weixin.qq.com/s/3LQVKnEY4Fk7UTtMBN5YxA ","date":"2020-05-12","objectID":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/:3:0","tags":["npm","resource","package"],"title":"NPM 和 Yarn 使用国内淘宝镜像源提升各依赖安装速度","uri":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/"},{"categories":["dotnet"],"content":"今天测试人员报公司的 WPF 程序启动崩溃，下面记录这个问题的跟踪流程。 首先排除是否为发版问题，向测试要了测试环境的程序，运行奔溃，观察日志报 System.OutOfMemoryException； 启用本地 Debug 程序运行，发现内存快速增长直到进程崩溃； 启动 Visual Studio 的性能跟踪工具，跟踪内存增长，由于进程一启动内存就快速增长来不及做快照，故在代码中做了启动延时处理。拍下快照，对比内存快照，发现托管内存没有增加，判断为非托管内存溢出； 由于这是个启动就能出现的问题，启动代码也不多，就尝试注释一些代码来缩小问题范围，当注释掉 CefSharp 的初始化代码后程序就正常了，进而判断内存溢出出现在 CefSharp 内部； 回退代码到一周前，启动程序后问题照旧，到这时就很诡异了，因为最近这个程序我们在开发环境下都是经常运行的，从来没出现过这个一启动就能发现的问题，而今天一周前的代码都出现了问题，这就排除是代码修改造成的； 初步判断是环境问题造成，这时候注意到公司的网络不能访问 google 了，之前公司是提供了梯子的，只要开启自动检测代理就能“出国”。我刚开始猜测 Cef 是 google 的嵌入式浏览器，难道它要访问 google 的服务？我首先尝试禁用网卡，程序奇迹般的正常了，虽然业务不可用，但是内存不涨了，证明它不需要访问 google 的服务。然后我关掉代理自动检测，程序也完全正常了。 总结一下，我没有去搜索这个问题，因为不太好描述，只能大概猜测这个问题的原因：Cef 是嵌入的一个独立浏览器进程，和我们程序进程通讯应该通过了网卡，现在公司代理有问题，导致通讯出了问题，非托管内存就溢出了。但这个问题只出现在代理故障的情况，代理正常、关闭代理甚至关闭网卡 Cef 都是正常的，于是猜测是不是公司代理配置出现了什么回路之类的导致程序通信消耗内存暴增。整个问题的追踪很有意思，耗时大概两个小时，这还需要一定经验和灵光乍现才能想到网卡设备这个层面。 ","date":"2020-04-16","objectID":"/cefsharp-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/:0:0","tags":["dotnet","wpf","cef"],"title":"CefSharp 内存溢出问题排查","uri":"/cefsharp-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"categories":["dotnet"],"content":"添加 AnyCPU 支持 需要在项目配置文件的第一个 \u003cPropertyGroup\u003e 节点中添加 \u003cCefSharpAnyCpuSupport\u003etrue\u003c/CefSharpAnyCpuSupport\u003e WPF 启动时代码如下： public partial class App : Application { public App() { //Add Custom assembly resolver AppDomain.CurrentDomain.AssemblyResolve += Resolver; //Any CefSharp references have to be in another method with NonInlining // attribute so the assembly rolver has time to do it's thing. InitializeCefSharp(); } [MethodImpl(MethodImplOptions.NoInlining)] private static void InitializeCefSharp() { var settings = new CefSettings(); // Set BrowserSubProcessPath based on app bitness at runtime settings.BrowserSubprocessPath = Path.Combine(AppDomain.CurrentDomain.SetupInformation.ApplicationBase, Environment.Is64BitProcess ? \"x64\" : \"x86\", \"CefSharp.BrowserSubprocess.exe\"); // Make sure you set performDependencyCheck false Cef.Initialize(settings, performDependencyCheck: false, browserProcessHandler: null); } // Will attempt to load missing assembly from either x86 or x64 subdir // Required by CefSharp to load the unmanaged dependencies when running using AnyCPU private static Assembly Resolver(object sender, ResolveEventArgs args) { if (args.Name.StartsWith(\"CefSharp\")) { string assemblyName = args.Name.Split(new[] { ',' }, 2)[0] + \".dll\"; string archSpecificPath = Path.Combine(AppDomain.CurrentDomain.SetupInformation.ApplicationBase, Environment.Is64BitProcess ? \"x64\" : \"x86\", assemblyName); return File.Exists(archSpecificPath) ? Assembly.LoadFile(archSpecificPath) : null; } return null; } } 引入 Cef 后程序体积增加 347 MB（x64 和 x86 各占一半） win7 下要正常使用 Cef 安装 https://www.microsoft.com/en-us/download/details.aspx?id=48145 参考 https://www.shuzhiduo.com/A/n2d9QqgVdD/ win8 参考 https://www.shuzhiduo.com/A/1O5ElwVGJ7/ ","date":"2020-04-08","objectID":"/wpf-%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8-cefsharp/:1:0","tags":["dotnet","wpf","cef"],"title":"WPF 程序使用 CefSharp","uri":"/wpf-%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8-cefsharp/"},{"categories":["wpf"],"content":"WPF 桌面程序中使用图片有多种方式，他们具有一些如下特点: 特点/类型 PNG SVG Path Font IconFont 性能 好 差 中 好 中 改变颜色 不支持 不支持 支持 支持 支持 改变大小 不支持 支持 支持 支持（不友好） 支持 多色彩支持 支持 支持 不支持 不支持 不支持 ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:0:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"PNG 位图是使用最多的一种方式，也是 WPF 原生 Image 控件支持的一种方式，性能是几种方式当中最好的，不过它的缺点是不支持改变图片颜色和大小（改变大小后会有模糊和锯齿），当一个项目大了之后项目中会有很多形状类似，但可能大小和颜色有细微差别的图片，会造成项目难以管理。（下图是性能对比，是在一个窗口中初始化 3000 个控件的耗时） PNGPNG \" PNG ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:1:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"SVG SVG 是常用的一种矢量图，浏览器对 SVG 也是可以直接支持。SVG 矢量图的好处是美工可以直接出图，程序员可以不用再进行二次转换，而且矢量图可以做出各种彩色的复杂图形。但是 WPF 对 SVG 却不能原生支持，不过我们还是能比较轻松地在网上找到很多现成的解决方案，如图，是 SVG 的性能。 SVGSVG \" SVG ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:2:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"Path Path 是 WPF 中描述矢量图的常用方式，著名的 WPF 开源项目 MahApps.Metro 里的有一个使用矢量图的控件 Metro.IconPacks 就是对 Path 的封装，下面是该控件的性能。 PathPath \" Path ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:3:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"IconFont 目前 Web 前端中用的非常多的一种矢量图片就是文字，经过测试，它的性能介于接近最快的 PNG，经过封装以后它的易用性可以达到 MahApps.Metro 的水平，并且它指定的高宽参数能够最贴近 UI 人员的设计意图。并且我写了一个小工具可以从 https://www.iconfont.cn/ 下载项目图标，直接转换为程序可用的强类型引用，使代码可以很方便的使用 .ttf 字体文件中的字体作为图标。 ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:4:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"资源路径如下 测试工具地址：https://github.com/fengrui358/WPFLabs/tree/master/WpfLabs/WpfLabs/ImagePerformanceDemo 图标转换工具地址：https://github.com/fengrui358/IconFontForWPF ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:5:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["dotnet"],"content":"本文基于 Automapper 9.0.0 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"诊断 Automapper 的属性映射过程 var cfg = new MapperConfigurationExpression(); cfg.CreateMap\u003cTypeB, TypeA\u003e(); var configuration = new MapperConfiguration(cfg); var executionPlan = configuration.BuildExecutionPlan(typeof(TypeB), typeof(TypeA)); 最关键的一行代码 var executionPlan = configuration.BuildExecutionPlan(typeof(TypeB), typeof(TypeA));，此时查看 executionPlan 可以看到它对应的表达式树解析，看到属性如何映射。这里有个小技巧，安装 Visual Studio 插件 ReadableExpressions VS extension 可以更清晰的看到表达式树解析。需要注意应该在正式发布时移除所有的调试代码。 参考http://docs.automapper.org/en/stable/Understanding-your-mapping.html ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"自动映射属性 Automapper 会自动按照属性名去匹配映射关系，在默认映射中有以下一些特点： 不会区分属性名大小写，只要名称一样，大小写不一致也能够转换； 不会严格要求类型，字符串数值之间可以互相转换； 如果没匹配对应的属性，会继续寻找带 Get 前缀的方法名，也可以自动对目标类型进行 PascalCase 约定的 分词查找，按照分词的顺序可以在源类型中深度查找内部对象。 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"类的成员对象向外映射 类型映射时想要映射的是 Source 类型的内部成员对象时，创建映射时需要加 IncludeMembers。 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"配置校验，测试映射关系 Automapper 的映射是基于约定的，并不是强类型之间的手动映射，一个典型的应用场景是创建好映射之后，过了一段时间可能属性名变了，就会造成潜在的 Bug，这时候就需要使用配置校验 Configuration Validation，如下： var configuration = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, Destination\u003e()); configuration.AssertConfigurationIsValid(); 默认的校验规则是需要检查目标的每个属性都需要在来源中有映射，否则抛出异常。 有两种方式方式修改默认的校验规则： 使用 Ignore()，var configuration = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, Destination\u003e().ForMember(dest =\u003e dest.SomeValuefff, opt =\u003e opt.Ignore())); CreateMap 的时候修改校验规则，使用 MemberList.Source 或 MemberList.None ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"集合映射 如果要映射集合只需要映射集合对应的元素类型，支持的集合映射类型如下： IEnumerable IEnumerable\u003cT\u003e ICollection ICollection\u003cT\u003e IList IList\u003cT\u003e List\u003cT\u003e Arrays 如果要映射到一个已存在的集合，目标集合首先会被清空，具体详见 AutoMapper.Collection 如果源的属性里有集合对象，并且属性为空，那么当它映射到目标时，会把属性映射为空集合，这一点符合 C# 关于集合的定义，数组、列表、集合、字典和 IEnumerables 永远不应该为 null。在配置映射器时，可以通过将 AllowNullCollections 属性设置为 true 来更改此行为。 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"全局类型转换 Type Converters 在创建配置时使用 ConvertUsing，这个配置是全局的，只需要调用一次，它有以下三种重载方式： void ConvertUsing(Func\u003cTSource, TDestination\u003e mappingFunction); void ConvertUsing(ITypeConverter\u003cTSource, TDestination\u003e converter); void ConvertUsing\u003cTTypeConverter\u003e() where TTypeConverter : ITypeConverter\u003cTSource, TDestination\u003e; ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"需要自定义源到目标之间的转换逻辑 Value Resolvers 当出现需要自定义转换逻辑时，主要使用以下接口： public interface IValueResolver\u003cin TSource, in TDestination, TDestMember\u003e { TDestMember Resolve(TSource source, TDestination destination, TDestMember destMember, ResolutionContext context); } 使用 IValueResolver 接口有以下三种方式： MapFrom\u003cTValueResolver\u003e MapFrom(typeof(CustomValueResolver)) MapFrom(aValueResolverInstance) 除以上之外还可以继承 IMemberValueResolver 接口，这个接口比上面那个多了来源属性的指定。 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"解析条件 如果我们指定了属性成员的映射，那在正式转换时可能会引发异常，这时候可以进行前置条件判断。 public class SourceClass { public string Value { get; set; } } public class TargetClass { public int ValueLength { get; set; } } // ... var source = new SourceClass { Value = null }; var target = new TargetClass; CreateMap\u003cSourceClass, TargetClass\u003e() .ForMember(d =\u003e d.ValueLength, o =\u003e o.MapFrom(s =\u003e s.Value.Length)) .ForAllMembers(o =\u003e o.Condition((src, dest, value) =\u003e value != null)); .ForMember(d =\u003e d.ValueLength, o =\u003e o.MapFrom(s =\u003e s != null ? s.Value.Length : 0)) ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"Value Converters 介于 Type Converters 和 Value Resolvers 之间的值转换方式： Type converter = Func\u003cTSource, TDestination, TDestination\u003e Value resolver = Func\u003cTSource, TDestination, TDestinationMember\u003e Member value resolver = Func\u003cTSource, TDestination, TSourceMember, TDestinationMember\u003e Value converter = Func\u003cTSourceMember, TDestinationMember\u003e 在成员级别配置该转换器 public class CurrencyFormatter : IValueConverter\u003cdecimal, string\u003e { public string Convert(decimal source) =\u003e source.ToString(\"c\"); } var configuration = new MapperConfiguration(cfg =\u003e { cfg.CreateMap\u003cOrder, OrderDto\u003e() .ForMember(d =\u003e d.Amount, opt =\u003e opt.ConvertUsing(new CurrencyFormatter())); cfg.CreateMap\u003cOrderLineItem, OrderLineItemDto\u003e() .ForMember(d =\u003e d.Total, opt =\u003e opt.ConvertUsing(new CurrencyFormatter())); }); 如果属性的名称不能匹配，使用以下方式 public class CurrencyFormatter : IValueConverter\u003cdecimal, string\u003e { public string Convert(decimal source) =\u003e source.ToString(\"c\"); } var configuration = new MapperConfiguration(cfg =\u003e { cfg.CreateMap\u003cOrder, OrderDto\u003e() .ForMember(d =\u003e d.Amount, opt =\u003e opt.ConvertUsing(new CurrencyFormatter(), src =\u003e src.OrderAmount)); cfg.CreateMap\u003cOrderLineItem, OrderLineItemDto\u003e() .ForMember(d =\u003e d.Total, opt =\u003e opt.ConvertUsing(new CurrencyFormatter(), src =\u003e src.LITotal)); }); ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"值转换 在值转换前判断是否应用了值转换器，可以在以下地方使用值转换器： Globally Profile Map Member var configuration = new MapperConfiguration(cfg =\u003e { cfg.ValueTransformers.Add\u003cstring\u003e(val =\u003e val + \"!!!\"); }); var source = new Source { Value = \"Hello\" }; var dest = mapper.Map\u003cDest\u003e(source); dest.Value.ShouldBe(\"Hello!!!\"); ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"Null 转换 如果来源值为空，可以使用空转换器来给目标属性赋值，而不是使用源值 var config = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, Dest\u003e() .ForMember(destination =\u003e destination.Value, opt =\u003e opt.NullSubstitute(\"Other Value\"))); var source = new Source { Value = null }; var mapper = config.CreateMapper(); var dest = mapper.Map\u003cSource, Dest\u003e(source); dest.Value.ShouldEqual(\"Other Value\"); source.Value = \"Not null\"; dest = mapper.Map\u003cSource, Dest\u003e(source); dest.Value.ShouldEqual(\"Not null\"); ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"映射前后逻辑处理 偶尔需要在映射时进行一些逻辑处理，可使用如下方式： var configuration = new MapperConfiguration(cfg =\u003e { cfg.CreateMap\u003cSource, Dest\u003e() .BeforeMap((src, dest) =\u003e src.Value = src.Value + 10) .AfterMap((src, dest) =\u003e dest.Name = \"John\"); }); 或者继承接口 IMappingAction： public class NameMeJohnAction : IMappingAction\u003cSomePersonObject, SomeOtherPersonObject\u003e { public void Process(SomePersonObject source, SomeOtherPersonObject destination, ResolutionContext context) { destination.Name = \"John\"; } } var configuration = new MapperConfiguration(cfg =\u003e { cfg.CreateMap\u003cSomePersonObject, SomeOtherPersonObject\u003e() .AfterMap\u003cNameMeJohnAction\u003e(); }); ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"构造函数映射 如果目标类型没有默认的构造函数，Automapper 支持根据构造函数的形参名称来自动匹配源属性。 public class Source { public int Value { get; set; } } public class SourceDto { public SourceDto(int value) { _value = value; } private int _value; public int Value { get { return _value; } } } var configuration = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, SourceDto\u003e()); 如果构造函数的参数名称无法自动匹配，可以使用 ForCtorParam 来手动指定 public class Source { public int Value { get; set; } } public class SourceDto { public SourceDto(int valueParamSomeOtherName) { _value = valueParamSomeOtherName; } private int _value; public int Value { get { return _value; } } } var configuration = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, SourceDto\u003e() .ForCtorParam(\"valueParamSomeOtherName\", opt =\u003e opt.MapFrom(src =\u003e src.Value)) ); 如果要禁用构造函数映射 var configuration = new MapperConfiguration(cfg =\u003e cfg.DisableConstructorMapping()); 也可以选择要调用的目标构造函数 // don't map private constructors var configuration = new MapperConfiguration(cfg =\u003e cfg.ShouldUseConstructor = ci =\u003e !ci.IsPrivate); 参考：http://docs.automapper.org/en/stable/index.html ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["css"],"content":"文本与段落 加载本地字体，通常按照从特殊到一般 font-family: Arial, 'Microsoft Yahei', sans-serif; 加载 web 字体 @font-face { font-family: 'webfont'; src: url('webfont.woff'); } font-family: 'webfont', Arial, 'Microsoft Yahei', sans-serif; 颜色 color: #077f3c; 大小 font-size: 28px; 字符间距 letter-spacing: 4px; 文本方向 writing-mode: vertical-rl; text-orientation: mixed; 文本样式 text-decoration: underline line-through; 行间距 line-height: 36px; 缩进 text-indent: 2em; 折行 white-space: nowrap; 省略 white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 对齐 text-align: justify; 设置背景颜色 background-color: #8be5ac; 加载背景图片 background-image: url(./bg.jpg); 调整背景尺寸 background-size: 50px; 调整背景填充 background-repeat: no-repeat; 调整背景位置 雪碧图通常使用该属性实现 background-position: center center; 调整背景拉伸 background-size: contain; /* 充满容器，可能会留白 */ background-size: cover; /* 充满容器，可能会裁剪 */ ","date":"2019-11-15","objectID":"/css-%E8%B5%84%E6%BA%90/:1:0","tags":["css","resource"],"title":"CSS 资源","uri":"/css-%E8%B5%84%E6%BA%90/"},{"categories":["css"],"content":"外发光悬空阴影 box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23); 外发光悬空阴影外发光悬空阴影 \" 外发光悬空阴影 ","date":"2019-11-15","objectID":"/css-%E8%B5%84%E6%BA%90/:2:0","tags":["css","resource"],"title":"CSS 资源","uri":"/css-%E8%B5%84%E6%BA%90/"},{"categories":["css"],"content":"HSL 定义 HSL 颜色 色相（H） 是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。 饱和度（S） 是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0-100% 的数值。 亮度（L） ，取 0-100%，增加亮度，颜色会向白色变化；减少亮度，颜色会向黑色变化。 https://www.runoob.com/cssref/func-hsl.html 参考：https://www.bilibili.com/video/BV1654y1m76w?p=1\u0026share_medium=iphone\u0026share_plat=ios\u0026share_source=COPY\u0026share_tag=s_i×tamp=1598287257\u0026unique_k=KP2sHN ","date":"2019-11-15","objectID":"/css-%E8%B5%84%E6%BA%90/:3:0","tags":["css","resource"],"title":"CSS 资源","uri":"/css-%E8%B5%84%E6%BA%90/"},{"categories":["ide"],"content":"专栏地址：https://time.geekbang.org/column/article/40098 ","date":"2019-10-13","objectID":"/visual-studio-code-%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["ide","vscode"],"title":"Visual Studio Code 专栏学习笔记","uri":"/visual-studio-code-%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"常用命令 打开命令面板：Ctrl+Shift+P F1 Cmd 窗口命令：Code，Code --help查看命令帮助，Cmd 命令加| Code -可直接将 Cmd 命令的结果输出到 VS Code 的一个页面中，方便后续操作 编辑操作： 删除当前行：Ctrl+Shift+K 剪切当前行：Ctrl+Shift+X 复制当前行：Ctrl+Shift+C 新起一行到下一行：Ctrl+Enter 新起一行到上一行：Ctrl+Shift+Enter 当前行向上\\下移动：Alt+↑\\↓ 向上\\下复制当前行：Alt+Shift+↑\\↓ 添加行注释：Ctrl+/ 添加块注释：Alt+Shift+A 代码格式化（需安装各个语言对应的插件）：Alt+Shift+F 选中段代码格式化：Ctrl+K Ctrl+F 光标回退到之前位置：Ctrl+U 在一个函数的括号中跳转：Ctrl+Shift+\\ 多光标：Ctrl+Alt+鼠标 Ctrl+Alt+↑\\↓ Ctrl+D Ctrl+D(选中重复的单词为他们生成多光标) Alt+Shift+I 展开文件列表：Ctrl+Tab 然后按住Ctrl 按下Tab即可在文件列表中切换 展开文件列表并搜索：Ctrl+P 在文件列表中按下Ctrl+Enter可在新窗口打开选中的文件 Ctrl+P+文件名+冒号+行号 可跳转到指定文件的指定行号 跳转到指定行号：Ctrl+G 在一个文件的类、方法中跳转：Ctrl+Shift+O Ctrl+Shift+O+冒号 可对当前文件中的符号进行分类 在多个文件中进行符号跳转：Ctrl+T 跳转到符号定义：Ctrl+F12 F12 跳转到符号引用：Shift+F12 鼠标操作：连续3次按下鼠标左键选中当前行 连续4次按下鼠标左键选中当前文档所有文本 选择行号可选中当前行 选中文本+Alt 移动光标可复制选中段 鼠标悬停+按住Ctrl 提示当前悬停位置的额外信息 触发建议：命令面板中输入\"Trigger Suggest\"，默认快捷键为Ctrl+Space，修改为Alt+Enter 跳转：跳转回上一次光标位置Alt+Left，跳转到下一次光标位置Alt+Right，可通过命令跳转到上一次编辑所在位置 粘贴：粘贴富文本Ctrl+V，粘贴纯文本Ctrl+Shift+V 选中当前行：Ctrl+I 自动补全： 函数签名预览：Ctrl+Space 函数参数预览：Ctrl+Shift+Space 自动补全：在设置中搜索Editor.Suggest可修改编辑推荐参数 快速修复：绿色波浪线上点击Ctrl+. 重构 重命名：F2 鼠标选中可提取成单独的函数 代码片段 在命令面板中配置代码片段：Configure User Snippets 输入代码片段中的prefix可提示代码片段，按Tab输出代码片段，再按Tab在占位符间切换，按Shift+Tab在占位符中反向切换。 代码片段占位符{1:label}，代码片段内置变量说明：https://code.visualstudio.com/docs/editor/userdefinedsnippets#_variables 代码折叠 折叠选中部分的括号：Ctrl+Shift+[ 递归折叠当前选中部分的括号：Ctrl+K Ctrl+[ 折叠所有可折叠的部分：Ctrl+K Ctrl+0 展开所有可展开的部分：Ctrl+K Ctrl+J 标记折叠，不同语言有不同的折叠方式，请参考：https://code.visualstudio.com/docs/editor/codebasics#_folding 折叠标记和展开标记的快捷键分别是：Ctrl+K Ctrl+8 Ctrl+K Ctrl+9 小地图相关设置：editor.minimap 面包屑相关设置：breadcrumbs.enabled 搜索 单文件搜索：Ctrl+F(鼠标切换到搜索框) F3(鼠标停留在文本编辑页面) Shift+F3(反向跳转) 搜索设置：Alt+C(切换大小写) Alt+W(切换全词匹配) Alt+R(切换正则搜索) 替换搜索：Ctrl+H Tab Shift+Tab(可在替换框中切换) 多文件搜索：Ctrl+Shift+F 编辑器设置 设置行号：editor.lineNumbers 渲染空格或制表符：editor.renderWhitespace 缩进竖线：editor.renderIndentGuides 行字符数量控制线：\"editor.rulers\": [20] 鼠标样式控制：editor.cursorBlinking editor.cursorStyle editor.cursorWidth 选中行高亮显示：editor.renderLineHighlight 编辑器制表符和空格设置：editor.detectIndentation editor.insertSpaces editor.tabSize 代码格式自动校正：editor.formatOnSave editor.formatOnType 自动保存控制：files.autoSave files.autoSaveDelay 设置新建文件的默认格式：files.defaultLanguage=markdown 调整自动推荐时间间隔：editor.quickSuggestionsDelay: 0 编辑器设置分类 光标渲染和多光标相关的设置：editor cursor 搜索相关的设置：editor find 字体相关的设置：editor font 代码格式化相关的设置：editor fotmat 自动补全、建议相关的设置：editor suggest 命令面板 命令历史记录：workbench.commandPalette.history 命令面板打开时保留之前的输入：workbench.commandPalette.preserveInput 多文件夹工作区 打开最近访问的文件或文件夹：Ctrl+R 终端 切换终端：Ctrl+` 创建新终端：Ctrl+Shift+` 终端配置：terminal.integrated 向终端运行指定命令：Run Active File In Active Terminal Run Selected Text In Active Terminal 工作流（WorkFlow） 自动运行任务：Run Task 配置任务：Configure Task https://code.visualstudio.com/docs/editor/tasks#_custom-tasks 脚本执行结果分析：https://marketplace.visualstudio.com/search?term=problem%20matcher\u0026target=VSCode\u0026category=All%20categories\u0026sortBy=Relevance 多行错误分析器https://code.visualstudio.com/docs/editor/tasks#_defining-a-multiline-problem-matcher 调试（Debug） 打开调试界面：Ctrl+Shift+D program 一般用于指定将要调试的文件。 stopOnEntry，当调试器启动后，是否在第一行代码处暂停代码的执行。这个属性非常方便，如果没有设置断点而代码执行非常快的话，我们就会像文章的最开头那样，代码调试一闪而过，而设置了 stopOnEntry 后，代码会自动在第一行停下来，然后我们就可以继续我们的代码调试了。 args 参数。相信你应该记得在前面任务系统配置的文章里，我已经说明了可以使用 args 来控制传入任务脚本的参数，同样的，我们也可以通过 args 来把参数传给将要被调试的代码。 env 环境变量。大部分调试器都使用它来控制调试进程的特殊环境变量。 cwd 控制调试程序的工作目录。 port 是调试时使用的端 27。 工作区 拆分编辑器：Ctrl+\\ Split Editor 在编辑器组中快速跳转：Ctrl+1 Ctrl+2 切换垂直 / 水平编辑器布局：Shift+Alt+0 Flip Editor Group Layout 专注模式：Ctrl+B Ctrl+J Toggle Activity Bar Visibility Toggle Status Bar Visibility Toggle Zen Mode Toggle Centered Layout 缩放：Ctrl+-/+ View:Rest Zoom 快捷键设置 打开快捷键设置：Open Keyboard Shortcuts 设置 KeyBindings.json：有三个主要属性，Key设置快捷键，Command对应的系统命令，When触发时机（详见:https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts，如果想解除某个快捷键，只需要在 Command 的最前面加上-就可以覆盖默认设置。 Json 支持 Json 是 VsCode 默认支持的语言，可通过Json Schemas对 Json 的语法进行校验和智能提示，样例如下： { \"json.schemas\": [ { \"fileMatch\": [\"/.myconfig\"], \"schema\": { \"type\": \"object\", \"properties\": { \"name\": { \"type\": \"string\",","date":"2019-10-13","objectID":"/visual-studio-code-%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["ide","vscode"],"title":"Visual Studio Code 专栏学习笔记","uri":"/visual-studio-code-%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"主框架 隐藏、开启侧边栏：Ctrl+B 交互式演习场 Help -Interactive Playground 可以帮助学习 VS Code ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"编辑区分栏 创建一个新的分栏：Ctrl+\\ 关闭当前选中的分栏：Ctrl+W 在三个分栏间切换：Ctrl+1,2,3 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"资源管理器 移动选中文件后快速打开该文件到编辑区：Ctrl+Enter 快速搜索一个文件（执行其他命令）：Ctrl+P ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"配置编辑器 VS Code 给予了我们很灵活的配置项，可以通过 user settings 设置全局项，或通过 workspace settings 设置每一个项目或文件夹的配置。设置的值保存在一个 setting.json 文件中。 通过 Ctrl+Shift+P 打开命令输入栏，输入 user 然后按 Enter 可以编辑全局的用户 setting.json 文件。 通过 Ctrl+Shift+P 打开命令输入栏，输入 worksp 然后按 Enter 可以编辑项目或文件夹的 setting.json 文件。 当启动配置编辑时可在左边窗口看到 VS Code 的默认配置，我们要编辑的 setting.json 会放在右边窗口。从默认配置可以很方便的进行审查和复制。 完成配置编辑后，按下 Ctrl+S 保存更改，更改将会立即生效。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"保存和自动保存 默认情况下，VS Code 需要显示的进行保存操作，即按 Ctrl+S。 然而，我们也可以很轻松的开启自动保存，可通过配置进行定时触发保存或是等待焦点离开编辑器时自动保存。当自动保存开启后，就不再需要显示的进行文件保存。 要开启 Auto Save，需要打开 User Settings 或 Workspace Settings 找到相关配置项： files.autoSave：可以设置 off（默认值）来禁用自动保存，可以设置 afterDelay 来配置一个自动保存的延迟时间，也可以配置 onFocusChange 来当我们的焦点离开正在编辑的文件时自动保存。 files.autoSaveDelay：当 files.autoSave 配置为 afterDelay 时可指定自动保存延时的毫秒数。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"通过文件搜索 Ctrl+Shift+F 快速搜索当前打开的文件夹里的内容，单击搜索结果项可将它展示在编辑区。 TIP: 支持正则表达式搜索。 Ctrl+Shift+J 可打开搜索的高级设置，其中可以设置要包含或是要排除的文件。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"命令面板 通过快捷键 Ctrl+Shift+P 可快速的打开命令面板，在命令面板中我们可以访问 VS Code 的所有功能，包括快捷键设置和大多数通用操作。 命令面板还能执行一些其他常用的命令，如编辑器命令，打开文件，查找符号，快速浏览一个文件等，下面是一些常用的命令： Ctrl+P 可快速导航到一个文件或符号通过键入它们的名字。 Ctrl+Shift+Tab 带我们回到最后一次打开的文件集。 Ctrl+Shift+P 带我们直接进入命令编辑面板。 Ctrl+Shift+O 带我们直接导航到一个文件的符号信息。 Ctrl+G 导航到文件的指定行。 键入 ? 可得到一个可用命令的列表，可以直接在这里选中执行。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"html 相关插件 Prettier 代码格式化。 CSS Peek 关联 Html 中对标签到 CSS 文件。 Html Boilerplate Html 模版。 Color Info CSS 颜色提示。 Auto Close Tag 自动闭合标签。 Html CSS Suport Html 标签引用 CSS 样式提示。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["cooking"],"content":"原料 ","date":"2019-09-19","objectID":"/%E8%84%86%E7%9A%AE%E4%BA%94%E8%8A%B1%E7%83%A4%E8%82%89/:1:0","tags":["cooking","oven"],"title":"脆皮五花烤肉","uri":"/%E8%84%86%E7%9A%AE%E4%BA%94%E8%8A%B1%E7%83%A4%E8%82%89/"},{"categories":["cooking"],"content":"猪肉涂抹配料 五花肉 1 斤 孜然粉 1 勺 绍兴黄酒 1 勺 五香粉 1 勺 红糖粉 1 勺 盐 1 勺 耗油 1 勺 辣椒粉 1 勺（可选，不吃辣不放） 生抽 1 勺（可选，颜色浅可不放，适当加盐） ","date":"2019-09-19","objectID":"/%E8%84%86%E7%9A%AE%E4%BA%94%E8%8A%B1%E7%83%A4%E8%82%89/:1:1","tags":["cooking","oven"],"title":"脆皮五花烤肉","uri":"/%E8%84%86%E7%9A%AE%E4%BA%94%E8%8A%B1%E7%83%A4%E8%82%89/"},{"categories":["cooking"],"content":"猪皮涂抹配料 粗盐 白醋 鸡蛋清 ","date":"2019-09-19","objectID":"/%E8%84%86%E7%9A%AE%E4%BA%94%E8%8A%B1%E7%83%A4%E8%82%89/:1:2","tags":["cooking","oven"],"title":"脆皮五花烤肉","uri":"/%E8%84%86%E7%9A%AE%E4%BA%94%E8%8A%B1%E7%83%A4%E8%82%89/"},{"categories":["cooking"],"content":"步骤 五花肉加姜葱、料酒、花椒焯水 五花肉改刀，两指宽方块，从肉向猪皮切，切到最后一层瘦肉即可，不要切穿 猪皮用叉子叉一些小孔 均匀涂抹配料，肉缝中间也要涂，但是猪皮不能涂 用锡箔纸包裹猪肉，只露出猪皮，锡箔纸底部瘦肉那一面扎一些小孔方便烤出的油脂滴出 猪皮擦干水分，涂抹一层白醋 放入烤箱 70° 热风烘烤 1 小时，让猪皮表面水分蒸发 取出猪肉，猪皮涂抹一层鸡蛋清，再撒上一层粗盐 放入烤箱 190° 上下烘烤 1 小时，取出猪肉，去除猪皮表面的粗盐 再放入烤箱 210° 热风烘烤 5 分钟，让猪皮起泡（注意时刻观察，起泡了就不用烤了） ","date":"2019-09-19","objectID":"/%E8%84%86%E7%9A%AE%E4%BA%94%E8%8A%B1%E7%83%A4%E8%82%89/:2:0","tags":["cooking","oven"],"title":"脆皮五花烤肉","uri":"/%E8%84%86%E7%9A%AE%E4%BA%94%E8%8A%B1%E7%83%A4%E8%82%89/"},{"categories":null,"content":"常见系统整理 搭建了一些常见系统，以便需要时能快速开箱即用。 MQ 服务：RabbitMQ WebRTC 服务：janus ELK 日志服务：elk ","date":"2019-08-04","objectID":"/shortcut/:0:1","tags":null,"title":"","uri":"/shortcut/"},{"categories":null,"content":"  free 笔记 是一个简洁、优雅且高效的 Hugo 博客网站。 路的尽头是风景free 笔记 \" 路的尽头是风景 ","date":"2019-08-04","objectID":"/about/:0:0","tags":null,"title":"关于 free 笔记","uri":"/about/"},{"categories":null,"content":"介绍  笔记主人：奉锐  坐标：成都  邮箱 qjdev@qq.com  微信 feng_rui  主要领域为前端技术，后端技术略懂，欢迎探讨研究。 ","date":"2019-08-04","objectID":"/about/:0:1","tags":null,"title":"关于 free 笔记","uri":"/about/"},{"categories":["wpf"],"content":"常用Path路径 正三角形（左）：\u003cPath Data=“M40,0 L0,30 40,60 z” Stretch=“Uniform”/\u003e 正三角形（上）：\u003cPath Data=“M0,40 L30,0 60,40 z” Stretch=“Uniform”/\u003e 正三角形（右）：\u003cPath Data=“M0,0 L40,30 0,60 z” Stretch=“Uniform”/\u003e 正三角形（下）：\u003cPath Data=“M0,0 L30,40 60,0 z” Stretch=“Uniform”/\u003e 矩形：\u003cPath Data=“M0,0 L1,0 L1,1 L0,1 z” Stretch=“Uniform”/\u003e 圆形：\u003cPath Data=“M100,50 C100,77.614237 77.614237,100 50,100 C22.385763,100 0,77.614237 0,50 C0,22.385763 22.385763,0 50,0 C77.614237,0 100,22.385763 100,50 z” Stretch=“Uniform”/\u003e 箭头（左）：\u003cPath Data=“M40,0 L0,30 40,60” Stretch=“Uniform”/\u003e 箭头（上）：\u003cPath Data=“M0,40 L30,0 60,40” Stretch=“Uniform”/\u003e 箭头（右）：\u003cPath Data=“M0,0 L40,30 0,60” Stretch=“Uniform”/\u003e 箭头（下）：\u003cPath Data=“M0,0 L30,40 60,0” Stretch=“Uniform”/\u003e 半圆（左）：\u003cPath Data=“M34,0 L34,68 C15.222317,68 0,52.777684 0,34 0,15.222319 15.222317,3.5762787E-07 34,0 z” Stretch=“Uniform”/\u003e 半圆（上）：\u003cPath Data=“M34,0 C52.777684,7.1525574E-07 68,15.222319 68,34.000001 L0,34.000001 C3.5762787E-07,15.222319 15.222319,7.1525574E-07 34,0 z” Stretch=“Uniform”/\u003e 半圆（右）：\u003cPath Data=“M0,0 C18.777683,3.5762787E-07 34,15.222319 34,34 34,52.777684 18.777683,68 0,68 z” Stretch=“Uniform”/\u003e 半圆（下）：\u003cPath Data=“M0,0 L68,0 C68,18.777681 52.777684,34 34,34 15.222319,34 3.5762787E-07,18.777681 0,0 z” Stretch=“Uniform”/\u003e 椭圆矩形（水平）：\u003cPath Data=“M34,0 L76,0 C94.777683,9.8347664E-07 110,15.222319 110,34.000001 110,52.777684 94.777683,68.000001 76,68.000001 L34,68.000001 C15.222317,68.000001 0,52.777684 0,34.000001 0,15.222319 15.222317,9.8347664E-07 34,0 z” Stretch=“Uniform”/\u003e 椭圆矩形（垂直）：\u003cPath Data=“M34.000001,0 C52.777684,0 68.000001,15.222321 68.000001,34 L68.000001,76 C68.000001,94.777681 52.777684,110 34.000001,110 15.222319,110 8.9406967E-07,94.777681 0,76 L0,34 C8.9406967E-07,15.222321 15.222319,0 34.000001,0 z” Stretch=“Uniform”/\u003e 菱形:\u003cPath Data=“M150,0 L0,75 0,225 150,300 300,225 300,75 z” Stretch=“Uniform”/\u003e Stretch 默认使用 Uniform，在这种参数下矩形为正方形、圆形为正圆形，如果修改 Stretch 为 Fill，则根据容器高宽进行自由拉伸。 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:1:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"动画 缓动函数（使用 IE 查看）：http://tinyurl.com/animationeasing WPF 动画默认为 60 帧/s，程序会在系统资源允许的情况下努力使动画达到这个帧率，也可以在代码里手动指定帧率，修该附加属性 Timeline.DesiredFrameRate 的值。 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:2:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"变化 LayoutTransform：对元素使用该变换时会真正改变元素的大小和位置，从而引发布局容器的重新计算，因此，只当使用该变化一次，不要在动画中使用。 RenderTransform：显示变化，对元素运用该变化时并不会真正的改变元素的大小和位置，只是显示上面产生了变化，因此不会影响布局容器的测量和排版。 RenderTransformOrigin：使用变化时可以在具体变化中使用决对坐标，也可以直接指定元素的RenderTransformOrigin，从而使用相对坐标，比如\"0.5,0.5\"就是该元素的中心点。 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:3:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"字体 WPF 有个问题是小文本显示不太清晰，原因是 WPF 没有使用 GDI 渲染文本，好的解决方法是增大文本，在通常的 96 dpi 的显示器上，文本字号最小控制在 15，如果小于这个值最好将文本的 TextOptions.TextFormattingMode 的值设置为 Display，而不是标准的 Ideal，这样做会使文本更清晰。 检查字体版权是否允许在自己的程序中嵌入，可使用工具：https://www.microsoft.com/en-us/Typography/TrueTypeProperty21.aspx，如果右键属性显示可安装就可以使用。 字体加载的两种方式，第一种字体为嵌入式资源：FontFamily=\"pack://application:,,,/WpfLabs;component/FontFamilyDemo/#Aileron\"；第二种字体为文件，可在后台代码中设置：new FontFamily（@\"D:\\FontFamilyDemo\\FontFiles\\#Aileron\"）;。 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:4:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"性能 WPF 中，很多元素继承了 Freezable，表示该元素支持冻结，冻结之后变更通知就失效了，但是内存占用会下降，很多情况下都可以将元素冻结，常见的比如 SolidColorBrush 和 Storyboard。在 Xaml 中使用时先引用命名空间 xmlns:options=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation/options\"，然后对元素使用 \u003cStoryboard options:Freeze=\"True\"\u003e。 集合虚拟化：启用 UI 虚拟化的两个附加属性 1、ScrollViewer.CanContentScroll=\"True\"；2、VirtualizingStackPanel.IsVirtualizing=\"True\"。 大集合项容器再循环，项容器再循环提高了滚动性能，降低了内存消耗量：VirtualizingStackPanel.VirtualizationMode=\"Recycling\" 当集合中使用了分组，默认不会启用虚拟化，需要手动设置 VirtualizingStackPanel.IsVirtualizingWhenGrouping 属性纠正这个问题 \u003cListBox VirtualizingStackPanel.IsVirtualizingWhenGrouping=\"True\"...\u003e ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:5:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"绑定 Xaml 中 String.Format 的使用参考：https://www.cnblogs.com/candyzkn/p/4476832.html Uri 绑定资源路径写法：pack://application:,,,/WpfLabs;component/FontFamilyDemo/#Aileron Uri 绑定本地文件路径写法：pack://siteoforigin:,,,/Aileron.jpg ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:6:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"错误验证 显示错误提示可使用专用的错误模板，即再真正的元素之上附加一层装饰层来展示真正的错误，注意在错误模板中使用 AdornedElementPlaceholder 来标识真正的控件元素，然后使用路径属性绑定去寻找真正的错误提示，参考 19.4.5。 文章中提到的参考来源默认为 《WPF 编程宝典：使用 C# 2012 和 .NET 4.5 第 4 版》 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:7:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["deploy"],"content":"场景： 有些场景下会出现局域网内的某些网段可能由于安全限制，不能访问外网，此时可以通过安装一些工具来实现借助局域网内某些能够上外网的电脑来实现网络代理的功能。以下工具均是使用于Window环境。 服务端： 部署于可以上外网的电脑上，首先下载 TcpRoute2，该软件的作用是通过 Socks5 代理协议对外提供服务。下载完成后在文件夹下有个 config.toml.example 文件，删掉 .example 后缀，修改配置文件中的 addr= 字段为对应的电脑 IP，然后运行 TcpRoute2Windows.exe 程序即可开启代理服务。 客户端： 部署于局域网中需要上网的电脑上，首先下载 Proxifier，下载完毕后安装，安装完毕后首先配置代理的服务的地址，选择 Profile -\u003e Proxy Servers，添加之前服务端 addr= 填写的地址和端口，选择 Socks5 协议，认证如果服务端没有配置就可以不用修改，点击 Check，没有问题后可直接确定。然后选择 Profile-\u003eProxification Rules，可以修改现有规则或者启用一个新规则，其中 Applications、Target hosts、Target ports 都可以填 Any，最后的 Action 选择刚才建立的服务地址，然后该机器就能够全局通过代理上网了。不过要注意不能用 Ping 命令测试是否能上网，因为 Ping 命令不会走代理协议。 备注： TcpRoute 是一款开源软件，Proxifier 是一款商业软件，可以免费试用 30 天，不过网上很容易找到注册码，以下是我之前找的，用户名随意填写，注册码：5EZ8G-C3WL5-B56YG-SCXM9-6QZAP、G3ZC7-7YGPY-FZD3A-FMNF9-ENTJB、YTZGN-FYT53-J253L-ZQZS4-YLBN9 三选一。 ","date":"2019-04-01","objectID":"/windows-%E4%B8%8B%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/:0:0","tags":["deploy"],"title":"Windows 下搭建网络代理","uri":"/windows-%E4%B8%8B%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"},{"categories":["dotnet"],"content":"安装 CentOs，可使用最小安装包镜像 http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1708.iso ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:1:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"跟随安装步骤进行，中途要选择磁盘 选择磁盘选择磁盘 \" 选择磁盘 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:2:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"设置 Root 用户密码 设置 Root 用户密码设置 Root 用户密码 \" 设置 Root 用户密码 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:3:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装完毕后重启，进入系统，CentOs 最小版缺少一些必要组件，首先要打开网卡设置，用vi编辑 vi /etc/sysconfig/network-scripts/ifcfg-ens33 编辑最后一行，将 ONBOOT=no 改为 ONBOOT=yes :wq 保存并退出 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:4:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"重启网卡 service network restart 然后Ping一下百度，应该 OK 了 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:5:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装 ipconfig 等网络工具 中途需要输入 y 确认几次：sudo yum install net-tools ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:6:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"使用 ifconfig 查看本机 IP 查看本机 IP查看本机 IP \" 查看本机 IP ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:7:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"下载 Putty 使用IP地址可进行远程连接： 远程连接远程连接 \" 远程连接 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:8:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装 Nginx 参考教材https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7 安装 Nginx：sudo yum install epel-release; sudo yum install nginx 启动 Nginx：sudo systemctl start nginx 打开防火墙：sudo firewall-cmd --permanent --zone=public --add-service=http; sudo firewall-cmd --permanent --zone=public --add-service=https 重新加载防火墙：sudo firewall-cmd --reload ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:9:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"现在可以使用命令在Web浏览器访问Nginx了 http://server_domain_name_or_IP/ ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:10:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装 .Net Core 环境 https://www.microsoft.com/net/download/linux-package-manager/centos/sdk-current sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc sudo sh -c 'echo -e \"[packages-microsoft-com-prod]\\nname=packages-microsoft-com-prod \\nbaseurl= https://packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\" \u003e /etc/yum.repos.d/dotnetdev.repo' sudo yum update sudo yum install libunwind libicu sudo yum install dotnet-sdk-2.1.4 至此，可输入 dotnet --version 查看 .NetCore 已安装成功。 参考： http://video.jessetalk.cn/course/4/task/6/show http://video.jessetalk.cn/course/4/task/7/show ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:11:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["wpf"],"content":"在 WPF 中使用动画的情况非常多，而要让动画变得生动往往要使用一些变速动画，WPF 也内置了很方便的缓动函数来实现这一功能。 除此之外，WPF 还有关键帧动画，利用关键帧动画能够很好的控制动画的细节，与美工的很多设计保持完美一致。关键帧动画中还有一套叫做样条关键帧动画（SplineKeyFrame），这个动画利用一个三次贝塞尔曲线能够更准确的控制动画的速率。 不同的缓动函数光看名字很难知道实际效果，样条关键帧动画的贝塞尔曲线控制也很难直观的看到效果，于是写了个小工具来展现不同的动画速率的效果以及修改配置对速率的影响，下面是工具的运行效果。 动画速率效果动画速率效果 \" 动画速率效果 工具代码下载地址：https://github.com/fengrui358/WPFLabs/tree/master/EasingFunctionDemo 三次贝塞尔曲线控制参考：https://www.cnblogs.com/hnfxs/p/3148483.html ","date":"2017-12-04","objectID":"/wpf-%E5%8A%A8%E7%94%BB%E9%80%9F%E7%8E%87%E6%95%88%E6%9E%9C/:0:0","tags":["dotnet","wpf"],"title":"WPF 动画速率效果","uri":"/wpf-%E5%8A%A8%E7%94%BB%E9%80%9F%E7%8E%87%E6%95%88%E6%9E%9C/"},{"categories":["ui"],"content":" 正三角形(左)：\u003cPath Data=“M40,0 L0,30 40,60 z” Stretch=“Uniform”/\u003e 正三角形(上)：\u003cPath Data=“M0,40 L30,0 60,40 z” Stretch=“Uniform”/\u003e 正三角形(右)：\u003cPath Data=“M0,0 L40,30 0,60 z” Stretch=“Uniform”/\u003e 正三角形(下)：\u003cPath Data=“M0,0 L30,40 60,0 z” Stretch=“Uniform”/\u003e 矩形：\u003cPath Data=“M0,0 L1,0 L1,1 L0,1 z” Stretch=“Uniform”/\u003e 圆形：\u003cPath Data=“M100,50 C100,77.614237 77.614237,100 50,100 C22.385763,100 0,77.614237 0,50 C0,22.385763 22.385763,0 50,0 C77.614237,0 100,22.385763 100,50 z” Stretch=“Uniform”/\u003e 箭头(左)：\u003cPath Data=“M40,0 L0,30 40,60” Stretch=“Uniform”/\u003e 箭头(上)：\u003cPath Data=“M0,40 L30,0 60,40” Stretch=“Uniform”/\u003e 箭头(右)：\u003cPath Data=“M0,0 L40,30 0,60” Stretch=“Uniform”/\u003e 箭头(下)：\u003cPath Data=“M0,0 L30,40 60,0” Stretch=“Uniform”/\u003e Stretch 默认使用 Uniform，在这种参数下矩形为正方形、圆形为正圆形，如果修改 Stretch 为 Fill，则根据容器高宽进行自由拉伸。 ","date":"2017-07-22","objectID":"/%E5%B8%B8%E7%94%A8-path-%E8%B7%AF%E5%BE%84/:0:0","tags":["ui","wpf"],"title":"常用 Path 路径","uri":"/%E5%B8%B8%E7%94%A8-path-%E8%B7%AF%E5%BE%84/"},{"categories":["dotnet"],"content":"警告警告 \" 警告 如果在一个类中定义了虚属性或者虚方法，又在构造函数中访问了这个虚属性或方法，此时 VisualStudio 是不会给出警告，并且编译也没有问题，但是如果安装了 Resharper 插件则会给出警告提示：“在构造函数中访问了虚成员”，那么，这为何是一个安全隐患，下面给出一个例子说明： using System; namespace VirtualDemo { class Program { static void Main(string[] args) { var test = new SubClass(); Console.ReadKey(); } } class BaseClass { protected virtual string VirtualProperty { get; set; } public BaseClass() { var p = VirtualProperty; VirtualMethod(); } protected virtual void VirtualMethod() { } } class SubClass : BaseClass { private MockClass _mockClass; public SubClass() { _mockClass = new MockClass(); } protected override string VirtualProperty { get { return _mockClass.MockProperty; } set { _mockClass.MockProperty = value; } } protected override void VirtualMethod() { var p = _mockClass.MockProperty; } } class MockClass { public string MockProperty { get; set; } } } 该示例很简单，在构造 SubClass 时出现了空引用报错，因为基类构造函数先于子类构造函数运行，而子类构造函数中初始化了一个成员类，但是基类构造函数访问虚成员时子类还没构造，所以出现了空引用报错。有多种方式可以避免这一情况，可以通过子类字段初始化的方式来构造成员类，这个语法糖可避免构造函数的时序问题，第二个是可定义一个虚的 Initialize 方法在子类构造函数第一步调用，子类在继承这个方法时初始化需要的依赖。 ","date":"2017-06-03","objectID":"/csharp%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%AE%BF%E9%97%AE%E8%99%9A%E6%88%90%E5%91%98/:0:0","tags":["dotnet"],"title":"C# 为何不推荐在构造函数中访问虚成员","uri":"/csharp%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%AE%BF%E9%97%AE%E8%99%9A%E6%88%90%E5%91%98/"},{"categories":["dotnet"],"content":"纵览 NLog 在启动时会自动的去加载配置，总的说来 NLog 的配置会来源于两个地方： 配置嵌入在标准的 *.exe.config 或者 web.config 文件。 存储在一个单独的配置文件中。 对于 Xamarin Android，支持将配置文件放在 assets 文件夹下。不过它不能自动加载，需要手动配置，如下： LogManager.Configuration = new XmlLoggingConfiguration(\"assets/nlog.config\"); 第一种使用标准配置的情况代码如下： \u003cconfiguration\u003e \u003cconfigSections\u003e \u003csection name=\"nlog\" type=\"NLog.Config.ConfigSectionHandler, NLog\"/\u003e \u003c/configSections\u003e \u003cnlog\u003e \u003c/nlog\u003e \u003c/configuration\u003e 第二种使用纯粹的 XML 格式再\u003cnlog /\u003e根节点下添加配置，并且当加入命名空间时还能够获得 Visual Studio 的智能提示。 \u003cnlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\u003e \u003c/nlog\u003e 注意当不添加命名空间时 NLog 配置文件是大小写不敏感的，而使用命名空间则配置文件就变得大小写敏感。智能提示只工作在大小写敏感的配置中。\u003cnlog /\u003e 根节点中可以添加如下的孩子元素，其中头两个为必须添加的元素，其他三个用于一些高级功能。 \u003ctargets /\u003e - 定义日志目标和输出 \u003crules /\u003e - 定义日志的路由规则 \u003cextensions /\u003e - 从*.dll 文件中加载的 NLog 扩展 \u003cinclude /\u003e - 定义包括的额外配置文件 \u003cvariable /\u003e - 设置配置文件的变量值 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:1:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Targets 每一个 \u003ctargets /\u003e 节点定义来一个日志输出目标，每个目标有两个属性是必须的: name - 目标的名称 type - 枚举值，如:“File”，“Database”，“Mail”。当引用来命名空间时需要使用xsi:type 然后除了必要的两个属性以外根据不同的 type 还会有一些不同的参数属性，这个后面讲 targets 时会详细讲到。 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:2:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Rules 日志路由规则定义在 \u003crules /\u003e 节点下，这个路由表定义了一系列的规则来约束日志对象的名称、日志等级和它们的输出目标的关系。运算时从 rules 的第一条规则开始计算，如果匹配就立即输出到指定到目标，然后计算下一条规则，如果匹配到一条被标记为 final 的规则，则不再往下计算。 路由表中的每一条规则都是一个 \u003clogger /\u003e 元素，包括以下属性： name - 日志的名称（包括通配符 *） minlevel - 该规则能匹配的最低日志等级 maxlevel - 该规则能匹配的最高日志等级 level - 只匹配某一个单独的日志等级 levels - 该规则可匹配多个日志等级，用 , 分隔符分开 writeTo - 指定输出到到目标，可以是多个，用 , 分隔符分开 final - 标记该条规则为最后一条，在该条规则匹配到情况下不再继续往后匹配 enabled - 设置为 false 则禁用该规则 假如在同一条规则中包含来多个日志等级到关键字（level，levels，minlevel，maxlevel），则按照日志等级关键字的优先顺序来设置优先级，只取优先级最高的那个关键字，其他的忽略。 日志等级关键字的优先顺序如下： level levels minlevel 和 maxlevel（最低和最高等级的优先级相同） 没有关键字（默认为全部等级） ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:3:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Layouts and layout renderers Nlog 其中最强大的一个组件就是 layouts。layouts 的主要作用是使用嵌入标记 ${ 和 } 来嵌入一些上下文信息。 layouts 可以用于很多地方，例如它们可以控制输出到屏幕或文件内到文本信息到格式，也可以控制输出到文件时的要用的文件名。 下面是一个示例，我们将以下信息写入到控制台中： 当前日期和时间 输出该段日志段类和方法名称 日志等级 日志信息 以上基本上是日常使用最长用的信息，要输出以上信息也非常简单： \u003ctarget name=\"c\" xsi:type=\"Console\" layout=\"${longdate} ${callsite} ${level} ${message}\" /\u003e 我们也可以指定不同的日志对象将它们对应的日志信息分别输出到对应到日志文件中，如下： \u003ctarget name=\"f\" xsi:type=\"File\" fileName=\"${logger}.txt\" /\u003e 使用 ${logger} 就可以创建如下到日志文件列表： Name.Space.Class1.txt Name.Space.Class2.txt Name.Space.Class3.txt Other.Name.Space.Class1.txt Other.Name.Space.Class2.txt Other.Name.Space.Class3.txt ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:4:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"分隔配置文件（Include files） 有时我们会希望将一个大的配置文件分隔成多个小的，Nlog 也提供来一个机制在主配置文件中包括额外的配置文件，使用 \u003cinclude file=\"……\"/\u003e 元素。而其中额外的配置文件的名称也可以使用 ${} 语法嵌入动态的文件名，跟在 layout 中使用它没什么区别，所以我们也可以根据不同的环境指定不同的配置文件，例子如下，我们根据运行环境所在的不同机器使用不同的配置文件： \u003cnlog\u003e ... \u003cinclude file=\"${basedir}/${machinename}.config\"/\u003e ... \u003c/nlog\u003e 其中有一个可选属性，ignoreError=\"true\"，该属性的默认值为 false。添加这个属性的作用是当额外配置文件没有找到或是格式不正确时可以阻止 Nlog 抛出异常，当设置 ignoreError=\"true\"，配置的异常信息只会记录在 Nlog 的内部调试日志当中，此时可以通过 Troubleshooting logging 来记录内部错误。 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:5:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Variables 变量为编写复杂和重复的内容提供了一种简明的表达形式。可以使用如下的语法定义一个变量： \u003cvariable name=\"var\" value=\"xxx\" /\u003e 一旦变量定义好之后，就可以使用类似 ${var} 这样的语法使用它了，例子如下： \u003cnlog\u003e \u003cvariable name=\"logDirectory\" value=\"${basedir}/logs/${shortdate}\"/\u003e \u003ctargets\u003e \u003ctarget name=\"file1\" xsi:type=\"File\" fileName=\"${logDirectory}/file1.txt\"/\u003e \u003ctarget name=\"file2\" xsi:type=\"File\" fileName=\"${logDirectory}/file2.txt\"/\u003e \u003c/targets\u003e \u003c/nlog\u003e 需要注意变量的声明必须在使用之前，否则配置初始化会失败。 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:6:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Vars since NLog 4.1 在 NLog 4.1 版本中有一个新方法来使用变量，用 ${var:var1} 来代替 ${var1}。 在 layout renderer 中使用这种写法的好处是： 可以通过 API 来改变，删除和新建变量。 可以为变量配置一个默认值，如：${var:password:default=unknown}。 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:6:1","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"自动重载配置 配置文件在程序启动时会自动加载 NLog 配置大全 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:7:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["wpf"],"content":"在 WPF 的集合控件中常常需要在每一个集合项之间插入一个分隔符样式，但是 WPF 的 ItemsControl 没有相关功能的直接实现，所以只能考虑曲线救国，经过研究，大概想到了以下两种实现方式。 先写出 ItemsControl 的数据模板，如下： \u003cItemsControl ItemsSource=\"{Binding Source}\" BorderThickness=\"1\" BorderBrush=\"Blue\" VerticalAlignment=\"Stretch\"\u003e \u003cItemsControl.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"Auto\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003cBorder Name=\"Bd\" Grid.Row=\"0\" Height=\"1\" Background=\"Red\" /\u003e \u003cTextBlock Grid.Row=\"1\" Text=\"{Binding}\" /\u003e \u003c/Grid\u003e \u003c/DataTemplate\u003e \u003c/ItemsControl.ItemTemplate\u003e \u003c/ItemsControl\u003e 其中名为 Bd 的 Border 就是分隔符，此时每一项的头部都可以看见分隔符，现在我们的目标是要隐藏掉第一项的分隔符，这就达到了项与项之间才有分隔符的目的。 第一种实现方式最简单，使用集合项前向绑定 PreviousData，这是四种绑定方式中的一种，估计也是平时用得最少的一种，不过此时就派上用场了，代码如下： \u003cDataTemplate.Triggers\u003e \u003cDataTrigger Binding=\"{Binding RelativeSource={RelativeSource PreviousData}}\" Value=\"{x:Null}\"\u003e \u003cSetter TargetName=\"Bd\" Property=\"Visibility\" Value=\"Collapsed\" /\u003e \u003c/DataTrigger\u003e \u003c/DataTemplate.Triggers\u003e 当某一项的前项为空时就隐藏分隔符，简单的一行代码搞定。不过这种实现方式有个缺点就是如果使用的是 Insert 方式向绑定的数据源的最前面添加数据则就会出现不止一个没有分隔符的项，如果是往队尾或者队中添加则不会出现这个问题。 第二种实现方式是借助 ItemsControl 的 AlternationCount 和 AlternationIndex 属性来为集合项标记索引号，再隐藏索引号为 0 的项的分隔符，代码如下： \u003cItemsControl ItemsSource=\"{Binding Source}\" BorderThickness=\"1\" BorderBrush=\"Blue\" VerticalAlignment=\"Stretch\" AlternationCount=\"{Binding Source.Count}\"\u003e 首先在 ItemsControl 上绑定 AlternationCount 到数据源的 Count 属性上，然后此时 ItemsControl 的 AlternationIndex 属性就变成的该集合数据源的索引号了，在触发器中写上逻辑即可： \u003cBorder Name=\"Bd\" Grid.Row=\"0\" Height=\"1\" Background=\"Red\"\u003e \u003cBorder.Style\u003e \u003cStyle TargetType=\"{x:Type Border}\"\u003e \u003cStyle.Triggers\u003e \u003cDataTrigger Binding=\"{Binding Path=(ItemsControl.AlternationIndex), RelativeSource={RelativeSource AncestorType={x:Type ContentPresenter}}}\" Value=\"0\"\u003e \u003cSetter Property=\"Visibility\" Value=\"Collapsed\" /\u003e \u003c/DataTrigger\u003e \u003c/Style.Triggers\u003e \u003c/Style\u003e \u003c/Border.Style\u003e \u003c/Border\u003e 触发器判定当索引号为0时就隐藏 Border，这种方式代码量也不大，优点是能绝对实现这个功能，无论向队首插入还是队尾插入，但是 AlternationCount 和 AlternationIndex 属性本来的含义是用来实现比如隔行变色等功能，此时这种功能被占用，所以如果你的集合要同时实现分隔符和隔行样式的功能可能需要额外加转换器，不过转换器内容也很简单，求个余数就能还原之前的功能了。 （2017 年 4 月 15 日补充） 经过网友 vbfool 提示，补充第三种方式，按照第二种思路自定义附加属性，这样就不用占用原生 ItemsControl 的属性了。并且可以用附加属性标记出所有的索引号，供其他场景使用。 先自定义一个 MarkIndex 属性用于标记 ItemsControl，如果这个属性被设为 True 再在代码逻辑中去订阅数据项的变更，然后向 ItemContainer 中设置一个 ItemIndex 附加属性，标记出索引号。 定义的依赖属性如下： #region MarkIndex public static readonly DependencyProperty MarkIndexProperty = DependencyProperty.RegisterAttached( \"MarkIndex\", typeof(bool), typeof(ItemsControlHelper), new PropertyMetadata(default(bool), OnMarkIndexPropertyChanged)); public static bool GetMarkIndex(DependencyObject obj) { return (bool)obj.GetValue(MarkIndexProperty); } public static void SetMarkIndex(DependencyObject obj, bool value) { obj.SetValue(MarkIndexProperty, value); } private static void OnMarkIndexPropertyChanged(DependencyObject dependencyObject, DependencyPropertyChangedEventArgs args) { if ((bool)args.NewValue) { var itemsControl = dependencyObject as ItemsControl; if (itemsControl != null) { itemsControl.ItemContainerGenerator.StatusChanged -= ItemContainerGeneratorOnStatusChanged; itemsControl.ItemContainerGenerator.ItemsChanged -= ItemContainerGeneratorOnItemsChanged; itemsControl.ItemContainerGenerator.StatusChanged += ItemContainerGeneratorOnStatusChanged; itemsControl.ItemContainerGenerator.ItemsChanged += ItemContainerGeneratorOnItemsChanged; } } else { var itemsControl = dependencyObject as ItemsControl; if (itemsControl != null) { itemsControl.ItemContainerGenerator.StatusChanged -= ItemContainerGeneratorOnStatusChanged; itemsControl.ItemContainerGenerator.ItemsChanged -= ItemContainerGeneratorOnItemsChanged; } } } private static void ItemContainerGeneratorOnItemsChanged(object sender, ItemsChangedEventArgs itemsChangedEventArgs) { var itemContainerGenerator = (ItemContainerGenerator)sender; if (itemContainerGenerator.Status == GeneratorStatus.ContainersGenerated) { for (int i = 0; i \u003c itemContainerGenerator.Items.Count; i++) { var dp = itemContainerGenerator.ContainerFromIndex(i); if (dp != null) {","date":"2017-04-10","objectID":"/wpf-%E9%9B%86%E5%90%88%E6%8E%A7%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E9%9A%94%E7%AC%A6itemscontrol-separator/:0:0","tags":["dotnet","wpf"],"title":"WPF 集合控件实现分隔符（ItemsControl Separator）","uri":"/wpf-%E9%9B%86%E5%90%88%E6%8E%A7%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E9%9A%94%E7%AC%A6itemscontrol-separator/"},{"categories":["dotnet"],"content":"安装 Nlog 通过 NuGet 安装，可以看到排名靠前的有两个，一个是 NLog，还有一个是 NLog.Config，推荐安装第二个，除了安装 NLog 程序集以外还会安装它的配置文件和一个配置文件 XML 结构的描述文件（让 Visual Studio 支持配置文件的智能提示）。 也可以通过 NuGet Console 用命令行安装：Install-Package NLog.Config。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:1:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"日志等级 跟大多数日志框架一样，NLog 也有很多内置的日志等级，使用时可以根据日志名称和等级通过配置筛选想看到的日志。 NLog 支持的日志等级如下： Trace - 最细的调试等级，比如要调试很细微的通讯协议可以用该等级。该等级一般只用于开发阶段。 Debug - 调试等级，没有 Trace 等级细，用于调试系统的运行流程。该等级一般不用于生产环境。 Info - 一般信息。该等级一般用于生产环境。 Warn - 警告等级，一般是一些不会引起严重问题的警告，可以恢复或只是一些临时性的故障。 Error - 错误，大多数时候用于显示程序捕获到的 Excetion。 Fatal - 崩溃，非常严重的错误。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:2:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"创建日志记录对象 NLog 有两个最常用的类，一个是：Logger，另一个是：LogManager。Logger 提供一系列记录日志的 API，而 LogManager 负责创建 Logger 对象。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:3:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"记录日志信息 通过 Logger 对象调用不同的日志等级名称命名的 API 来记录日志，也可以使用 Log() 方法传入日志等级的枚举作为参数来记录日志。 using NLog; public class MyClass { private static Logger logger = LogManager.GetCurrentClassLogger(); public void MyMethod1() { logger.Trace(\"Sample trace message\"); logger.Debug(\"Sample debug message\"); logger.Info(\"Sample informational message\"); logger.Warn(\"Sample warning message\"); logger.Error(\"Sample error message\"); logger.Fatal(\"Sample fatal error message\"); // alternatively you can call the Log() method // and pass log level as the parameter. logger.Log(LogLevel.Info, \"Sample informational message\"); } } 你可以直接使用这些日志 API 来格式化字符串，就跟使用 Console.WriteLine() 和 String.Format() 一样。 using NLog; public class MyClass { private static Logger logger = LogManager.GetCurrentClassLogger(); public void MyMethod1() { int k = 42; int l = 100; logger.Trace(\"Sample trace message, k={0}, l={1}\", k, l); logger.Debug(\"Sample debug message, k={0}, l={1}\", k, l); logger.Info(\"Sample informational message, k={0}, l={1}\", k, l); logger.Warn(\"Sample warning message, k={0}, l={1}\", k, l); logger.Error(\"Sample error message, k={0}, l={1}\", k, l); logger.Fatal(\"Sample fatal error message, k={0}, l={1}\", k, l); logger.Log(LogLevel.Info, \"Sample informational message, k={0}, l={1}\", k, l); } } 提示： 但是要避免使用 String.Format() 来直接格式化日志内容，而要使用 NLog 自己的 API 来格式化，主要原因是出于性能考虑。 如果使用 NLog 的 API 来格式化，那么 NLog 只会在在这段日志确定会被输出到某个目标时才执行格式化操作，而如果使用 String.Format()，那么每当代码运行到这里都会执行字符串格式化。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:4:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"配置 NLog 的配置比起 log4net 就要简单清晰得多来，而且在 Visual Studio 里加载配置的 XML 架构描述文件后还有智能提示，对于入门选手来说可谓是相当的简单。 NLog 的配置主要有两个方面，第一个是要配置输出日志的目标，就是定义一个存储日志的地方；第二个就是定义一个日志对象，日志对象需要定义要输出的日志的级别，再关联一个输出目标就可以来。如下是一个最简单的输出到文本文件的配置： \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003cnlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\u003e \u003ctargets\u003e \u003ctarget name=\"logfile\" xsi:type=\"File\" fileName=\"file.txt\" /\u003e \u003c/targets\u003e \u003crules\u003e \u003clogger name=\"SomeNamespace.Component.*\" minlevel=\"Trace\" writeTo=\"logfile\" final=\"true\" /\u003e \u003clogger name=\"*\" minlevel=\"Info\" writeTo=\"logfile\" /\u003e \u003c/rules\u003e \u003c/nlog\u003e ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:5:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"其他知识点 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:6:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"内部诊断日志 内部诊断日志是 NLog 自身的调试日志，一般情况下不必打开，主要用来调试 NLog 不正常工作的情况，比如日志没有按照配置输出到指定地方，或者 NLog 扩展没有正常工作等情况。打开内部诊断日志很简单，需要在配置的根节点 \u003cnlog\u003e 下面配置以下几个特性： internalLogFile=\"file.txt\" - 指定内部诊断日志的输出路径。 internalLogLevel=\"Trace|Debug|Info|Warn|Error|Fatal|Off\" – 决定内部诊断日志输出的最小等级，跟我们外部调用者一样，内部诊断日志对象也是分等级的。 internalLogToConsole=\"false|true\" – 是否输出内部诊断日志到控制台。 internalLogToConsoleError=\"false|true\" – 是否输出内部诊断日志到控制台的错误输出。（stderr，不太明白跟上一个的区别） 下面是一个比较完整的配置： \u003cnlog internalLogFile=\"c:\\log.txt\" internalLogLevel=\"Trace\"\u003e \u003ctargets\u003e \u003c!-- target configuration here --\u003e \u003c/targets\u003e \u003crules\u003e \u003c!-- log routing rules --\u003e \u003c/rules\u003e \u003c/nlog\u003e 当然，使用程序代码也能配置内部日志参数： using NLog; using NLog.Common; class Program { static void Main() { // enable internal logging to the console InternalLogger.LogToConsole = true; // enable internal logging to a file InternalLogger.LogFile = \"c:\\\\log.txt\"; // set internal log level InternalLogger.LogLevel = LogLevel.Trace; } } ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:6:1","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"性能优化 之前比较过 NLog 和 Log4Net 的性能，NLog 略胜一筹，但是在使用的过程当中还是有几点需要注意。 不要使用 string.format 来格式化字符串参数，而是将字符串参数直接传给 NLog 的方法。 不要使用多线程去写多个文件。 可以使用条件日志 “Conditional logging”，用法如下： Conditional logging 当存在使用大量诊断日志的情况下，从 NLog4.0 开始可以使用这种方法来优化： Logger.Trace(\"entering method {0}\", methodname); 替换为 Logger.ConditionalTrace(\"entering method {0}\", methodname); 这段日志的调用只会在 .Net 编译器添加 DEBUG 条件的时候才会包含进去。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:6:2","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["deploy"],"content":"Web Deploy 支持直接从本地 Visual Studio 的工程文件部署网站到远程服务器，部署的过程中可以对比哪些文件变化了需要拷贝，而不是一股脑的全部拷贝，效率和准确性会更好。 部署的过程主要要注意以下几点： ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:0:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"远程服务器的 IIS 安装管理服务 安装管理服务安装管理服务 \" 安装管理服务 ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:1:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"IIS 控制面板中启动管理服务，使用 Windows 凭据还是 IIS 凭据视需要而定 IIS 凭据IIS 凭据 \" IIS 凭据 完毕之后可以看到服务列表中的 WMSVC 启动 WMSVC 启动WMSVC 启动 \" WMSVC 启动 ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:2:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"安装Web Deploy，地址 http://www.iis.net/downloads/microsoft/web-deploy ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:3:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"本地 Visual Studio 链接测试 链接测试链接测试 \" 链接测试 注意站点名称必须和 IIS 中的站点名称匹配才能验证连接成功，还有注意你的服务器 IP 地址必须能够 Ping 通，防火墙端口 8172 必须开放。整个过程我只遇到一个问题，与这篇文章类似：http://www.benday.com/2013/07/12/fix-error_could_not_connect_to_remotesvc-error-using-visual-studio-2012-web-deploy/ ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:4:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["dotnet"],"content":"假如有这样一个场景，1 个 100 万用户同时在线的系统，假设有一个 Session 管理器来管理它们的存亡，每个用户的 Session 有效时间假设 5 分钟，通常一个最简单的做法是在一个 Session 管理器中启动一个 Thread 去定时校验每个 Session 是否到达有效期截止时间，将到期的 Session 清理掉，而这个需求就导致存放 Session 的字典必须支持并发。而另一种做法就是在每个 Session 对象的内部去启动一个 Timer 让 Timer 在指定时间后去校验自身是否到期，若到期则发出事件通知让管理器去做清理工作。 测试结果，使用 Thread 的方式 CPU 一直保持在 4% 左右，而使用 Timer 的方式 CPU 保持在 0，内存比 Thread 方式多用 100 多 mb。按照存储比 CPU 便宜的标准，即使是内存消耗感觉也是第二种方式会更好一些。 2017 年 3 月 9 日补充：这篇文章过时了，今天读到篇文章，原来可以用一种叫环形队列的数据结构来处理这种大量的超时任务。参见：http://mp.weixin.qq.com/s/mvFwjgxliwx808Hn_9ruEA。 ","date":"2016-06-22","objectID":"/timer-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF/:0:0","tags":["dotnet","async"],"title":"Timer 的性能优势","uri":"/timer-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF/"},{"categories":["xamarin"],"content":"Xamarin Android 项目在编译时会从 google 的服务器下载缺失的 m2repository 相关文件，虽然不明白这是干什么的，但是情况就是 Andorid SDK Manager 不会去下载这个东西，然后在 VS 里编译某些项目时会去下载某些版本的 m2repository 文件。 由于墙的关系这个肯定是下载不下来的，所以只能通过迅雷穿墙下载，然后拷贝到指定的目录，这个目录就是它报错的提示里的一个文件夹，路径类似于：C:\\Users\\Administrator\\AppData\\Local\\Xamarin\\zips，下载的路径可以从国内的镜像网站找，也可以根据报错提示从 google 的网站下，官方的下载路径类似于：https://dl-ssl.google.com/android/repository/android_m2repository_r10.zip 下载完毕后需要放入上面的指定文件夹，还要修改文件的名字，对应关系如下（截止至 23.3.0 版）： Android： 23.3.0 —— android_m2repository_r29.zip —————– 2A3A8A6D6826EF6CC653030E7D695C41.zip 23.2.1 —— android_m2repository_r28.zip —————– 17BE247580748F1EDB72E9F374AA0223.zip 23.1.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.0.1.3 —— android_m2repository_r22.zip —————– 96659D653BDE0FAEDB818170891F2BB0.zip 23.0.1.1 —— android_m2repository_r20.zip —————– 650E58DF02DB1A832386FA4A2DE46B1A.zip 22.2.1 —— android_m2repository_r16.zip —————– 0595E577D19D31708195A83087881EE6.zip 22.2.0 —— android_m2repository_r15.zip —————– F9D66CC0ADC0C3787F4DAE6D494E6BC7.zip 22.1.1.1 —— android_m2repository_r14.zip —————– AB24E1C26FC70B44683752D37075AC06.zip 22.0.0 —— android_m2repository_r12.zip —————– 806FD8EEF161DCEA979C128F27BE5867.zip 21.0.3 —— android_m2repository_r10.zip —————– 1FD832DCC1792D8ACA07FAC3259FC5A9.zip 19.0.1 —— support_r19.0.1.zip —————– CED55A39D1283BB9DC217CAE987067E0.zip Google： 8.4 —— google_m2repository_r24.zip —————– CAA441D76F04E0D57C4110F8A00CDA7A.zip 以上有缺失和错误的欢迎补充，给出一个完整包的下载地址： http://pan.baidu.com/s/1boOwuZ1 ","date":"2016-05-16","objectID":"/%E8%A7%A3%E5%86%B3-xamarin-android-%E5%A2%99%E7%9A%84%E9%97%AE%E9%A2%98/:0:0","tags":["xamarin","dotnet"],"title":"解决 Xamarin Android 墙的问题","uri":"/%E8%A7%A3%E5%86%B3-xamarin-android-%E5%A2%99%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["xamarin"],"content":"在 Xamarin 中有一些 Forms 原生不太好实现的内容可以考虑使用 HTML、Javascript、CSS 那一套前端技术来实现，使用 WebView 来承载显示本地或网络上的 HTML 文件。不像 OpenUri 方法，不是将用户带到设备中的本地浏览器里去，而是用 WebView 直接在 App 内部显示 HTML 内容。 该文档由下面几节内容组成： 内容（Content）——WebView 支持各种内容元素，包括嵌入式 HTML 文件，Web 页面和 HTML 字符串。 导航（Navigation）——WebView 支持导航到特定的页面并返回。 事件（Events）——监听并相应响应用户在 WebView 中触发的动作。 性能（Performance）——了解各平台上 WebView 的性能特点。 权限（Permissions）——了解在 App 中使用 WebView 的相应权限设置。 布局（Layout）——WebView 对布局有一些特别要求，了解如何恰当的显示 WebView。 imgimg \" img ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:0:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Content WebView 支持下列几种内容： HTML 和 CSS 网站——WebView 全方位支持 HTML 和 CSS 布局的网站，也包括对 JavaScript 的支持。 文档（Documents）——因为 WebView 使用的是平台本地组件，所以 WebView 可以显示平台所支持的那些文档类型。这意味着，PDF 文件可以直接在 iOS 和 Android 平台上显示，但是 Windows Phone 平台不能。 HTML 字符串——WebView 可以显示内存中的 HTML 字符串。 本地文件——WebView 可以显示嵌入在 App 中的任何内容。 注意： Windows 和 Windows Phone 平台上的 WebView 并不支持 Silverlight，Flash和任何的 ActiveX 控件，即使该平台上的 Internet Explorer 浏览器都支持。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"网站（Websites） 要显示因特网上的一个网站，可以给 WebView 的 Source 属性设置一个 URL 字符串： var browser = new WebView { Source = \"http://xamarin.com\" }; 注意： URLs 地址必须是指定协议的完整格式（如：前面必须有\"http://“或”http://\"） iOS 和 ATS 自 iOS 9 以后，默认情况下仅允许应用程序和实现了最佳安全实践的服务通信，如果想和不安全的服务进行通信必须要修改 Info.plist 的设置。 注意： 如果你的应用程序需要链接一个不安全的服务，你应该使用 NSExceptionDomains 设置一些域名做为例外，而不是使用 NSAllowsArbitraryLoads 完全关闭 ATS。 NSAllowsArbitraryLoads 只应该用在某些极端紧急情况下。 下面这个例子展示了如何设置一些特殊域名（此处用 xamarim.com 举例）绕开 ATS 的检验： \u003ckey\u003eNSAppTransportSecurity\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSExceptionDomains\u003c/key\u003e \u003cdict\u003e \u003ckey\u003examarin.com\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSIncludesSubdomains\u003c/key\u003e \u003ctrue/\u003e \u003ckey\u003eNSTemporaryExceptionAllowsInsecureHTTPLoads\u003c/key\u003e \u003ctrue/\u003e \u003ckey\u003eNSTemporaryExceptionMinimumTLSVersion\u003c/key\u003e \u003cstring\u003eTLSv1.1\u003c/string\u003e \u003c/dict\u003e \u003c/dict\u003e \u003c/dict\u003e 良好的实践是只让一部分域名绕开 ATS 的检验，允许你访问受信任的网站同时也能更安全的访问不受信任的域名。下面的例子展示了 App 当中最不安全的一种做法，完全禁用 ATS： \u003ckey\u003eNSAppTransportSecurity\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSAllowsArbitraryLoads \u003c/key\u003e \u003ctrue/\u003e \u003c/dict\u003e 查看 App Transport Security 获取关于 iOS 9 这个新功能的更多信息。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"HTML 字符串 如果你想展示一串被代码动态定义的 HTML 字符串，你需要创建一个 HtmlWebViewSource 的实例： var browser = new WebView(); var htmlSource = new HtmlWebViewSource(); htmlSource.Html = @\"\u003chtml\u003e\u003cbody\u003e \u003ch1\u003eXamarin.Forms\u003c/h1\u003e \u003cp\u003eWelcome to WebView.\u003c/p\u003e \u003c/body\u003e\u003c/html\u003e\"; browser.Source = htmlSource; imgimg \" img 上面的代码中，@ 符号用于标记 HTML 作为一串字面量的字符串，所有通用转义符都会被忽略。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:2","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"本地 HTML 文件 WebView 可以直接展示嵌入在 App 中的 HTML，CSS 和 Javascript，例如： \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eXamarin Forms\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eXamrin.Forms\u003c/h1\u003e \u003cp\u003eThis is an iOS web page.\u003c/p\u003e \u003cimg src=\"XamarinLogo.png\" /\u003e \u003c/body\u003e \u003c/html\u003e CSS： html,body { margin:0; padding:10; } body,p,h1 { font-family: Chalkduster; } 注意上面的 CSS 中指定的特殊字体需要根据不同的平台自定义，不是所有的平台都具有相同的字体。 imgimg \" img 注意： Xamarin.Forms 中当前存在一个 bug，在 Windows 中本地 HTML 内容不能被显示，但是它不会影响 Windows Phone。查看 Bugzilla 获取关于这个 bug 最新状态的更多信息。 使用 WebView 显示本地内容，你需要像打开其他文件一样打开一个 HTML 文件，然后读取内容文本到 HtmlWebViewSource 的 Html 属性上。关于打开文件的更多信息，可以查看 Working with Files。 虽然我们读取了第一个页面，但是 WebView 并不知道 HTML 来自于哪里。这样在处理页面引用本地资源时就会有问题。例如，一个本地文件很可能有一个指向另一个文件的链接，也有可能使用一个分离的 JavaScript 文件，或者一个 CSS 样式文件。 为了解决这个问题，你需要告诉 WebView 到文件系统的哪里去寻找文件。此时需要设置 WebView 所引用的 HtmlWebViewSource 对象的 BaseUrl 属性。 因为文件系统在每个操作系统上是不一样的，所以你需要针对每个平台确定它的 URL。Xamarin.Forms 可以通过 DependencyService 解决运行时的平台依赖。 要使用 DependencyService，需要先定义一个可被各平台所实现的接口： public interface IBaseUrl { string Get(); } 注意，该接口需要被各个平台实现，否则 App 会无法运行。在公共项目中，要确保你记得使用 DependencyService 设置 BaseUrl 的值： var source = new HtmlWebViewSource(); source.BaseUrl = DependencyService.Get\u003cIBaseUrl\u003e().Get(); 至此，你只需要在各个平台中实现这个接口就可以了： iOS [assembly: Dependency(typeof(BaseUrl_iOS))] namespace WorkingWithWebview.iOS { public class BaseUrl_iOS : IBaseUrl { public string Get() { return NSBundle.MainBundle.BundlePath; } } } 此时网站的位置会被定位到项目的根目录或者 Resources 目录，并且文件的生成操作应该修改为 BundleResource，如下图： imgimg \" img Android 在 Android 平台下，HTML，CSS 和图片文件应该位于 Assets 文件夹下，并且生成操作应该修改为 AndroidAsset，如下图： imgimg \" img Android 平台下，BaseUrl 的值应该设置为 \"file:///android_asset/\"： [assembly: Dependency(typeof(BaseUrl_Android))] namespace WorkingWithWebview.Android { public class BaseUrl_Android : IBaseUrl { public string Get() { return \"file:///android_asset/\"; } } } Android 平台下，Assets 文件夹下的文件也可以通过 Forms.Context.Assets 属性访问，代码如下： var assetManager = Xamarin.Forms.Forms.Context.Assets; using (var streamReader = new StreamReader(assetManager.Open(\"local.html\"))) { var html = streamReader.ReadToEnd(); } Windows Phone 注意： 在Windows Phone 8.1 下 WebView 不支持本地内容，但是在 Windows Phone 8 下支持。 在 Windows Phone 平台下，HTML，CSS 和图片文件位于项目根目录，并且生成操作应该修改为 Content，如下图： imgimg \" img Windows Phone 平台下，BaseUrl 的值应该设置为\"\"： [assembly: Dependency(typeof(BaseUrl_Windows))] namespace WorkingWithWebview.Windows { public class BaseUrl_Windows : IBaseUrl { public string Get() { return \"\"; } } } ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:3","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Navigation WebView 可以通过几个方法和属性来进行导航： GoForward()——如果 CanGoForward 等于 true，调用 GoForward 导航到下一个访问页面。 GoBack()——如果 CanGoBack 等于 true，调用 GoBack 将会导航到最后一个访问过的页面。 CanGoBack——如果有页面可以返回则该值等于 true，如果浏览的是起始 URL 则该值返回 false。 CanGoForward——如果用户返回了某个页面并且可以向前访问某个已经访问过的页面则该值为 true。 在页面内部，WebView 不支持多点触控。所以重点是需要针对移动端优化内容，使其呈现时不需要额外的缩放等操作。 对于应用程序来说，在 WebView 中展示链接比在设备的浏览器中展示更常见。在这种情况下，允许正常的导航非常有用，但是当用户在起始页面点击返回按钮时，程序会返回到一个正常的 App 页面中。 下面演示如何使用内建的方法和属性启用这种场景。 首先在一个 page 页面中创建一个浏览器视图： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"WebViewDemo.InAppDemo\" Title=\"In App Browser\"\u003e \u003cContentPage.Content\u003e \u003cStackLayout\u003e \u003cStackLayout Orientation=\"Horizontal\" Padding=\"10,10\"\u003e \u003cButton Text=\"Back\" HorizontalOptions=\"StartAndExpand\" Clicked=\"backClicked\" /\u003e \u003cButton Text=\"Forward\" HorizontalOptions=\"End\" Clicked=\"forwardClicked\" /\u003e \u003c/StackLayout\u003e \u003cWebView x:Name=\"Browser\" WidthRequest=\"1000\" HeightRequest=\"1000\" /\u003e \u003c/StackLayout\u003e \u003c/ContentPage.Content\u003e \u003c/ContentPage\u003e 后台代码： public partial class InAppDemo : ContentPage { //sets the URL for the browser in the page at creation public InAppDemo(string URL) { InitializeComponent(); Browser.Source = URL; } private void backClicked(object sender, EventArgs e) { //check to see if there is anywhere to go back to if (Browser.CanGoBack) { Browser.GoBack(); } else { //if not, leave the view Navigation.PopAsync(); } } private void forwardClicked(object sender, EventArgs e) { if (Browser.CanGoForward) { Browser.GoForward(); } } } 最后呈现效果如下： imgimg \" img ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Events WebView 通过触发两个事件来帮助你响应状态变更： Navigating——当 WebView 开始加载一个新页面时触发。 Navigated——当一个页面加载完毕并且导航停止时触发。 如果你能预感到加载网页将会耗费比较长的时间，可以考虑使用这两个事件实现一个状态指示器。代码如下： 界面 XAML 代码： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"WebViewDemo.LoadingDemo\" Title=\"Loading Demo\"\u003e \u003cContentPage.Content\u003e \u003cStackLayout\u003e \u003cLabel x:Name=\"LoadingLabel\" Text=\"Loading...\" HorizontalOptions=\"Center\" isVisible=\"false\" /\u003e \u003cWebView x:Name=\"Browser\" HeightRequest=\"1000\" WidthRequest=\"1000\" Navigating=\"webOnNavigating\" Navigated=\"webOnEndNavigating\" /\u003e \u003c/StackLayout\u003e \u003c/ContentPage.Content\u003e \u003c/ContentPage\u003e 后台两个事件处理： void webOnNavigating (object sender, WebNavigatingEventArgs e) { LoadingLabel.IsVisible = true; } void webOnEndNavigating (object sender, WebNavigatedEventArgs e) { LoadingLabel.IsVisible = false; } 当页面加载中时输出结果如下： imgimg \" img 当页面加载完成时输出如下： imgimg \" img ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Performance 最近的各大 web 浏览器都已经采用了一些被世人所熟知的流行技术，如硬件加速渲染和 JavaScript 编译。不幸的是，出于安全限制，大多数高级功能在 iOS 的 WebView 和 UIWebView 里无法使用。Xamarin.Forms 里的 WebView 在 iOS 平台下实际上是使用的 UIWebView。如果这个限制对你的使用造成了困扰，你需要在平台内部使用支持快速浏览等功能的 WKWebView 进行重新渲染。但是需要注意 WKWebView 仅支持 iOS 8 以上的系统。 WebView 在 Android 的默认设置中跟内建浏览器一样快。 在 Windows Phone 8 和 Windows Phone 8.1 里的 WebBrowser 控件不支持最新的 HTML5 相关新特性，并且它常常出现性能问题。需要注意测试网站在 Windows Phone 的 WebView 中究竟会怎样呈现，如果仅在 IE 浏览器中测试是不够的。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Permissions 为了让 WebView 正常工作，你必须知道各个平台的权限设置。注意在一些平台，WebView 在 debug 模式下可以工作，但是在最后发布时的 release 模式下却不能。这就是权限造成的问题，比如 Android 上的 internet 访问权限，在 Xamarin Studio 的调试模式下默认是打开的。 Windows Phone 8.0——需要 ID_CAP_WEBBROWSERCOMPONENT 权限来使用控件，需要 ID_CAP_NETWORKING 来访问因特网。 Windows Phone 8.1——需要 Internet 才能访问网络内容。 Android——需要 Internet 才能访问网络内容，访问本地内容不需要特殊的权限。 iOS——不需要特殊的权限。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Layout 不像大多数其他 Xamarin.Forms 视图，在 StackLayout 和 RelativeLayout 中嵌套 WebView 时必须指明它的 HeightRequest 和 WidthRequest 属性。如果你没有指明这些属性，那么 WebView 将不会渲染。 下面的例子展示了 WebView 的渲染布局代码： 在 StackLayout 中指明 HeightRequest 和 WidthRequest： \u003cStackLayout\u003e \u003cLabel Text=\"test\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" HeightRequest=\"1000\" WidthRequest=\"1000\" /\u003e \u003c/StackLayout\u003e 在 RelativeLayout 中指明 HeightRequest 和 WidthRequest： \u003cRelativeLayout\u003e \u003cLabel Text=\"test\" RelativeLayout.XConstraint= \"{ConstraintExpression Type=Constant, Constant=10}\" RelativeLayout.YConstraint= \"{ConstraintExpression Type=Constant, Constant=20}\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" RelativeLayout.XConstraint=\"{ConstraintExpression Type=Constant, Constant=10}\" RelativeLayout.YConstraint=\"{ConstraintExpression Type=Constant, Constant=50}\" WidthRequest=\"1000\" HeightRequest=\"1000\" /\u003e \u003c/RelativeLayout\u003e 在 AbsoluteLayout 中不用指明 HeightRequest 和 WidthRequest： \u003cAbsoluteLayout\u003e \u003cLabel Text=\"test\" AbsoluteLayout.LayoutBounds=\"0,0,100,100\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" AbsoluteLayout.LayoutBounds=\"0,150,500,500\" /\u003e \u003c/AbsoluteLayout\u003e 在 Grid 中不用指明 HeightRequest 和 WidthRequest，Grid 是少数的几个不用指明宽和高的布局容器： \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"100\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003cLabel Text=\"test\" Grid.Row=\"0\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" Grid.Row=\"1\" /\u003e \u003c/Grid\u003e 原文链接： https://developer.xamarin.com/guides/xamarin-forms/user-interface/webview/ 相关 Demo：Working with WebView WebView 的简单演示：WebView WebView 的高级演示，包括平台自定义渲染 WebView 和 JavaScript 和 C# 代码交互： HybridWebView ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:6:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"如之前所见的大量可视化元素均有自己的尺寸大小： iOS 的状态栏高度为 20，所以我们需要调整 iOS 的页面的 Padding 值，留出这个高度。 BoxView 设置它的默认宽度和高度为 40。 Frame 的默认 Padding 为 20。 StackLayout 的默认 Spacing 属性值为 6。 还有 Device.GetNamedSize 方法，该方法将 Label 或 Button 等控件中使用的 NamedSize 枚举值转换为不同平台对应的数值，即不同控件中不同 NamedSize 枚举对应的 FontSize 值。 然后上面那些数值代表什么？它们的单位是什么？并且怎样精确的设置这些值获得指定的大小？ 好问题。尺寸大小同样会影响文本的显示效果，正如我们所看到，不同的平台显示的文本的数量也会不一样，那么可以在 Forms 程序中控制显示的文本数量吗？即使可以控制，那会是一种好的编程实践吗？程序应该通过调整尺寸大小来适应屏幕的显示密度吗？ 通常，当编写 Xamarin.Forms 应用程序时不要过于接近那些可视化元素的实际尺寸数值。最好的方式是充分信任 Xamarin.Forms 在三个不同平台下都会做出最好的默认选择。 然后，有时一个开发者还是需要知道部分可视化元素的尺寸大小以及它们所附着的屏幕的尺寸大小。 如你平时所知的一样，视频是由一大堆像素所组成的一个矩形。任何可以显示在屏幕上的可视化元素都有一个像素尺寸。在早期的个人电脑中，开发者都用像素来定位和布局那些可视化元素。但是，随着拥有更多元素的大小尺寸和像素密度的显示设备出现，在编写程序时直接使用像素的方式变得过时和不受开发者欢迎了，必须寻求另一种新的解决方案。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:0:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"Pixels，points，dps，DIPs，DIUs 这种控制像素的方式始于桌面电脑时代的操作系统，于是这种解决方案也自然而然的被用于移动设备。因此，我们将从桌面设备开始探讨这个问题。 桌面视频有大量不同的像素尺寸，从几乎要过时的 640x480 到上千像素。跟电影和电视一样，4:3 的纵宽比也曾经是电脑显示的标准，不过现在更常用高清晰纵宽比，如 16：9 或者 16：10。 桌面视频也有一个物理尺寸，这个物理尺寸通常是测量显示器对角线的英寸和厘米长度。通过像素尺寸和物理尺寸可以计算出这个视频的显示分辨率或者像素密度，像素密度使用 DPI（dots per inch 打印分辨率——即每英寸所打印点数）来描述，有时也可以使用 PPI（pixels per inch 图像的采样率——即每英寸的像素数量）。显示分辨率还可以通过 点距（dot pitch——即相邻像素间的距离，毫米为单位）来描述。 例如，使用毕达哥拉斯定律可以计算出一个 800x600 分辨率的对角线长度上可以容纳 1000 像素点，如果是 13 英寸的显示器，那么像素密度是 77 DPI，或者 0.33 毫米的点距。然后，如果现代笔记本上的 13 英寸显示器可能拥有 2560x1600 的像素尺寸，230 DPI 的像素密度，或者 0.11 毫米的点距。那么同样的一个 100 像素的正方形元素在高精度显示器上的大小可能只有老式显示器的三分之一大。 当开发者试图调整可视化元素到正确的大小就像一场战役一样。因此，Apple 和 Microsoft 计划为桌面电脑建立一套机制来允许开发者用一些设备无关的单位来描述视频显示的尺寸而不是直接使用像素。开发者遇到的大多数尺寸规格都能用这一系列的设备独立单位来描述，而操作系统就负责在这些设备独立单位和像素之间进行转换。 在 Apple 的世界里，桌面视频都假设每英寸拥有 72 单位元素。这一数字来源于印刷排版界，在传统的印刷排版里，每英寸大约有 72 个点，但是在数字排版印刷方面，这个点位的精度已经标准化为 1/72 英寸。使用点的数量来描述比直接使用像素更好，开发者能更直观的感受到屏幕上可视化元素和这个大小包括的尺寸点数之间的关系。 在 Microsoft 世界里，一个相似的技术已经成熟，被称为设备无关像素（device-independent pixels DIPs），或者设备无关单位（device-independent units DIUs）。作为一个 Windows 开发者，需要知道该平台下的桌面视频假定拥有一个 96 DIUs 的分辨率，比 72 DPI 高三分之一。 然而，移动设备拥有不同的规则：一个特点就是现代手机的像素密度比桌面设备高出很多。高像素密度意味着文本和其他可视化元素会收缩在一个很小的尺寸空间中。 手机的另一个特点就是比桌面设备或笔记本更贴近人的面部。这也意味着相同的可视化元素如果呈现在手机上，尺寸可以比桌面设备更小。因为手机的物理尺寸比桌面设备更小，所以缩小可视化元素来适应屏幕就变得十分可取。 Apple 继续在 iPhone 上使用 DIUs 来描述点数，直到最近，所有的苹果设备都采用来一种被叫做 Retina 的高清屏解决方案，该方案使单点的像素密度变成原来的两倍。这个规则适用于苹果的几乎所有设备，MacBook Pro，iPad 和 iPhone。直到 iPhone 6 Plus 的出现，将单点的像素密度变成了原来的三倍。 例如，iPhone 4 拥有 3.5 英寸屏幕，640x960 像素显示分辨率，320 DPI 的像素密度。由于单点有两倍的像素密度，所以当应用程序运行在 iPhone4 上当时候，将会在屏幕上呈现 320x480 个点。iPhone 3 有 320x480 的像素显示分辨率，点的数量等于像素的数量，所以，对于一个程序来说，呈现在 iPhone 3 和 iPhone 4 上的大小相同。尽管大小尺寸相同，但是 iPhone 4 上的文本和可视化元素将会显示在一个更高的分辨率之上。 对于 iPhone 3 和 iPhone 4，从屏幕尺寸和点数尺寸的关系上来说，它们拥有比桌面设备每英寸 72 点更大的一个密度，每英寸 160 点。 iPhone 5 拥有一个 4 英寸屏幕，但是它点像素尺寸达到了 640x1136。像素密度和 iPhone 4 一样，对于程序来说，屏幕上点数尺寸为 320x768。 iPhone 6 拥有 4.7 英寸屏幕，像素尺寸为 750x1334。像素密度同样也是 320 DPI，每单位点有两个像素，所以对于程序来说，屏幕上能呈现的点数尺寸为 375x667。 然而，iPhone 6 Plus 拥有 5.5 英寸屏幕，像素尺寸为 1080x1920，像素密度为 400DPI，更高的像素密度意味着一个点上有更多的像素，对于 iPhone 6 Plus，Apple 设定一个点等于三个像素点。给我们的感觉是屏幕的点数尺寸应该是 360x640，但是实际对于程序来说，iPhone 6 Plus 点屏幕点数尺寸是 414x736，每英寸 150 个点。 以上信息总结起来就如下面这个表： 型号 iPhone 2，3 iPhone 4 iPhone 5 iPhone 6 iPhone 6 Plus 像素尺寸 320x480 640x960 640x1136 750x1134 1080x1920 屏幕尺寸 3.5 英寸 3.5 英寸 4 英寸 4.7 英寸 5.5 英寸 像素密度 165 DPI 330 DPI 326 DPI 326 DPI 401 DPI 单位点包含像素数量 1 2 2 2 3 点数尺寸 320x480 320x480 320x568 375x667 414x736 每英寸包含点数量 165 165 163 163 154 Android 也十分相似，只是 Andorid 设备拥有更多的设备尺寸和显示尺寸，但是 Andorid 开发者在工作中通常不关心具体设备，而是关心密度无关像素这个单位（density-independent pixel dps）。像素密度和 dps 之间的关系是，每英寸呈现 160dps，即 Andorid 和 Apple 的单位很相似。 然而 Mircosoft 通过 Windows Phone 带来了一种不同的方式。Windows Phone 7 设备无论它的屏幕分辨率是 320x480（这种分辨率很稀有，可不做讨论）或者是 480x800（通常叫做 WVGA Wide Video Graphics Array），都拥有统一的像素尺寸。Windows Phone 7 程序工作在这种像素单位的基础上。假设一台最平常的 4 英寸 480x800 的 Windows Phone 7 设备，这意味着该设备的像素密度大约是 240DPI。而这是 iPhone 和 Android 设备的 1.5 倍。 当 Windows Phone 8 来临时，出现了很多更大屏幕的设备，768x1280（WXGA Wide Extended Graphics Array），720x1280（720P），1080x1920（1080P）。 对于这三种额外的尺寸，开发者同样使用设备无关的单位。此时，一个内部的缩放机制将会使所有设备在竖屏情况下宽度都呈现 480 像素。对应的比例因子如下表： 屏幕类型 WVGA WXGA 720P 1080P 像素尺寸 480x800 768x1280 720x1280 1080x1920 缩放比例 1 1.6 1.5 2.25 DIUs 尺寸 480x800 480x800 480x853 480x853 Xamarin.Forms 开发者通常使用设备无关的方式来处理手机显示，但是在具体三个平台上也有一些不一样： iOS：每英寸 160 单位 Android：每英寸 160 单位 Windows Phone：每英寸 240 单位 如果将相同物理大小的可视化元素放在三个平台，那么 Windows Phone 平台上看见的大小会比 iOS 和 Android 大 1.5 倍。 VisualElement 类定义了两个属性，Width 和 Height，这两个元素用设备无关的单位来描述 views，layouts 和 pages。这两个属性的初始值被设置为伪值 -1。只有当 page 上的所有元素都已经定位和调整大小完毕这两个属性的值才有效。同样，需要注意 HorizontalOptions 或 VerticalOptions 的默认值是 Fill，这个设置将会让视图尽可能的占据更多的空白地方。 Width 和 Height 的值也可以用来反映一些额外空间值，比如 Padding，设置后的区域会被 view 的 BackgroundColor 属性指定的颜色填充。 VisualElement 定义了一个 SizeChanged 事件，当一个可视化元素的 Width 或 Height 属性发生变化时触发。当 page 对内部的大量元素进行定位和调整大小时会触发一系列事件，SizeChanged 事件就是其中一个。这个构造的过程会在第一次定义这个 page 时出现（通常是在 page 的构造中），而任何一个对布局内容的影响都会使这一过程再次发生，例如将视图添加到 ContentPage 或者 StackLayout 中，或从它们中移除，或者改变可视化元素的大小。 当屏幕尺寸发生改变时同样也会触发新的布局过程，这种情况通常发生在设备在竖屏和横屏之间进行切换的","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"可测量尺寸（Metrical sizes） 这里再一次强调一下三个平台上的英寸和设备无关单位之间的关系： iOS：每英寸 160 单位 Android：每英寸 160 单位 Windows Phone：每英寸 240 单位 下面是尺寸以厘米为单位的情况： iOS：每厘米 64 单位 Android：每厘米 64 单位 Windows Phone：每厘米 96 单位 那么意味着 Xamarin.Forms 程序可以使用以上可测量尺寸来更改可视化元素大小，使用熟悉的英寸或厘米为单位。下面给出一个名叫 MetricalBoxView 的程序来展示这个问题，该程序在屏幕上显示了一个宽大约 1 厘米高大约 1 英寸的 BoxView。 public class MetricalBoxViewPage : ContentPage { public MetricalBoxViewPage() { Content = new BoxView { Color = Color.Accent, WidthRequest = Device.OnPlatform(64, 64, 96), HeightRequest = Device.OnPlatform(160, 160, 240), HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center }; } } 如果你使用直尺在手机屏幕上测量，你会发现结果跟我们希望的尺寸很接近。 imgimg \" img ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"估计字体大小（Estimated font sizes） Label 和 Button 控件上的 FontSize 属性的类型是 double。FontSize 指的是文本字符从最下面到最上面到高度，也包括该字体对应的标点符号。在大多数情况下，你需要通过 Device.GetNamedSize 方法设置这个属性。该方法允许你使用一系列 NamedSize 相关到枚举值：Default，Micro，Small，Medium，Large。 你也可以使用字体大小的实际数字，但是这么做会引起一个小问题（稍后会谈到这个细节）。在大多数情况下，Xamarin.Forms 通过相同的设备无关单位来表示字体的大小，这意味着你可以基于不同的平台分辨率计算设备无关的字体大小。 例如，假设你想在程序中使用 12 号字体。首先，你必须要知道 12 号字体用于印刷材料或是桌面显示器的效果很好，但是如果用于手机就太大了。 如果移动设备上一英寸有 72 个点，那么 12 号字体大约是六分之一英寸，乘以分辨率的 DPI。结果是 iOS 和 Android 设备大约是 27 设备无关单位，Windows Phone 大约是 40 设备无关单位。 我们写一个名叫 FontSizes 的小程序，开头部分与第三章中的 NamedFontSizes 程序很相似，后面还列出了不同字体的点数大小，使用设备点分辨率转换为设备无关单位。 public class FontSizesPage : ContentPage { public FontSizesPage() { BackgroundColor = Color.White; StackLayout stackLayout = new StackLayout { HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center }; // Do the NamedSize values. NamedSize[] namedSizes = { NamedSize.Default, NamedSize.Micro, NamedSize.Small, NamedSize.Medium, NamedSize.Large }; foreach (NamedSize namedSize in namedSizes) { double fontSize = Device.GetNamedSize(namedSize, typeof(Label)); stackLayout.Children.Add(new Label { Text = String.Format(\"Named Size = {0} ({1:F2})\", namedSize, fontSize), FontSize = fontSize, TextColor = Color.Black }); } // Resolution in device-independent units per inch. double resolution = Device.OnPlatform(160, 160, 240); // Draw horizontal separator line. stackLayout.Children.Add( new BoxView { Color = Color.Accent, HeightRequest = resolution / 80 }); // Do some numeric point sizes. int[] ptSizes = { 4, 6, 8, 10, 12 }; foreach (double ptSize in ptSizes) { double fontSize = resolution * ptSize / 72; stackLayout.Children.Add(new Label { Text = String.Format(\"Point Size = {0} ({1:F2})\", ptSize, fontSize), FontSize = fontSize, TextColor = Color.Black }); } Content = stackLayout; } } 为便于在三个平台上面比较，背景已被统一设置为白色，文字设置为黑色。在 StackLayout 中间用一个高 1/8 英尺的 BoxView 将两部分分隔开。 这个程序提供了一个粗略的思路让你能够在三个平台上产生视觉上差不多大小的元素。括号中的数字是特定平台下的设备无关的 FontSize 数值。 imgimg \" img 然而在 Android 平台下有一个问题，运行 Android 的 Settings，进入 Display 页面，选择 Font size 项，可以看到，有 Small，Normal（默认），Large，Huge 这几个字号选择。这项设置可以给用户提供更广的字号选择，对于那些觉得字体太小感觉眼睛不舒服的用户可以将字号调大，对于那些眼睛很好想一次多看一些字的用户可以将字号设小。 在设置中修改字号，选择除 Normal 外的其他选项，然后重新运行 FontSizes 程序，可以看到程序里的所有文本都不一样里，根据你的设置，文本比之前都更大或更小了。你可以看到在水平线的上面部分，也就是 Device.GetNamedSize 方法返回的数值根据系统字号的不同发生了变化。对于 NamedSize.Default，Normal 的默认设置返回的字号是 14（就如上面的截图所展示的一样），如果设置为 Small 则返回 12，Large 返回 16，Huge 返回 18.33。 除了 Device.GetNamedSize 返回的值不一样以外，根据字号设置的不同，底层文本绘制的逻辑也不一样。继续看程序的下面部分，程序计算出的字体的点位值依然相同，虽然它们的文本大小已经发生了改变。这是用枚举值设置 Android 的 Label 的结果，Android 在内部会使用 ComplexUnitType.Sp（COMPLEX_UNIT_SP）计算字体大小，SP 代表缩放像素 scaled pixel，当文本超过使用的设备无关像素时会产生一个缩放。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"调整文本到合适的尺寸（Fitting text to available size） 也许你需要调整一堆文本到一定大小的矩形区域，你可以使用两个数值来计算，一个是矩形区域的实际尺寸，另一个是装载这些文本的 Label 控件的 FontSize 属性值（但是 Andorid 需要将 Font size 设置为 Normal）。 第一个需要的数值是行距，即 Label 视图里每一行文本间的垂直高度。下面展示了三个平台下的具体行高值： iOS：行距 = 1.2 * label.FontSize Android：行距 = 1.2 * label.FontSize Windows Phone：行距 = 1.3 * label.FontSize 第二个有帮助的数值是字符宽度，不管在哪个平台，一段混合了大小写的默认字体的字符宽度大约是 font size 的一半： 平均字符宽度 = 0.5 * label.FontSize 例如，假设你想在宽度为 320 的长度内容纳 80 个文本字符，并且你想让字体尽量的大。那么 320 除以 40（宽度大约占高度一半）得到字号为 8，这个数值就是我们可以给 Label 的 FontSize 属性赋的值。对于文本来说在真正测试之前还有一些不确定性，希望不要对你的计算结果产生太多惊喜。 下面这个程序展示了如何让行距以及字符宽更适合页面中的一段文本，当然这个页面是不包括 iPhone 的状态栏的。为了让 iPhone 排除状态栏更容易一些，这个程序使用了 ContentView。 ContentView 继承自 Layout，只添加了一个 Content 属性。ContentView 是 Frame 的基类，但是 Frame 没有添加过多的额外功能。然而，当你想在自定义页面中定义一组视图，并轻松的模拟它们间的外边距，它将变得很有用。 也许你注意到了，Xamarin.Forms 没有一个 margin 的概念，跟 padding 很相似，padding 定义了视图里的内边距，而 margin 定义了视图外面的外边距。ContentView 可以让我们模拟这个，如果你发现一个视图需要一个外边距，那么你可以将这个视图放在 ContentView 中，并且设置这个 ContentView 的 Padding 属性。ContentView 的 Padding 属性继承自 Layout。 这个 EstimatedFontSize 程序使用 ContentView 的方式略有不同：它通过设置整个页面的 padding 来避开 iOS 的状态栏，而不是将页面中的某一项内容设置到 ContentView 中。因此，此处的 ContentView 除了 iOS 的状态栏以外与页面有相同的尺寸。通过附加 ContentView 的 SizeChanged 事件来获取内容区的尺寸，通过这个尺寸来计算文本的字号。 SizeChanged 事件的处理方法中使用了第一个参数，这个参数通常是引发这次事件的对象（在这个程序里就是包含那个文本填充的 ContentView），代码如下： public class EstimatedFontSizePage : ContentPage { Label label; public EstimatedFontSizePage() { label = new Label(); Padding = new Thickness(0, Device.OnPlatform(20, 0, 0), 0, 0); ContentView contentView = new ContentView { Content = label }; contentView.SizeChanged += OnContentViewSizeChanged; Content = contentView; } void OnContentViewSizeChanged(object sender, EventArgs args) { string text = \"A default system font with a font size of S \" + \"has a line height of about ({0:F1} * S) and an \" + \"average character width of about ({1:F1} * S). \" + \"On this page, which has a width of {2:F0} and a \" + \"height of {3:F0}, a font size of ?1 should \" + \"comfortably render the ??2 characters in this \" + \"paragraph with ?3 lines and about ?4 characters \" + \"per line. Does it work?\"; // Get View whose size is changing. View view = (View)sender; // Define two values as multiples of font size. double lineHeight = Device.OnPlatform(1.2, 1.2, 1.3); double charWidth = 0.5; // Format the text and get its character length. text = String.Format(text, lineHeight, charWidth, view.Width, view.Height); int charCount = text.Length; // Because: // lineCount = view.Height / (lineHeight * fontSize) // charsPerLine = view.Width / (charWidth * fontSize) // charCount = lineCount * charsPerLine // Hence, solving for fontSize: int fontSize = (int)Math.Sqrt(view.Width * view.Height / (charCount * lineHeight * charWidth)); // Now these values can be calculated. int lineCount = (int)(view.Height / (lineHeight * fontSize)); int charsPerLine = (int)(view.Width / (charWidth * fontSize)); // Replace the placeholders with the values. text = text.Replace(\"?1\", fontSize.ToString()); text = text.Replace(\"??2\", charCount.ToString()); text = text.Replace(\"?3\", lineCount.ToString()); text = text.Replace(\"?4\", charsPerLine.ToString()); // Set the Label properties. label.Text = text; label.FontSize = fontSize; } } 这段文本中可以看到唯一名称为“?1”，“??2”，“?3”和“?4”的占位符，程序运行中会用文本的信息替换掉这些占位符。 如果我们的目标是让文本尽量的大但是又不会溢出一屏的范围，那么结果会跟下面的图很接近： imgimg \" img 效果不错，虽然 iPhone 和 Android 实际上只显示了 14 行文本，但技术看起来还是可靠的。我们没必要让横屏模式计算出的 FontSize 值也相等，但有时候它也确实可以做到： imgimg \" img ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"一个大小合适的计时器（A fit-to-size clock） Class 类中包含一个静态 StartTimer 方法让你能够设置一个计时器定期触发事件。这个可用的周期性事件可以保证这个计时器应用可行，虽然这个应用只是简单的展示一个时间文本。 此处 Device.StartTimer 方法的第一个参数使用一个 TimeSpan 类型的值表示一个时间间隔，这个时间间隔直接影响计时器的触发周期（你的设置可以低到 15 或 16 毫秒，大概等于每秒 60 帧的显示器的帧速率周期），计时器的事件处理函数没有参数，但是需要返回 true 让计时器继续。 程序 FitToSizeClock 创建了一个 Label 用于显示时间然后设置了两个事件：页面的 SizeChanged 事件用于改变字号，Device.StartTimer 事件用于每秒钟改变时间文本值。两个事件的处理代码都是只需要简单的改变 Label 的一个属性，所以可以使用 lambda 表达式来简化写法，就不需要将 Label 存成字段，直接在 lambda 表达式里就直接访问。 public class FitToSizeClockPage : ContentPage { public FitToSizeClockPage() { Label clockLabel = new Label { HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center }; Content = clockLabel; // Handle the SizeChanged event for the page. SizeChanged += (object sender, EventArgs args) =\u003e { // Scale the font size to the page width // (based on 11 characters in the displayed string). if (this.Width \u003e 0) clockLabel.FontSize = this.Width / 6; }; // Start the timer going. Device.StartTimer(TimeSpan.FromSeconds(1), () =\u003e { // Set the Text property of the Label. clockLabel.Text = DateTime.Now.ToString(\"h:mm:ss tt\"); return true; }); } } 在 StartTimer 的方法中指定了一个 DateTime 的自定义格式化字符串将文本格式化为一段 10 个或 11 个的文本字符，文本都是大写字符，并且宽度比平均宽度更宽。在 SizeChanged 处理函数中隐藏了一个逻辑，即假设要显示的文本字符数为 12 个，那么设置它的字号应该是页面宽度的 1/6： imgimg \" img 当然，在横屏模式下文本会变得更大： imgimg \" img 再次提醒，该技术在 Android 平台下只能用于系统设置中 Font size 的值设置为 Normal 的情况。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"凭经验使用恰当的文本（Empirically fitting text） 在一个特定的矩形框大小范围内填充合适的文本的另一个解决方法是：先凭经验设置文本的字号，然后在此基础上再调大或调小。该方法的优点是在 Android 设备上无论用户系统设置中的 Font size 是什么，都可以很好的工作。 但这个过程可能比较棘手：第一个问题是在字体大小和渲染文本的高度上没有一个清晰的线性关系。当文本在它的容器中宽度越大时，它在单词间就越容易出现分行，这种情况会造成更多的空间浪费。所以为了找到最佳字号往往会重复多次计算。 第二个问题涉及到 Label 渲染一个指定大小字号的文本时，获取 Label 尺寸的一个机制。你可以处理 Label 的 SizeChanged 事件，但是在处理函数里你不能做任何改变（如设置一个新的 FontSize 属性），因为这样做会引起这个事件处理函数的递归调用。 一个更好的方式是调用 GetSizeRequest 方法，这个方法定义在 VisualElement 类中， Label 和其他所有视图元素都继承自这个类。GetSizeRequest 方法需要两个参数，一个是宽度的限制，另一个是高度的限制。这两个值可以表示一个矩形范围，以此来限制你想让这个元素填充的一个范围，并且这两个值可以部分或全部都定义为无穷大。当调用 Label 的 GetSizeRequest 方法时，通常可以将宽度限制为 Label 元素容器的宽度，高度设置为 Double.PositiveInfinity。 GetSizeRequest 方法返回一个类型为 SizeRequest 的值，该类型为一个结构体，定义了两个属性 Minimum 和 Request，两个属性的类型都为 Size。Request 属性指出了这段渲染文本的尺寸大小（关于此类容更多的内容会在后面的章节讲到）。 下面的程序 EmpiricalFontSize 证明了这项技术。为了方便，定义了一个名叫 FontCalc 的结构体来专门针对特定的 Label（已初始化文本）、字号和文本宽度调用 GetSizeRequest 方法： struct FontCalc { public FontCalc(Label label, double fontSize, double containerWidth) : this() { // Save the font size. FontSize = fontSize; // Recalculate the Label height. label.FontSize = fontSize; SizeRequest sizeRequest = label.GetSizeRequest(containerWidth, Double.PositiveInfinity); // Save that height. TextHeight = sizeRequest.Request.Height; } public double FontSize { private set; get; } public double TextHeight { private set; get; } } 这段代码将渲染后的 Label 元素的高度存储在一个 TextHeight 属性中。 当你对一个 page 或是 layout 调用 GetSizeRequest 方法时，它们必须要获得所有包含在可视化树中的元素的尺寸大小。当然，这是有性能损失的，所以，除非有特别的必要，你应该尽量避免这样做。但是 Label 元素没有子元素，所以对 Label 调用 GetSizeRequest 方法的影响并不大。然而，你依然应该尽量尝试优化这个调用。尽量避免通过循环一列字号来找出那个不会导致文本溢出容器的最大字号值，能通过算法来找出合适的值那才更好。 GetSizeRequest 方法需要被调用的元素是可视化树的一部分，并且布局过程至少应该部分开始了。不要在 page 类的构造函数中调用 GetSizeRequest 方法，你不会从中获得任何信息。第一个可能获取到返回信息的时机是 OnAppearing 的重载方法。当然，此时你可能没有足够的信息给 GetSizeRequest 方法提供参数。 在 EmpiricalFontSizePage 类中，Label 的承载容器 ContentView 的 SizeChanged 事件处理函数中有使用 FontCalc 值的实例。（这里的事件处理函数与 EstimatedFontSize 程序相似）。每个 FontCalc 的构造函数对 Label 调用了 GetSizeRequest 方法并将结果存放在 TextHeight 中。SizeChanged 的处理函数在 10 和 100 的上下限字号之间尝试最佳值。因此变量的名称是 lowerFontCalc 和 upperFontCalc： public class EmpiricalFontSizePage : ContentPage { Label label; public EmpiricalFontSizePage() { label = new Label(); Padding = new Thickness(0, Device.OnPlatform(20, 0, 0), 0, 0); ContentView contentView = new ContentView { Content = label }; contentView.SizeChanged += OnContentViewSizeChanged; Content = contentView; } void OnContentViewSizeChanged(object sender, EventArgs args) { // Get View whose size is changing. View view = (View)sender; if (view.Width \u003c= 0 || view.Height \u003c= 0) return; label.Text = \"This is a paragraph of text displayed with \" + \"a FontSize value of ?? that is empirically \" + \"calculated in a loop within the SizeChanged \" + \"handler of the Label's container. This technique \" + \"can be tricky: You don't want to get into \" + \"an infinite loop by triggering a layout pass \" + \"with every calculation. Does it work?\"; // Calculate the height of the rendered text. FontCalc lowerFontCalc = new FontCalc(label, 10, view.Width); FontCalc upperFontCalc = new FontCalc(label, 100, view.Width); while (upperFontCalc.FontSize - lowerFontCalc.FontSize \u003e 1) { // Get the average font size of the upper and lower bounds. double fontSize = (lowerFontCalc.FontSize + upperFontCalc.FontSize) / 2; // Check the new text height against the container height. FontCalc newFontCalc = new FontCalc(label, fontSize, view.Width); if (newFontCalc.TextHeight \u003e view.Height) { upperFontCalc = newFontCalc; } else { lowerFontCalc = newFontCalc; } } // Set the final font size and the text with the embedded value. label.FontSize = lowerFontCalc.FontSize; label.Text = label.Text.Replace(\"??\", label.FontSize.ToString(\"F0\")); } } 在 while 循环的每一次迭代中，根据两个 FontCalc 值的平均值获取 Fontsize 的值并且获取一个新的 FontCalc 对象。依据渲染文本的高度用这个新对象来设置 lowerFontCalc 或者 upperFontCalc。当字体大小计算出最佳值时，循环结束。 大约七次循环之后，就能得到一个比之前那个程序估算出的值更合适的值： imgimg \" img 旋转手机就能触发另一次重算，计算出的字号跟刚才相似（虽然没必要一样）： imgimg \" img 似乎该算法通过 FontCalc 作为上下限能计算出更大平均值的字号。但是字号和渲染文本之间的高度过于复杂","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:6:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["dotnet"],"content":"在 .Net 4 中，Task.Factory.StartNew是启动一个新Task的首选方法。它有很多重载方法，使它在具体使用当中可以非常灵活，通过设置可选参数，可以传递任意状态，取消任务继续执行，甚至控制任务的调度行为。所有这些能力也带来了复杂性的提升，你必须知道何时应该使用何种重载方法，提供哪种调度方式等等。并且Task.Factory.StartNew这种写法也不够简洁明快，至少对它使用的主要场景不够快，一般它使用的主要场景只是将一个工作任务丢给一个后台线程执行而已。 于是，在 .NET Framework 4.5 开发者预览版 中，微软引进了新的Task.Run方法。新方法不是为了替代旧的Task.Factory.StartNew方法，只是提供了一种使用Task.Factory.StartNew方法的更简洁的形式，而不需要去指定那一系列参数。这是一个捷径，事实上，Task.Run的内部实现逻辑跟Task.Factory.StartNew一样，只是传递了一些默认参数。比如当你使用Task.Run： Task.Run(someAction); 实际上等价于： Task.Factory.StartNew(someAction, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default); 使用这些默认参数，Task.Run就能用于大多数情况——只是将任务简单的交给后台线程池去执行（这也是使用TaskScheduler.Default参数的目标）。这也并不意味着Task.Factory.StartNew方法就不必再使用了，它仍然有很多重要的用处。你可以通过控制TaskCreationOptions参数来控制任务的行为，你也可以通过控制TaskScheduler来控制任务应该如何排队如何运行，你也可以使用重载方法中的接受对象状态那个参数，对于一些性能敏感的代码，它可以用于避免闭包以及相应的资源分配。不过对于上面那个简单的例子，Task.Run是最友好。 Task.Run提供了八种重载方式，用于提供下面这几种组合情况： 普通任务（Task）和带返回值任务（Task\u003cTResult\u003e） 可取消任务（Cancelable）和不可取消任务（non-cancelabl） 同步委托（Synchronous）和异步委托（Asynchronous） 前两个很明显，对于第一点如果是用的Task做返回值的重载方法，那么该任务就没有返回值，如果是用的Task\u003cTResult\u003e做返回值的重载方法，那么该任务就有一个类型为TResult的返回值。对于第二点，也有接受CancellationToken参数的重载，可以在任务开始之前执行取消操作，然后并行任务（Task Parallel Library——TPL）就可以自然的过度到取消状态。 第三点要更有趣一些，它直接关系到 Visual studio 11 中的 C#和 Visual Basic 的异步语言支持。我们先使用Task.Factory.StartNew来展示下这个问题，如果有下面一段代码： var t = Task.Factory.StartNew(() =\u003e { Task inner = Task.Factory.StartNew(() =\u003e {}); return inner; }); 这里t的类型会被推断为Task\u003cTask\u003e，因为此处任务的委托类型是Func\u003cTResult\u003e，所以这里TResult的类型就是Task，于是StartNew方法就返回Task\u003cTask\u003e，类似的，我可以改变成下面这种写法： var t = Task.Factory.StartNew(() =\u003e { Task\u003cint\u003e inner = Task.Factory.StartNew(() =\u003e 42)); return inner; }); 此处的t的类型自然是Task\u003cTask\u003cint\u003e\u003e，任务的委托类型还是Func\u003cTResult\u003e，TResult的类型就是Task\u003cint\u003e，StartNew方法就返回Task\u003cTask\u003cint\u003e\u003e。这有什么关系呢？考虑下如果我们现在使用下面这种写法： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }); 这里使用了async关键词，编译器会将这个委托映射成Func\u003cTask\u003cint\u003e\u003e，调用这个委托最终会返回Task\u003cint\u003e。因为这个这个委托是Func\u003cTask\u003cint\u003e\u003e，TResult的类型就是Task\u003cint\u003e，所以最后t的类型应该是Task\u003cTask\u003cint\u003e\u003e，而不是Task\u003cint\u003e。 为了应对这几种情况，在 .Net 4 中引入了Unwrap方法。Unwrap方法有两种重载形式，均是扩展方法的形式，一种是针对类型Task\u003cTask\u003e，另一种是针对\u003cTask\u003cTResult\u003e\u003e。微软只所以要把这个方法命名为解包（Unwrap），是因为这个方法可以返回任务的实际结果。对Task\u003cTask\u003e调用Unwrap方法可以返回一个新的Task（就像内部任务的一个代理一样）代表它的内部任务。相似的，对Task\u003cTask\u003cTResult\u003e\u003e调用Unwrap返回一个新的Task\u003cTResult\u003e代表它的内部任务。但是，如果外部任务失败了或者取消了，就不会有内部任务了，因为没有任务运行完成，所以代理任务也就变成了外部任务的状态。回到前面的例子，如果想让t代表内部任务的返回值（在这个例子中，这个值是 42），那么应该像下面这样写： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }).Unwrap(); 现在，变量t的类型是Task\u003cint\u003e，代表异步调用的结果。 现在回到Task.Run，因为微软想让开发者尽可能的使用这个方法来启用后台任务，并且可以配合async/await使用，所以微软决定在Task.Run方法中内建unwrapping的功能。这也是上面第三点所指的内容，Task.Run的重载方法中有可以接受Action（没有返回值的任务）的，有接受Func\u003cTResult\u003e（返回TResult的任务）的，有接受Func\u003cTask\u003e（返回一个异步任务的任务）的，还有接受Func\u003cTask\u003cTResult\u003e\u003e（返回一个带TResult类型返回值的异步任务的任务）的。总的来说，Task.Run方法提供了上面Task.Factory.StartNew方法相同的unwrapping操作。于是，我们可以这样写： var t = Task.Run(async delegate { await Task.Delay(1000); return 42; }); t的类型是Task\u003cint\u003e，此处Task.Run执行的重载方法等价于： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default).Unwrap(); 如前所述，这是一个快捷方式。 上面讲的全部类容都意味着你可以使用Task.Run调用标准的lambdas/anonymous方法或是异步lambdas/anonymous方法，最后总会按你所期望的行为运行。如果我们想让任务在后台运行并且想等待它的结果，那么可以像下面这样写： int result = await Task.Run(async () =\u003e { await Task.Delay(1000); return 42; }); 此处变量result的类型正是你所期望的int，并且在该任务被调用大约 1 秒钟后，变量result的值被设置为 42。 有趣的是，新的await关键字被认为是等价于Unwrap方法的一种新语法形式。于是，如果我们回到上面那个Task.Factory.StartNew例子，我们可以先用Unwrap重写上面那个代码片段： int result = await Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default).Unwrap(); 或者，可以使用第二个await替换Unwrap： int result = await await Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default); 这里的await await虽然看着别扭，但是并没有问题。Task.Factory.StartNew方法返回一个Task\u003cTask\u003cint\u003e\u003e，对Task\u003cTa","date":"2016-03-05","objectID":"/task.run-vs-task.factory.startnew/:0:0","tags":["dotnet","async","translation"],"title":"Task.Run Vs Task.Factory.StartNew","uri":"/task.run-vs-task.factory.startnew/"},{"categories":["xamarin"],"content":"Xamarin 介绍 Xamarin 是一套跨平台解决方案，目的是使用 C# 语言创造原生的 iOS，Android，Mac 和 Windows 应用。 Xamarin 的三个优势： Xamarin App 拥有原生 App 的性能，因为最后生成的 App 中是使用的原生的控件和原生的 API，所以它的体验和效率与原生 App 相近。 使用熟悉的 C# 语法，在 Objective-C，Swift 或者 Java 中能做的任何事情都可以用 C# 做到。除此之外，C# 还有强大的 IDE 智能提示，lambdas 语法，更自然的异步语法（Task、Async），NuGet 快速获取组件。 在不同的平台上使用同样的语言还具有共享代码的优势，各个平台大约可以共享 75% 的 APIs 和数据结构代码。如果使用 Xamarin.Forms 来创建UI几乎可以共享 100% 的代码。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"最终的思想，共享代码 说白了，Xamarin 宣称的最大的优势就是在三个平台上使用同一种语言来共享代码，总体说来有三种技术实现： Shared Projects：可以在里面添加供三个平台公用的代码，图片和多媒体文件等，代码部分可使用#if __ANDROID__等条件编译符来指定哪一部分会编译输出到特定平台中。 Portable Class Libraries(PCLs)：使用更多的还是 PCLs，PCLs 库直接就能被各个平台所引用，一些流行的库如 SQLite，Json.NET,ReactiveUI 都支持 PCL。 Xamarin.Forms：支持你用 C# 代码来创建在三个平台上共享的 UI 界面，总共可以使用超过 40 个控件，它们都会在运行时映射为原生控件。 共享代码的关系就如下图： 共享代码的关系共享代码的关系 \" 共享代码的关系 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin 安装指南 工欲善其事，必先利其器。Xamarin的安装过程参考简书上的一篇文章，内容很齐全很详细：http://www.jianshu.com/p/c67c14b3110c 由于墙的原因，从官网下载的安装包无法直接安装，可以通过安装包中解析出配置文件，从中获取下载路径： Windows下载路径 Mac下载路径 Windows下的大体流程如下： Visual Studio 肯定是需要的，推荐 VS2013 安装 jdk，修改环境变量 安装 Android SDK，需要修改为国内镜像 安装 NDK 安装 GTK 安装 Xamarin.VisualStudio 安装 XamarinStudio（可选） 注意 6 和 7 的版本号很重要，必须要跟 Mac 端相匹配，跟破解补丁的版本也需要匹配。如果以后升级，通常只需要更新 6 和 7 就可以了。 关于 Android 模拟器，之前折腾过不少，最后推荐一款专用于游戏玩家的 Andorid 模拟器，海马玩模拟器，它的性能很好很流畅，不过游戏模拟器屏幕默认是横屏的，第一次要手动改成竖屏。 Mac 下的大体流程： 如果只考虑用 Mac 开发 iOS 程序，不考虑在 Mac 下开发 Android 程序，那么大体流程如下: 安装 MonoFramework 安装 monotouch 安装 XamarinStudio 需要注意三者之间的版本一一对应。 关于商业证书，Xamarin 的价格是很昂贵的： 价格价格 \" 价格 上面看到的价格只是针对单用户单设备平台，通常我们使用 Xamarin 都希望至少能用于 Android 和 iOS 两个平台，所以价格还得乘以 2。 安装完毕后如果没有购买商业证书，那么可以按照上面那篇文章来破解试用，如果使用的版本号在 3.11 之前，那么只需要完成离线破解，IDE 不需要登陆 Xamarin 账号，如果版本号在 3.11 之后，而且要编译 iOS（目的是为了连接 Mac 端的 BuildHost，如果是在 Mac 上开发编译 iOS 则不需要），那么还需要完成在线破解，具体破解流程文章里有，大体流程如下，最后提醒一下试用完了别忘了购买官方的商业授权。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"离线破解流程 软件读取机器特征码； 将特征码通过邮件发给破解者，等待他回复授权证书，不付费证书有效期 1 个月，付费 20 元证书有效期 10 年； 将证书和对应版本的破解文件拷贝到指定目录。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"在线破解流程 邮件申请开通在线服务 修改 host 的 IP 地址 导入 SSL 证书 登陆 Xamarin 账号 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:2","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin.Forms 程序结构 程序结构程序结构 \" 程序结构 程序的目录结构大致就可以参考这个图，最顶上一层表示三个特定平台的工程，第二层表示一个 PCL 或者 SAP 工程，通常也是 Forms 所在的工程，然后引用两个核心库 Xamarin.Forms.Core 和 Xamarin.Forms.Xaml，然后特定平台的工程还要引用两个特定平台的库，这个特定平台的库可以让程序集使用特定平台的 API。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin.Forms 官方 Demo Xamarin 提供了很多学习用的 Demo，地址是：https://developer.xamarin.com/samples-all/。不过官网的网速确实太慢，在 GitHub 上还有更多更全的 Forms 的 Demo：https://github.com/xamarin/xamarin-forms-samples。 其中我认为几个比较重要的 Demo 可以学习一下： CustomRenderers：教你怎样重写Forms里的一些原生控件的样式； Forms2Native：教你怎样从Forms页面跳转到Native页面； Native2Forms：教你怎样从Native页面跳转回Forms页面； FormsGallery：里面有几乎全部的Forms控件展示； Navigation：教你Forms的App页面导航跳转是怎么回事； UsingDependencyService：教你使用依赖服务在Forms里调用Native的方法； XamFormsImageResize：教你图片尺寸相关的东西； ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin.Forms 官方文档 Xamarin 官方提供了一套很全的在线学习指南，地址是：https://developer.xamarin.com/guides/xamarin-forms/getting-started/，这份指南目录结构良好，便于快速查看，从怎样开始第一个程序到后面怎样到商城发布一应俱全。 还有一个学习途径就是官网教材，可以免费下载离线版：https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/，教材的随书 Demo 地址：https://github.com/xamarin/xamarin-forms-book-preview-2。这本教材支持 Forms1.3 以上，并且章节一直在保持更新，截至 2016/02/25 已发布到 24 章，Demo 的核心库已更新到 2.0 并且加入了 UWP 工程。 如果说在线学习指南可以帮助你快速入门，那么这本教程可以帮助你更细化的理解 Forms 程序。 下面我将 24 章的官方教材的目录做个简单介绍，后面有时间也会对重要的几章做个更详尽的剖析： How Does Xamarin.Forms Fit In?（Forms适合什么场景） Anatomy of an App（剖析一个FormsApp） Deeper into Text（深入文本） Scrolling the Stack（滚动面板） Dealing with Sizes（处理尺寸大小） Button Clicks（按钮点击） XAML vs. Code（创建UI的两种方式） Code and XAML in Harmony（XAML和代码的协调合作） Platform-Specific API Calls（平台特定的API调用） XAML Markup Extensions（XAML扩展标记语言介绍） The Bindable Infrastructure（绑定的基础知识） Styles（样式） Bitmaps（位图） Absolute Layout（绝对布局） The Interactive Interface（交互控件） Data Binding（数据绑定） Mastering the Grid（熟练掌握Grid布局） MVVM（数据绑定开发模式Mvvm讲解） Collection Views（集合控件讲解–List） Async and File I/O（异步I/O操作文件） Transforms（变换—缩放、定位等） Animation（动画） Triggers and Behaviors（触发器和行为） Page Navigation（页面导航） 其中我感觉有几章比较重要，如果对 Xaml（WPF 主要用的界面标记语言）开发不太熟悉的同学需要看一下这几章： 7.XAML vs. Code：了解 Xaml 和 Code 两种方式来创建 UI 界面 8.Code and XAML in Harmony：了解 XAML 和后台代码如何协同工作 10.XAML Markup Extensions：了解扩展标记语言 11.The Bindable Infrastructure：了解绑定的基础知识 16.Data Binding：更深入的了解数据绑定 18.MVVM：了解基于数据绑定的 UI 开发模式 Mvvm 要对Forms的细节有深入理解看下面几章： 3.Deeper into Text：深入理解文本 5.Dealing with Sizes：深入理解如何处理尺寸大小，重点也是拿文本举例，教你如何理解移动开发里面像素、物理尺寸（英尺、厘米）、DPI、DIU，主要思想反正就是不要去关注表示大小的那些数值，字体应该使用字体枚举，布局应该是用比例去控制，要充分相信 Xamarin 平台能帮你控制好大小尺寸。 13.Bitmaps：了解怎样在 Forms 中使用图片，也是满满的都是坑，显示在界面上的图片体积一定要尽量的小，不要将一张原始尺寸的图片加载成缩略图然后放在列表中显示，否则程序一定会内存溢出，一定要对图片进行裁剪，将适合的体积的图片用在适合的地方。从这一章中还可以学习图片在具体平台下的用法和差异等。 19.Collection Views：了解集合控件，列表在 App 当中用得非常普遍，所以应当着重了解。 Async and File I/O：在 Xamarin 中只能使用异步 IO（或者说是 PCL 中只能使用异步IO），从趋势看未来的 .Net Core 可能也只支持异步 IO、异步 Http 请求等，感觉这种更重视性能的 IO 思想是未来框架的趋势，所以可以借此熟悉一下，C# 的异步语法应该算是众多编程语言中的佼佼者了。 下面对第五章 Dealing with Sizes 稍作讲解，这章重点介绍了移动平台下尺寸相关的一些知识，先看下下面两个表格： 型号 iPhone 2，3 iPhone 4 iPhone 5 iPhone 6 iPhone 6 Plus 像素尺寸 320x480 640x960 640x1136 750x1134 1080x1920 屏幕尺寸 3.5英寸 3.5英寸 4英寸 4.7英寸 5.5英寸 像素密度 165 DPI 330 DPI 326 DPI 326 DPI 401 DPI 单位点包含像素数量 1 2 2 2 3 点数尺寸 320x480 320x480 320x568 375x667 414x736 每英寸包含点数量 165 165 163 163 154 屏幕类型 WVGA WXGA 720P 1080P 像素尺寸 480x800 768x1280 720x1280 1080x1920 缩放比例 1 1.6 1.5 2.25 DIUs尺寸 480x800 480x800 480x853 480x853 第一张图是 iPhone 下的一些尺寸元素间的关系，第二张是 WinPhone 的，这里没有给出 Android 的，其实 Android 整体上说来跟 iPhone 的那些参数很相似。 Forms 中真正使用的不是像素，而是点数，点里面包含的像素数量是不一致的，像 iPhone2，3 基本上是一一对应，一个点包含一个像素，iPhone4，5，6 就是两倍像素，iPhone6Plus 就是三倍像素，所以 iPhone 的图片里出现 @2x，@3x 这些标识就是对应平台所使用的像素不同的图片。我们在 Forms 中使用的那些表示宽高的值就是这种点数单位，要知道设置的这些值可以获取整个页面的 Width 和 Height 值。 下面说下字号，Forms 提供了几种枚举字号：Default，Micro，Small，Medium，Large，在不同的设备，不同的用户系统字号设置，不同的控件中，相同的枚举返回的字号数值可能都不一样。通过 Device.GetNamedSize 方法获取的 FontSize 值的单位是 double，表示文本字符从最下面到最上面到高度，字体的宽度一般都是 FontSize 值的一半，字体的行距一般是 FontSize 值的 1.2 倍。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Forms 中 UI 布局细节 在 Forms 中设计各种元素布局等细节依然可以参考设计网页采用的盒模型的思想。从大的块元素的分离到小如一个文字，都可以想象成一个个小盒子。由内容区，内边距，边框，外边距组成。 UIUI \" UI Forms 中还有几个比较容易混淆的类：ContentView，Frame，BoxView。 虽然可以按照盒模型的思想来布局元素，但是 Forms 中没有标准的 margin 的概念，Forms 的做法是在一个内容视图外面再嵌套一个 ContentView，ContentView 继承自 Layout，只多了一个 Content 属性来存放内容视图。此时，ContentView 的 Padding 属性就可以想象成盒子的 Margin。 Frame 在布局中也比较常用，通常用于定义页面中一组视图的区块，它继承自 ContentView，多了些边框、阴影等属性。 BoxView 是一个矩形填充区，在 Forms 中用得最多的地方就是用它来绘制横线、竖线等分割线。虽然看起来很山寨，但它却是是 Forms 中的一个标准用法。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"APP 的发布 前面教程重点是介绍 Xamarin.Forms 相关的东西，对于平台特定的那些没有做介绍，比如平台和 Forms 之间的交互（依赖注入，前面的 Demo 介绍 PPT 有），比如最后 APP 的发布，发布相关的东西参考前面提到的在线教程： ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Android 发布教程 我们项目中的 Android 安装包没有发布进商城，是通过网址直接下载，所以发布教程没有验证：https://developer.xamarin.com/guides/android/deployment,_testing,_and_metrics/publishing_an_application/ ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"iOS 发布教程 iOS 需要发布，流程主要是有很多和 apple 打交道的地方比较麻烦，比如说开发者证书，AppStore 证书，用特定的证书打包你的 IPA，提交到 itunesconnect，审核等等，Xamarin 的教程如下：https://developer.xamarin.com/guides/ios/deployment,_testing,_and_metrics/app_distribution/ ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:2","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin 组件商店的使用 Xamarin 有自己的组件商店，里面有很多免费和收费的组件，刚开始就在这上面找东西，不过网速实在不可恭维，后来发现免费插件这上面有的 GitHub 上几乎都有，所以使用 GitHub 又快又方便。 如果要在组件商店中下载需要注意最后一步需要翻墙，因为网站用了 google 提供的 jquery 库：https://components.xamarin.com/ GitHub 上 Xamarin 提供的一个常用的免费插件目录，这个插件库里有 Xamarin 官方的也有第三方的。我们的项目所使用的插件大多来自这个目录，里面有插件的 NuGet 和 GitHub 地址： https://github.com/xamarin/plugins GitHub 上 Xamarin 官方插件库的源代码：https://github.com/jamesmontemagno/Xamarin.Plugins ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"GitHub 上去找东西 在 GitHub 上使用“Xamarin.Forms”为关键词进行搜索，可以快速找到相关资源。 Xamarin-Forms-Labs：这个库很大，包含的东西很多，IOC 容器、序列化组件、缓存组件、UI控件等，我们用得最多的还是 UI 控件。但是用法不是像其他插件一样直接引用它的相关 dll（之前尝试过很久，直接使用会导致莫名其妙的问题），而是直接拷贝代码到我们项目中直接用，但是这个库也正如它的名字一样，是实验性的，在 GitHub 介绍上也可以看到可用控件里几乎所有控件都是 beta 状态，我们在使用过程中也发现了不少 Bug，所以项目里的代码有所改动，跟以前应该不太一样了。我们项目里参考并使用的控件有Checkbox、RadioButton等。 XamarinFormsGestureRecognizers：这个没有使用过，从说明来看是一个手势功能相关的库。 XamarinForms 里的控件默认只有 Tap 点击事件，其他手势操作都在平台内部，这个库就是教你怎样将它们连接起来，然后在 PCL 中写针对控件的手势操作代码。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"IDE技巧 Android 很简单，在 Windows 上启动海马玩模拟器，模拟器启动时间比较长，但启动好之后就可以不用关了，然后只需要用 Visual Studio 设置 Android 项目为启动项，附加到模拟器进行调试即可；真机用 USB 连接使用同样的方式在 IDE 里调试。 iOS 比较麻烦，需要打开 Mac 电脑上的 BuildHost（如果 Mac 不在身边，可使用远程软件 tightvnc 操作，不过一台 Mac 同时只能供一人使用），然后 Visual Studio 设置 iOS 为启动项，可自动寻找局域网内的 Mac 电脑上的 BuildHost，然后输入配对码即可连接成功，如果失败请重启 BuildHost 再试；真机调试一样，不过真机只能连接在 Mac 电脑上。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"一些常用插件 Forms 中插件的使用也比较简单，基本上用一次就会了。首先，插件的使用方式都很统一，Forms 的 PCL 中一般引用两个库,两个库都是 PCL 的，一个带 Abstractions 后缀，里面只定义了接口和实体，不包含逻辑代码；另一个不带 Abstractions 后缀，就像工厂一样，只负责创建 Abstractions 程序集里定义的那些接口的实现者，创建的方式不是使用前面提到的 Xamarin 提供的依赖注入（ UsingDependencyService ），而是条件编译的方式直接 New 对应平台的实现者。在 Andorid 和 iOS（或者 WP）里引用了带 Abstractions 后缀的程序集，然后引用一个真正的属于该平台的程序集（非 PCL，可以调用平台特殊 API），这个程序集实现了 Abstractions 程序集里的接口，它的实例化对象在运行时被真正使用。如果我们自己写插件就可以使用 Xamarin 提供的依赖注入的方式，在特定平台内部写好功能类，然后在 PCL 中直接导出就可以使用了。 然后下面列出一些常用插件： Corcav.Behaviors：帮助你将列表的每一项绑定命令到这个列表的 BindingContext，而不是具体项的 BindingContext，帮助将事件转为命令，Xamarin 自身不带这个功能。 EZ-Compress-for-Xamarin ：压缩图片流的库。 MvvmLight：Mvvm 开发模式的支持库，还用到了里面的 Ioc 容器（SimpleIoc，我们系统里有两套 Ioc 容器，一个就是这个，另一个是 Xamarin 的依赖注入容器）；还用到了它提供的导航组件。 Xam.Plugins.Messaging：提供打电话、发短信、发 Email 等功能。 Media.Plugin：提供拍照、选照片的功能。 PCLStorage ：跨平台的异步 I/O 库。 Vibrate：提供了手机震动的功能。 Toasts.Forms.Plugin ：顶部的那个彩色浮动提示框。 然后一些用得比较多的 UI 组件有：圆形图片、Checkbox、RadioButton、图片选择器等，有自己写的，也有在Xamarin-Forms-Labs的基础上改的。 Andorid 使用插件时注意在工程的 Properties 的 AndroidManifest.xml 中写入对应的权限。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin 官方论坛 遇到疑难的问题，上 Xamarin 官方论坛搜索，大部分你遇到的问题上面应该都会有，基本用不着主动提问，这个地址我认为访问频率相当高，地址如下：http://forums.xamarin.com/ ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"没有涉及到的东西 本教程没有涉及到 GIS 相关的内容。 没有对特定平台内部相关知识介绍，我们团队的成员对平台特定API都了解太少，特别是涉及 UI 方面的，要掌握这些知识的难度跟学习原生开发无异，所以对一些难题解决起来比较费力，比如之前的 Android 和 iOS 的 Tab 页样式差异问题（Android 的 Tab 在屏幕上面，iOS 的 Tab 在屏幕底部）。因为 Tab 属于页面，跟控件不一样，不能使用 CustomRenderers 的技术重写样式，在论坛上搜索的结果如下： http://forums.xamarin.com/discussion/54668/bottom-tab-bar-menu-for-android https://forums.xamarin.com/discussion/10004/tabs-on-the-bottom-for-android-example-code http://forums.xamarin.com/discussion/56320/is-there-any-way-to-show-tabs-on-bottom-in-android-using-tabbedpagerenderer 主要意思先是从设计的角度强调不要进行这样通用的设计，如果一定是通用样式那么给出的解决方案也是平台内部的，首先不说技术门槛，这个实现方式跟 Forms 的思想就是有冲突的，所以最好的方案就是在新 APP 里用 Forms 纯手写 Tab 页面。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"资源汇总 官方Demo： https://developer.xamarin.com/samples-all/ https://github.com/xamarin/xamarin-forms-samples 官方程序安装地址： https://static.xamarin.com/installer_assets/v3/Windows/Universal/InstallationManifest.xml https://static.xamarin.com/installer_assets/v3/Mac/Universal/InstallationManifest.xml windows下的ios模拟器 最新的版本信息查询地址： https://developer.xamarin.com/releases/current/ 一个博客提供的最新下载地址： https://www.coderbusy.com/archives/256.html?from=groupmessage\u0026isappinstalled=0 可根据以上版本号手动构造下载地址如下： Win: http://dl.google.com/android/ndk/android-ndk-r10e-windows-x86_64.exe http://dl.google.com/android/installer_r24.4.1-windows.exe http://download.xamarin.com/GTKforWindows/Windows/gtk-sharp-2.12.30.msi https://dl.xamarin.com/XamarinforVisualStudio/Windows/Xamarin.VisualStudio_4.2.1.58.msi http://download.xamarin.com/studio/Windows/XamarinStudio-5.10.3.26-0.msi Mac: http://download.xamarin.com/Installer/MonoForAndroid/jdk-7u71-macosx-x64.dmg http://dl.google.com/android/android-sdk_r24.4.1-macosx.zip http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin http://dl.xamarin.com/MonoFrameworkMDK/Macx86/MonoFramework-MDK-4.6.2.7.macos10.xamarin.universal.pkg https://dl.xamarin.com/MonoDevelop/Mac/XamarinStudio-6.1.2.44.dmg https://dl.xamarin.com/MonoTouch/Mac/xamarin.ios-10.2.1.5.pkg http://dl.xamarin.com/MonoforAndroid/Mac/xamarin.android-7.0.2-37.pkg http://dl.xamarin.com/XamarinforMac/Mac/xamarin.mac-2.10.0.113.pkg 官方文档： https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/ 官方教材： https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/ https://github.com/xamarin/xamarin-forms-book-samples/ 官方论坛： http://forums.xamarin.com/ 常用插件： https://github.com/xamarin/plugins https://github.com/jamesmontemagno/Xamarin.Plugins https://components.xamarin.com/ https://github.com/XLabs/Xamarin-Forms-Labs MvvmCross https://github.com/MvvmCross/MvvmCross https://github.com/MvvmCross/MvvmCross-Plugins ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["dotnet"],"content":"Log4net 先说 Log4net，它是.net 平台上一个老牌的日志框架，我接触的时间也不长(因为公司有自己的日志库)，但是看着各开源库都在用这个于是前段时间也尝试去了解了一下。 首先让我认识到 Log4net 强大的地方就是它的多目标输出，可以输出到控制台、文件、数据库、系统事件、Email 等，几乎无所不能。然后它可以通过配置让日志系统实时生效，比如说在服务运行的过程中修改配置改变输出目标，改变日志等级等，均不用重启程序。但是 Log4net 也有一个让我比较头痛的地方就是感觉配置过于复杂，根本记不住，每次都必须去查阅资料，于是乎之前我也针对 Log4net 做了一个简单的封装，内嵌了一个默认使用文件存储的日志配置，提供静态日志方法，还提供一套性能统计的 API(貌似 Visual Studio 2015 后 IDE 已自带了)。以下是这个封装的源代码地址：github，nuget 地址：nuget。 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:1:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"NLog 下面说说为什么又关注起 NLog 了，Nlog 没有 Log4net 老牌，使用从 Nuget 下载量来看也没有 Log4net 用户量大，但是它却一直在保持高速的更新状态，从 github 主页上看它所支持的平台也相当广泛，从.net 环境到 mono 再到现在最新的 Xamarin 均支持： nlog支持范围nlog支持范围 \" nlog支持范围 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:2:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"比较 下面这个是一篇比较这两种日志的文章，应该是翻译的 StackOverFlow 再加上作者自己的一些见解: http://www.cnblogs.com/wanglee/archive/2013/05/22/3092474.html。 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:3:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"下面是总结的几点 项目 log4net nlog 流行程度 胜 负 易用性 负 胜 动态配置 平 平 输出目标 平 平 跨平台 负 胜 开源持续维护 负 胜 日志性能 负 胜 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:3:1","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"性能比较（不再有效，详见文末） 这是用这两款日志框架写的一个性能比较的 Demo，暂时只比较了文件记录日志的情况(因为相对来说这种情况应该是最多的)，附上源码地址。 性能比较结果如图，分别是 Debug 条件编译下的单线程和并行多线程以及独占锁和最小冲突锁的情况： 性能比较结果性能比较结果 \" 性能比较结果 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:3:2","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"2017 年 9 月 1 日更新 以上性能测试不再有效，根据网友反馈，由于输出内容的略有差异导致上面性能测试出现不公平的情况，log4Net 在输出时可能会有更多的计算量。在优化测试代码情况下，仅让日志框架打印日志内容，其余的包括时间、日志等级、日志类名一律不打印，使用最新版 Dll，两个框架性能相差无几。 推荐阅读： NET 开源项目介绍及资源推荐：http://www.cnblogs.com/Terrylee/archive/2006/12/03/opensource_framework_and_resource_recommendation_Log.html 附加链接： log4net：https://logging.apache.org/log4net/ NLog：https://github.com/NLog/NLog ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:4:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["xamarin"],"content":"安装 使用标准安装流程(JDK1.6 -\u003e Android SDK -\u003e NDK -\u003e Xamarin Studio -\u003e Xamarin Visual Studio) Android SDK Manager 更改源，可时刻保持最新，一个镜像源地址：mirrors.neusoft.edu.cn；ubuntu.buct.cn；Port: 80，Android SDK的目录结构介绍，Android的一些相关资源 http://ubuntu.buct.edu.cn/android/repository/。 Windows 端破解流程两步：替换 IDE 的 Dll，两个位置，一个是 VS 的 Common 下，一个 Xamarin Studio 的 bin 下；替换对应版本的 mandroid.exe 和 mtouch.exe Mac 端破解流程，Mac 端只负责 iOS 相关的东西，不考虑在 Mac 端开发 Android，首先要安装的东西包括：MonoFramework-MDK-3.12.1.3.macos10.xamarin.x86.pkg； monotouch-8.8.2.4.pkg ；XamarinStudio-5.8.2.7-0.dmg；(版本号注意要匹配，现在这一系列的版本号匹配的是 Windows 端的 3.9.525) 装完之后主要要替换三个东西：/Developer/MonoTouch/usr/bin/mtouch-64； Mtouch-64 替换完毕后需要在终端执行命令：chmod a+x /Developer/MonoTouch/usr/bin/mtouch-64 然后替换/Applications/Xamarin Studio.app/Contents/Resources/lib/monodevelop/AddIns/Xamarin.Ide/Xamarin.Components.Ide.dll 最后替换 /Applications/Xamarin.iOS Build Host.app/Contents/MonoBundle/Xamarin.Components.Ide.dll ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"模拟器 可以不使用 android 的标准模拟器，使用 Xamarin Android Player，据说性能要好一些，但是版权原因还没测试。 如果使用标准模拟器，可配置硬件加速 首先，你的 CPU 必须支持 Intel 虚拟化技术，如果支持进 BIOS 打开 使用 Android SDK 下载对应的 x86架构的系统镜像 android sdkandroid sdk \" android sdk 上Intel官网下载最新的HAXM虚拟引擎，或者直接用SDK下载 internel haxminternel haxm \" internel haxm 下载后需要手动安装，如果双击安装无效，使用管理员权限运行 CMD，执行安装目录下的那个 Bat 文件；如果提示不支持 Intel 虚拟化技术，但是我们确认是打开了的，可能是因为操作系统装了 Hyper 的原因，卸载 Hyper 重启再试一次 进 AVD 创建基于 X86 的虚拟机 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"安卓引用的文件结构 android tocandroid toc \" android toc 文件夹 作用 Components 登录 Xamarin 账户可下载它官方提供的一些组件直接使用 Assets 存放字体、本地数据库、配置文件等一系列本地资源 Properties 除了常规的程序集版本号等信息，含包括 Android 程序的权限描述文件AndroidManifest.xml Resources 包好 Strings，images，layout 等资源的文件夹，注意程序的视图界面也在该文件夹下，还包括一个 AboutResources.txt 资源描述文件 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"安卓应用的逻辑结构 安卓应用跟传统应用不一样，没有单点入口，应用和安卓操作系统紧密联系，操作系统可以随时将应用进程载入内存激活应用。因此应用中有一个 Activity 的概念，一个应用由很多 Activity 组成。 android logic structandroid logic struct \" android logic struct Activity 的特性： Activity的特性Activity的特性 \" Activity的特性 Label：告诉操作系统这个类属于哪个程序，它会去 AndroidManifest.xml 里去匹配。 MainLauncher：告诉操作系统打开程序后激活哪个页面。 Activity的生命周期：created, started and paused, resumed and destroyed, and so on。 通过重写基类的生命周期方法来实现自己的逻辑，如：OnCreate（应用程序被装载到内存中时调一次），OnResume（设备执行别的任务后，该 Activity 返回设备界面时触发），OnPause（设备将执行其他任务，该 Activity 离开设备界面时触发） 生命周期生命周期 \" 生命周期 生命周期生命周期 \" 生命周期 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"Xamarin.Forms相关 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"简介 可以跨平台的构建用户交互相关的东西，简而言之就是写一套代码三个平台通用，在此基础上也能够结合各平台特有的 Xamarin 本地代码混合一起。 Forms 除了跨平台的好处意外，还支持 Xaml 编写用户界面，不用借助 Goft.Mvvm.light 等第三方框架原生支持数据绑定等。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:1","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"使用前置条件 Android4.0 以上； IOS6.1 以上； 开发环境 VS2013； 解决方案必须是 .Net4.5 以上，PCL 模板，Vs2013update2 可使用 SharedProject。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:2","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"适用程序 适用程序适用程序 \" 适用程序 Xamarin.Forms Xamarin.iOS \u0026 Xamarin.Android 以单纯数据展示为主 程序会用到特殊的交互 快速原型、概念类程序 界面 UI 经过精心设计的程序 只会用到很少的平台特殊功能(API) 会用到很多的平台特殊功能(API) 共享代码比用户UI更加重要 用户UI比共享代码更加重要 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:3","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"Xaml相关 Forms 要针对各个平台做界面微调时 OnPlatForm OnPlatFormOnPlatForm \" OnPlatForm ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:4","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"FormsFQA 第一次运行 Forms 程序会提示“无法链接到远程服务器” Verify the project is selected to be deployed in the Solution Configuration Manager. ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:5","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"Mvvm相关 三套框架：MvvmCross、MvvmLight、XamarinFormsLab http://blog.galasoft.ch/posts/2014/05/mvvm-light-v4-4-with-xamarin-android-support/?utm_source=tuicool MvvmLight For Android要求Android版本在2.3(API10)以上 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:6","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"FQA 一个纠缠很久的问题，Android 设计界面中 Layout 无法加载，报什么网络错误，原因为 Android SDK 升级了最新的 Tools 到 24.3，最新版的 SDK 会引起 Xamarin 出现这个错误，如果使用最新的 Xamarin 则已修复这个错误，如果不想更新 Xamarin 则需要进行 SDK 降级操作 errorerror \" error 限制屏幕旋转功能，指定程序只能使用竖屏或横屏，参考《Xamarin Forms Preview Edition 2》第五章，88(PDF 101)页。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:7","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"其他资源 安装、破解：http://www.jianshu.com/p/c67c14b3110c ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:8","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"}]