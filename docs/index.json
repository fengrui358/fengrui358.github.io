[{"categories":null,"content":"  free 笔记 是一个简洁、优雅且高效的 Hugo 博客网站。 路的尽头是风景free 笔记 \" 路的尽头是风景 ","date":"2019-08-04","objectID":"/about/:0:0","tags":null,"title":"关于 free 笔记","uri":"/about/"},{"categories":null,"content":"介绍  笔记主人：奉锐  坐标：成都  邮箱 qjdev@qq.com  微信 feng_rui  主要领域为前端技术，后端技术略懂，欢迎探讨研究。 ","date":"2019-08-04","objectID":"/about/:0:1","tags":null,"title":"关于 free 笔记","uri":"/about/"},{"categories":["dotnet"],"content":"安装 CentOs，可使用最小安装包镜像 http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1708.iso ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:1:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"跟随安装步骤进行，中途要选择磁盘 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:2:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"设置 Root 用户密码 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:3:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装完毕后重启，进入系统，CentOs 最小版缺少一些必要组件，首先要打开网卡设置，用vi编辑 vi /etc/sysconfig/network-scripts/ifcfg-ens33 编辑最后一行，将 ONBOOT=no 改为 ONBOOT=yes :wq 保存并退出 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:4:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"重启网卡 service network restart 然后Ping一下百度，应该 OK 了 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:5:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装 ipconfig 等网络工具 中途需要输入 y 确认几次：sudo yum install net-tools ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:6:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"使用 ifconfig 查看本机 IP ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:7:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"下载 Putty 使用IP地址可进行远程连接： ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:8:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装 Nginx 参考教材https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7 安装 Nginx：sudo yum install epel-release; sudo yum install nginx 启动 Nginx：sudo systemctl start nginx 打开防火墙：sudo firewall-cmd --permanent --zone=public --add-service=http; sudo firewall-cmd --permanent --zone=public --add-service=https 重新加载防火墙：sudo firewall-cmd --reload ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:9:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"现在可以使用命令在Web浏览器访问Nginx了 http://server_domain_name_or_IP/ ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:10:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装 .Net Core 环境 https://www.microsoft.com/net/download/linux-package-manager/centos/sdk-current sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc sudo sh -c 'echo -e \"[packages-microsoft-com-prod]\\nname=packages-microsoft-com-prod \\nbaseurl= https://packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\" \u003e /etc/yum.repos.d/dotnetdev.repo' sudo yum update sudo yum install libunwind libicu sudo yum install dotnet-sdk-2.1.4 至此，可输入 dotnet --version 查看 .NetCore 已安装成功。 参考： http://video.jessetalk.cn/course/4/task/6/show http://video.jessetalk.cn/course/4/task/7/show ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:11:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["wpf"],"content":"在 WPF 中使用动画的情况非常多，而要让动画变得生动往往要使用一些变速动画，WPF 也内置了很方便的缓动函数来实现这一功能。 除此之外，WPF 还有关键帧动画，利用关键帧动画能够很好的控制动画的细节，与美工的很多设计保持完美一致。关键帧动画中还有一套叫做样条关键帧动画（SplineKeyFrame），这个动画利用一个三次贝塞尔曲线能够更准确的控制动画的速率。 不同的缓动函数光看名字很难知道实际效果，样条关键帧动画的贝塞尔曲线控制也很难直观的看到效果，于是写了个小工具来展现不同的动画速率的效果以及修改配置对速率的影响，下面是工具的运行效果。 工具代码下载地址：https://github.com/fengrui358/WPFLabs/tree/master/EasingFunctionDemo 三次贝塞尔曲线控制参考：https://www.cnblogs.com/hnfxs/p/3148483.html ","date":"2017-12-04","objectID":"/wpf-%E5%8A%A8%E7%94%BB%E9%80%9F%E7%8E%87%E6%95%88%E6%9E%9C/:0:0","tags":["dotnet","wpf"],"title":"WPF 动画速率效果","uri":"/wpf-%E5%8A%A8%E7%94%BB%E9%80%9F%E7%8E%87%E6%95%88%E6%9E%9C/"},{"categories":["ui"],"content":" 正三角形(左)：\u003cPath Data=“M40,0 L0,30 40,60 z” Stretch=“Uniform”/\u003e 正三角形(上)：\u003cPath Data=“M0,40 L30,0 60,40 z” Stretch=“Uniform”/\u003e 正三角形(右)：\u003cPath Data=“M0,0 L40,30 0,60 z” Stretch=“Uniform”/\u003e 正三角形(下)：\u003cPath Data=“M0,0 L30,40 60,0 z” Stretch=“Uniform”/\u003e 矩形：\u003cPath Data=“M0,0 L1,0 L1,1 L0,1 z” Stretch=“Uniform”/\u003e 圆形：\u003cPath Data=“M100,50 C100,77.614237 77.614237,100 50,100 C22.385763,100 0,77.614237 0,50 C0,22.385763 22.385763,0 50,0 C77.614237,0 100,22.385763 100,50 z” Stretch=“Uniform”/\u003e 箭头(左)：\u003cPath Data=“M40,0 L0,30 40,60” Stretch=“Uniform”/\u003e 箭头(上)：\u003cPath Data=“M0,40 L30,0 60,40” Stretch=“Uniform”/\u003e 箭头(右)：\u003cPath Data=“M0,0 L40,30 0,60” Stretch=“Uniform”/\u003e 箭头(下)：\u003cPath Data=“M0,0 L30,40 60,0” Stretch=“Uniform”/\u003e Stretch 默认使用 Uniform，在这种参数下矩形为正方形、圆形为正圆形，如果修改 Stretch 为 Fill，则根据容器高宽进行自由拉伸。 ","date":"2017-07-22","objectID":"/%E5%B8%B8%E7%94%A8-path-%E8%B7%AF%E5%BE%84/:0:0","tags":["ui","wpf"],"title":"常用 Path 路径","uri":"/%E5%B8%B8%E7%94%A8-path-%E8%B7%AF%E5%BE%84/"},{"categories":["dotnet"],"content":"如果在一个类中定义了虚属性或者虚方法，又在构造函数中访问了这个虚属性或方法，此时 VisualStudio 是不会给出警告，并且编译也没有问题，但是如果安装了 Resharper 插件则会给出警告提示：“在构造函数中访问了虚成员”，那么，这为何是一个安全隐患，下面给出一个例子说明： using System; namespace VirtualDemo { class Program { static void Main(string[] args) { var test = new SubClass(); Console.ReadKey(); } } class BaseClass { protected virtual string VirtualProperty { get; set; } public BaseClass() { var p = VirtualProperty; VirtualMethod(); } protected virtual void VirtualMethod() { } } class SubClass : BaseClass { private MockClass _mockClass; public SubClass() { _mockClass = new MockClass(); } protected override string VirtualProperty { get { return _mockClass.MockProperty; } set { _mockClass.MockProperty = value; } } protected override void VirtualMethod() { var p = _mockClass.MockProperty; } } class MockClass { public string MockProperty { get; set; } } } 该示例很简单，在构造 SubClass 时出现了空引用报错，因为基类构造函数先于子类构造函数运行，而子类构造函数中初始化了一个成员类，但是基类构造函数访问虚成员时子类还没构造，所以出现了空引用报错。有多种方式可以避免这一情况，可以通过子类字段初始化的方式来构造成员类，这个语法糖可避免构造函数的时序问题，第二个是可定义一个虚的 Initialize 方法在子类构造函数第一步调用，子类在继承这个方法时初始化需要的依赖。 ","date":"2017-06-03","objectID":"/csharp%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%AE%BF%E9%97%AE%E8%99%9A%E6%88%90%E5%91%98/:0:0","tags":["dotnet"],"title":"C# 为何不推荐在构造函数中访问虚成员","uri":"/csharp%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%AE%BF%E9%97%AE%E8%99%9A%E6%88%90%E5%91%98/"},{"categories":["wpf"],"content":"在 WPF 的集合控件中常常需要在每一个集合项之间插入一个分隔符样式，但是 WPF 的 ItemsControl 没有相关功能的直接实现，所以只能考虑曲线救国，经过研究，大概想到了以下两种实现方式。 先写出 ItemsControl 的数据模板，如下： \u003cItemsControl ItemsSource=\"{Binding Source}\" BorderThickness=\"1\" BorderBrush=\"Blue\" VerticalAlignment=\"Stretch\"\u003e \u003cItemsControl.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"Auto\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003cBorder Name=\"Bd\" Grid.Row=\"0\" Height=\"1\" Background=\"Red\" /\u003e \u003cTextBlock Grid.Row=\"1\" Text=\"{Binding}\" /\u003e \u003c/Grid\u003e \u003c/DataTemplate\u003e \u003c/ItemsControl.ItemTemplate\u003e \u003c/ItemsControl\u003e 其中名为 Bd 的 Border 就是分隔符，此时每一项的头部都可以看见分隔符，现在我们的目标是要隐藏掉第一项的分隔符，这就达到了项与项之间才有分隔符的目的。 第一种实现方式最简单，使用集合项前向绑定 PreviousData，这是四种绑定方式中的一种，估计也是平时用得最少的一种，不过此时就派上用场了，代码如下： \u003cDataTemplate.Triggers\u003e \u003cDataTrigger Binding=\"{Binding RelativeSource={RelativeSource PreviousData}}\" Value=\"{x:Null}\"\u003e \u003cSetter TargetName=\"Bd\" Property=\"Visibility\" Value=\"Collapsed\" /\u003e \u003c/DataTrigger\u003e \u003c/DataTemplate.Triggers\u003e 当某一项的前项为空时就隐藏分隔符，简单的一行代码搞定。不过这种实现方式有个缺点就是如果使用的是 Insert 方式向绑定的数据源的最前面添加数据则就会出现不止一个没有分隔符的项，如果是往队尾或者队中添加则不会出现这个问题。 第二种实现方式是借助 ItemsControl 的 AlternationCount 和 AlternationIndex 属性来为集合项标记索引号，再隐藏索引号为 0 的项的分隔符，代码如下： \u003cItemsControl ItemsSource=\"{Binding Source}\" BorderThickness=\"1\" BorderBrush=\"Blue\" VerticalAlignment=\"Stretch\" AlternationCount=\"{Binding Source.Count}\"\u003e 首先在 ItemsControl 上绑定 AlternationCount 到数据源的 Count 属性上，然后此时 ItemsControl 的 AlternationIndex 属性就变成的该集合数据源的索引号了，在触发器中写上逻辑即可： \u003cBorder Name=\"Bd\" Grid.Row=\"0\" Height=\"1\" Background=\"Red\"\u003e \u003cBorder.Style\u003e \u003cStyle TargetType=\"{x:Type Border}\"\u003e \u003cStyle.Triggers\u003e \u003cDataTrigger Binding=\"{Binding Path=(ItemsControl.AlternationIndex), RelativeSource={RelativeSource AncestorType={x:Type ContentPresenter}}}\" Value=\"0\"\u003e \u003cSetter Property=\"Visibility\" Value=\"Collapsed\" /\u003e \u003c/DataTrigger\u003e \u003c/Style.Triggers\u003e \u003c/Style\u003e \u003c/Border.Style\u003e \u003c/Border\u003e 触发器判定当索引号为0时就隐藏 Border，这种方式代码量也不大，优点是能绝对实现这个功能，无论向队首插入还是队尾插入，但是 AlternationCount 和 AlternationIndex 属性本来的含义是用来实现比如隔行变色等功能，此时这种功能被占用，所以如果你的集合要同时实现分隔符和隔行样式的功能可能需要额外加转换器，不过转换器内容也很简单，求个余数就能还原之前的功能了。 （2017 年 4 月 15 日补充） 经过网友 vbfool 提示，补充第三种方式，按照第二种思路自定义附加属性，这样就不用占用原生 ItemsControl 的属性了。并且可以用附加属性标记出所有的索引号，供其他场景使用。 先自定义一个 MarkIndex 属性用于标记 ItemsControl，如果这个属性被设为 True 再在代码逻辑中去订阅数据项的变更，然后向 ItemContainer 中设置一个 ItemIndex 附加属性，标记出索引号。 定义的依赖属性如下： #region MarkIndex public static readonly DependencyProperty MarkIndexProperty = DependencyProperty.RegisterAttached( \"MarkIndex\", typeof(bool), typeof(ItemsControlHelper), new PropertyMetadata(default(bool), OnMarkIndexPropertyChanged)); public static bool GetMarkIndex(DependencyObject obj) { return (bool)obj.GetValue(MarkIndexProperty); } public static void SetMarkIndex(DependencyObject obj, bool value) { obj.SetValue(MarkIndexProperty, value); } private static void OnMarkIndexPropertyChanged(DependencyObject dependencyObject, DependencyPropertyChangedEventArgs args) { if ((bool)args.NewValue) { var itemsControl = dependencyObject as ItemsControl; if (itemsControl != null) { itemsControl.ItemContainerGenerator.StatusChanged -= ItemContainerGeneratorOnStatusChanged; itemsControl.ItemContainerGenerator.ItemsChanged -= ItemContainerGeneratorOnItemsChanged; itemsControl.ItemContainerGenerator.StatusChanged += ItemContainerGeneratorOnStatusChanged; itemsControl.ItemContainerGenerator.ItemsChanged += ItemContainerGeneratorOnItemsChanged; } } else { var itemsControl = dependencyObject as ItemsControl; if (itemsControl != null) { itemsControl.ItemContainerGenerator.StatusChanged -= ItemContainerGeneratorOnStatusChanged; itemsControl.ItemContainerGenerator.ItemsChanged -= ItemContainerGeneratorOnItemsChanged; } } } private static void ItemContainerGeneratorOnItemsChanged(object sender, ItemsChangedEventArgs itemsChangedEventArgs) { var itemContainerGenerator = (ItemContainerGenerator)sender; if (itemContainerGenerator.Status == GeneratorStatus.ContainersGenerated) { for (int i = 0; i \u003c itemContainerGenerator.Items.Count; i++) { var dp = itemContainerGenerator.ContainerFromIndex(i); if (dp != null) {","date":"2017-04-10","objectID":"/wpf-%E9%9B%86%E5%90%88%E6%8E%A7%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E9%9A%94%E7%AC%A6itemscontrol-separator/:0:0","tags":["dotnet","wpf"],"title":"WPF 集合控件实现分隔符（ItemsControl Separator）","uri":"/wpf-%E9%9B%86%E5%90%88%E6%8E%A7%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E9%9A%94%E7%AC%A6itemscontrol-separator/"},{"categories":["deploy"],"content":"步骤如下 创建AWS账号，可获得一年期限的限制条件免费试用，主要流程跟着网上的教程走，具体优惠的限制在其他教程中已说得比较清楚了，不再赘述。**重点：**需要一张信用卡，然后注册验证的时候会从信用卡扣1美元，然后需要一个电话，亚马逊机器人会打这个电话，按提示在电话中输入网页上的验证码。 创建 Windows Server 2008 R2 镜像（由于本人没玩过 Linux、Windows Server 2012 也没尝试成功，所以最后使用的是 2008）。**重点：**在安全组策略中，AWS 已为我们的实例开启了 RDP 3389 端口以供远程桌面访问，修改为允许所有流量从任何 IP 进入（之前尝试了开放部分端口，比如 1723、1701，但是客户端连接不成功）。 创建实例，具体选择在哪个地区创建实例可通过这个网址进行测试http://www.cloudping.info，我自己选的韩国首尔，然后通过秘钥获得 VPS 实例的初始密码。 在控制面板左侧申请一个弹性IP绑定在刚才创建的实例上。 远程访问实例，降低本地安全策略的密码强度（可选），然后设置自己的管理员密码。 功能安装，安装远程访问与远程路由（Routing and Remote Access Services）的功能。 安装完毕后开启 VPN 服务，自定义选择 VPN 和 NAT。 对 VPN 进行配置，主要是分配静态 IP，根据服务器所在的内网 IP 决定，从服务器本机 IP 开始，可往后连续分配一定数量。 启动 NAT。 新建 VPN 用户，并设置允许访问网络然后分配之前划定的静态 IP，至此，服务端的配置就算结束了。 现在开始配置客户端，客户端比较简单，先建立一个 VPN，然后输入服务器的外网 IP，然后是用户名和密码，修改本地 VPN 连接的 DNS，可用 google 的 DNS：8.8.8.8 和 8.8.4.4，一切修改完毕后就可以开始连接，如果还是不行可能还要修改本地网卡的 DNS。注意：Mac 下要选择协议 PPTP，然后高级设置里要勾选通过 VPN 连接发送所有流量。 总体上感觉速度还不错，虽然服务器和带宽不咋地，不过一般上上 google、查查资料还是没问题。然后测试了不同用户在不同地点登录，貌似有点问题，具体的网络原理也不太清楚。 参考：http://www.advertcn.com/thread-7568-1-1.html ","date":"2016-09-08","objectID":"/aws-vps-%E5%88%9B%E5%BB%BA-windows-server-vpn/:1:0","tags":["deploy"],"title":"AWS VPS 创建 Windows Server VPN","uri":"/aws-vps-%E5%88%9B%E5%BB%BA-windows-server-vpn/"},{"categories":["resource"],"content":"微软相关平台资源 国内的微软相关资源：http://www.itellyou.cn/ Dotnet 相关资源：https://www.microsoft.com/net/download/visual-studio-sdks Windows 操作系统官方下载工具：https://www.microsoft.com/zh-cn/software-download/windows10 C# 注释规范：https://msdn.microsoft.com/zh-cn/library/5ast78ax.aspx Dotnet 全栈之路：https://www.microsoft.com/net/architecture .Net 产品控件库：https://www.syncfusion.com/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:1:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"WPF 官方 MSDN（英文）：https://msdn.microsoft.com/en-us/library/ms754130.aspx 官方 MSDN（中文）：https://msdn.microsoft.com/zh-cn/library/ms754130(v=vs.110).aspx ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:2:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"Visual Studio 模板扩展下载：https://visualstudiogallery.msdn.microsoft.com/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:2:1","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"Xamarin 版本信息：https://developer.xamarin.com/releases/current/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:2:2","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"VPN https://monocloud.net/ https://www.diycode.cc/topics/738 ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:3:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"内网穿透 https://natapp.cn/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:4:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"有趣 GitHub 上的技术栈：https://octoverse.github.com/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:5:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"设计 ICON 资源软件 Metro Studio：https://www.syncfusion.com/downloads/metrostudio/iconpackage/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:6:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"DotNetLib 对比 https://dotnet.libhunt.com/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:7:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["deploy"],"content":"Web Deploy 支持直接从本地 Visual Studio 的工程文件部署网站到远程服务器，部署的过程中可以对比哪些文件变化了需要拷贝，而不是一股脑的全部拷贝，效率和准确性会更好。 部署的过程主要要注意以下几点： ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:0:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"远程服务器的 IIS 安装管理服务 ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:1:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"IIS 控制面板中启动管理服务，使用 Windows 凭据还是 IIS 凭据视需要而定 完毕之后可以看到服务列表中的 WMSVC 启动 ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:2:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"安装Web Deploy，地址 http://www.iis.net/downloads/microsoft/web-deploy ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:3:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"本地 Visual Studio 链接测试 注意站点名称必须和 IIS 中的站点名称匹配才能验证连接成功，还有注意你的服务器 IP 地址必须能够 Ping 通，防火墙端口 8172 必须开放。整个过程我只遇到一个问题，与这篇文章类似：http://www.benday.com/2013/07/12/fix-error_could_not_connect_to_remotesvc-error-using-visual-studio-2012-web-deploy/ ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:4:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["dotnet"],"content":"假如有这样一个场景，1 个 100 万用户同时在线的系统，假设有一个 Session 管理器来管理它们的存亡，每个用户的 Session 有效时间假设 5 分钟，通常一个最简单的做法是在一个 Session 管理器中启动一个 Thread 去定时校验每个 Session 是否到达有效期截止时间，将到期的 Session 清理掉，而这个需求就导致存放 Session 的字典必须支持并发。而另一种做法就是在每个 Session 对象的内部去启动一个 Timer 让 Timer 在指定时间后去校验自身是否到期，若到期则发出事件通知让管理器去做清理工作。 测试结果，使用 Thread 的方式 CPU 一直保持在 4% 左右，而使用 Timer 的方式 CPU 保持在 0，内存比 Thread 方式多用 100 多 mb。按照存储比 CPU 便宜的标准，即使是内存消耗感觉也是第二种方式会更好一些。 2017 年 3 月 9 日补充：这篇文章过时了，今天读到篇文章，原来可以用一种叫环形队列的数据结构来处理这种大量的超时任务。参见：http://mp.weixin.qq.com/s/mvFwjgxliwx808Hn_9ruEA。 ","date":"2016-06-22","objectID":"/timer-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF/:0:0","tags":["dotnet","async"],"title":"Timer 的性能优势","uri":"/timer-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF/"},{"categories":["xamarin"],"content":"Xamarin Android 项目在编译时会从 google 的服务器下载缺失的 m2repository 相关文件，虽然不明白这是干什么的，但是情况就是 Andorid SDK Manager 不会去下载这个东西，然后在 VS 里编译某些项目时会去下载某些版本的 m2repository 文件。 由于墙的关系这个肯定是下载不下来的，所以只能通过迅雷穿墙下载，然后拷贝到指定的目录，这个目录就是它报错的提示里的一个文件夹，路径类似于：C:\\Users\\Administrator\\AppData\\Local\\Xamarin\\zips，下载的路径可以从国内的镜像网站找，也可以根据报错提示从 google 的网站下，官方的下载路径类似于：https://dl-ssl.google.com/android/repository/android_m2repository_r10.zip 下载完毕后需要放入上面的指定文件夹，还要修改文件的名字，对应关系如下（截止至 23.3.0 版）： Android： 23.3.0 —— android_m2repository_r29.zip —————– 2A3A8A6D6826EF6CC653030E7D695C41.zip 23.2.1 —— android_m2repository_r28.zip —————– 17BE247580748F1EDB72E9F374AA0223.zip 23.1.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.0.1.3 —— android_m2repository_r22.zip —————– 96659D653BDE0FAEDB818170891F2BB0.zip 23.0.1.1 —— android_m2repository_r20.zip —————– 650E58DF02DB1A832386FA4A2DE46B1A.zip 22.2.1 —— android_m2repository_r16.zip —————– 0595E577D19D31708195A83087881EE6.zip 22.2.0 —— android_m2repository_r15.zip —————– F9D66CC0ADC0C3787F4DAE6D494E6BC7.zip 22.1.1.1 —— android_m2repository_r14.zip —————– AB24E1C26FC70B44683752D37075AC06.zip 22.0.0 —— android_m2repository_r12.zip —————– 806FD8EEF161DCEA979C128F27BE5867.zip 21.0.3 —— android_m2repository_r10.zip —————– 1FD832DCC1792D8ACA07FAC3259FC5A9.zip 19.0.1 —— support_r19.0.1.zip —————– CED55A39D1283BB9DC217CAE987067E0.zip Google： 8.4 —— google_m2repository_r24.zip —————– CAA441D76F04E0D57C4110F8A00CDA7A.zip 以上有缺失和错误的欢迎补充，给出一个完整包的下载地址： http://pan.baidu.com/s/1boOwuZ1 ","date":"2016-05-16","objectID":"/%E8%A7%A3%E5%86%B3-xamarin-android-%E5%A2%99%E7%9A%84%E9%97%AE%E9%A2%98/:0:0","tags":["xamarin","dotnet"],"title":"解决 Xamarin Android 墙的问题","uri":"/%E8%A7%A3%E5%86%B3-xamarin-android-%E5%A2%99%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["xamarin"],"content":"在 Xamarin 中有一些 Forms 原生不太好实现的内容可以考虑使用 HTML、Javascript、CSS 那一套前端技术来实现，使用 WebView 来承载显示本地或网络上的 HTML 文件。不像 OpenUri 方法，不是将用户带到设备中的本地浏览器里去，而是用 WebView 直接在 App 内部显示 HTML 内容。 该文档由下面几节内容组成： 内容（Content）——WebView 支持各种内容元素，包括嵌入式 HTML 文件，Web 页面和 HTML 字符串。 导航（Navigation）——WebView 支持导航到特定的页面并返回。 事件（Events）——监听并相应响应用户在 WebView 中触发的动作。 性能（Performance）——了解各平台上 WebView 的性能特点。 权限（Permissions）——了解在 App 中使用 WebView 的相应权限设置。 布局（Layout）——WebView 对布局有一些特别要求，了解如何恰当的显示 WebView。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:0:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Content WebView 支持下列几种内容： HTML 和 CSS 网站——WebView 全方位支持 HTML 和 CSS 布局的网站，也包括对 JavaScript 的支持。 文档（Documents）——因为 WebView 使用的是平台本地组件，所以 WebView 可以显示平台所支持的那些文档类型。这意味着，PDF 文件可以直接在 iOS 和 Android 平台上显示，但是 Windows Phone 平台不能。 HTML 字符串——WebView 可以显示内存中的 HTML 字符串。 本地文件——WebView 可以显示嵌入在 App 中的任何内容。 注意： Windows 和 Windows Phone 平台上的 WebView 并不支持 Silverlight，Flash和任何的 ActiveX 控件，即使该平台上的 Internet Explorer 浏览器都支持。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"网站（Websites） 要显示因特网上的一个网站，可以给 WebView 的 Source 属性设置一个 URL 字符串： var browser = new WebView { Source = \"http://xamarin.com\" }; 注意： URLs 地址必须是指定协议的完整格式（如：前面必须有\"http://“或”http://\"） iOS 和 ATS 自 iOS 9 以后，默认情况下仅允许应用程序和实现了最佳安全实践的服务通信，如果想和不安全的服务进行通信必须要修改 Info.plist 的设置。 注意： 如果你的应用程序需要链接一个不安全的服务，你应该使用 NSExceptionDomains 设置一些域名做为例外，而不是使用 NSAllowsArbitraryLoads 完全关闭 ATS。 NSAllowsArbitraryLoads 只应该用在某些极端紧急情况下。 下面这个例子展示了如何设置一些特殊域名（此处用 xamarim.com 举例）绕开 ATS 的检验： \u003ckey\u003eNSAppTransportSecurity\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSExceptionDomains\u003c/key\u003e \u003cdict\u003e \u003ckey\u003examarin.com\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSIncludesSubdomains\u003c/key\u003e \u003ctrue/\u003e \u003ckey\u003eNSTemporaryExceptionAllowsInsecureHTTPLoads\u003c/key\u003e \u003ctrue/\u003e \u003ckey\u003eNSTemporaryExceptionMinimumTLSVersion\u003c/key\u003e \u003cstring\u003eTLSv1.1\u003c/string\u003e \u003c/dict\u003e \u003c/dict\u003e \u003c/dict\u003e 良好的实践是只让一部分域名绕开 ATS 的检验，允许你访问受信任的网站同时也能更安全的访问不受信任的域名。下面的例子展示了 App 当中最不安全的一种做法，完全禁用 ATS： \u003ckey\u003eNSAppTransportSecurity\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSAllowsArbitraryLoads \u003c/key\u003e \u003ctrue/\u003e \u003c/dict\u003e 查看 App Transport Security 获取关于 iOS 9 这个新功能的更多信息。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"HTML 字符串 如果你想展示一串被代码动态定义的 HTML 字符串，你需要创建一个 HtmlWebViewSource 的实例： var browser = new WebView(); var htmlSource = new HtmlWebViewSource(); htmlSource.Html = @\"\u003chtml\u003e\u003cbody\u003e \u003ch1\u003eXamarin.Forms\u003c/h1\u003e \u003cp\u003eWelcome to WebView.\u003c/p\u003e \u003c/body\u003e\u003c/html\u003e\"; browser.Source = htmlSource; 上面的代码中，@ 符号用于标记 HTML 作为一串字面量的字符串，所有通用转义符都会被忽略。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:2","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"本地 HTML 文件 WebView 可以直接展示嵌入在 App 中的 HTML，CSS 和 Javascript，例如： \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eXamarin Forms\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eXamrin.Forms\u003c/h1\u003e \u003cp\u003eThis is an iOS web page.\u003c/p\u003e \u003cimg src=\"XamarinLogo.png\" /\u003e \u003c/body\u003e \u003c/html\u003e CSS： html,body { margin:0; padding:10; } body,p,h1 { font-family: Chalkduster; } 注意上面的 CSS 中指定的特殊字体需要根据不同的平台自定义，不是所有的平台都具有相同的字体。 注意： Xamarin.Forms 中当前存在一个 bug，在 Windows 中本地 HTML 内容不能被显示，但是它不会影响 Windows Phone。查看 Bugzilla 获取关于这个 bug 最新状态的更多信息。 使用 WebView 显示本地内容，你需要像打开其他文件一样打开一个 HTML 文件，然后读取内容文本到 HtmlWebViewSource 的 Html 属性上。关于打开文件的更多信息，可以查看 Working with Files。 虽然我们读取了第一个页面，但是 WebView 并不知道 HTML 来自于哪里。这样在处理页面引用本地资源时就会有问题。例如，一个本地文件很可能有一个指向另一个文件的链接，也有可能使用一个分离的 JavaScript 文件，或者一个 CSS 样式文件。 为了解决这个问题，你需要告诉 WebView 到文件系统的哪里去寻找文件。此时需要设置 WebView 所引用的 HtmlWebViewSource 对象的 BaseUrl 属性。 因为文件系统在每个操作系统上是不一样的，所以你需要针对每个平台确定它的 URL。Xamarin.Forms 可以通过 DependencyService 解决运行时的平台依赖。 要使用 DependencyService，需要先定义一个可被各平台所实现的接口： public interface IBaseUrl { string Get(); } 注意，该接口需要被各个平台实现，否则 App 会无法运行。在公共项目中，要确保你记得使用 DependencyService 设置 BaseUrl 的值： var source = new HtmlWebViewSource(); source.BaseUrl = DependencyService.Get\u003cIBaseUrl\u003e().Get(); 至此，你只需要在各个平台中实现这个接口就可以了： iOS [assembly: Dependency(typeof(BaseUrl_iOS))] namespace WorkingWithWebview.iOS { public class BaseUrl_iOS : IBaseUrl { public string Get() { return NSBundle.MainBundle.BundlePath; } } } 此时网站的位置会被定位到项目的根目录或者 Resources 目录，并且文件的生成操作应该修改为 BundleResource，如下图： Android 在 Android 平台下，HTML，CSS 和图片文件应该位于 Assets 文件夹下，并且生成操作应该修改为 AndroidAsset，如下图： Android 平台下，BaseUrl 的值应该设置为 \"file:///android_asset/\"： [assembly: Dependency(typeof(BaseUrl_Android))] namespace WorkingWithWebview.Android { public class BaseUrl_Android : IBaseUrl { public string Get() { return \"file:///android_asset/\"; } } } Android 平台下，Assets 文件夹下的文件也可以通过 Forms.Context.Assets 属性访问，代码如下： var assetManager = Xamarin.Forms.Forms.Context.Assets; using (var streamReader = new StreamReader(assetManager.Open(\"local.html\"))) { var html = streamReader.ReadToEnd(); } Windows Phone 注意： 在Windows Phone 8.1 下 WebView 不支持本地内容，但是在 Windows Phone 8 下支持。 在 Windows Phone 平台下，HTML，CSS 和图片文件位于项目根目录，并且生成操作应该修改为 Content，如下图： Windows Phone 平台下，BaseUrl 的值应该设置为\"\"： [assembly: Dependency(typeof(BaseUrl_Windows))] namespace WorkingWithWebview.Windows { public class BaseUrl_Windows : IBaseUrl { public string Get() { return \"\"; } } } ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:3","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Navigation WebView 可以通过几个方法和属性来进行导航： GoForward()——如果 CanGoForward 等于 true，调用 GoForward 导航到下一个访问页面。 GoBack()——如果 CanGoBack 等于 true，调用 GoBack 将会导航到最后一个访问过的页面。 CanGoBack——如果有页面可以返回则该值等于 true，如果浏览的是起始 URL 则该值返回 false。 CanGoForward——如果用户返回了某个页面并且可以向前访问某个已经访问过的页面则该值为 true。 在页面内部，WebView 不支持多点触控。所以重点是需要针对移动端优化内容，使其呈现时不需要额外的缩放等操作。 对于应用程序来说，在 WebView 中展示链接比在设备的浏览器中展示更常见。在这种情况下，允许正常的导航非常有用，但是当用户在起始页面点击返回按钮时，程序会返回到一个正常的 App 页面中。 下面演示如何使用内建的方法和属性启用这种场景。 首先在一个 page 页面中创建一个浏览器视图： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"WebViewDemo.InAppDemo\" Title=\"In App Browser\"\u003e \u003cContentPage.Content\u003e \u003cStackLayout\u003e \u003cStackLayout Orientation=\"Horizontal\" Padding=\"10,10\"\u003e \u003cButton Text=\"Back\" HorizontalOptions=\"StartAndExpand\" Clicked=\"backClicked\" /\u003e \u003cButton Text=\"Forward\" HorizontalOptions=\"End\" Clicked=\"forwardClicked\" /\u003e \u003c/StackLayout\u003e \u003cWebView x:Name=\"Browser\" WidthRequest=\"1000\" HeightRequest=\"1000\" /\u003e \u003c/StackLayout\u003e \u003c/ContentPage.Content\u003e \u003c/ContentPage\u003e 后台代码： public partial class InAppDemo : ContentPage { //sets the URL for the browser in the page at creation public InAppDemo(string URL) { InitializeComponent(); Browser.Source = URL; } private void backClicked(object sender, EventArgs e) { //check to see if there is anywhere to go back to if (Browser.CanGoBack) { Browser.GoBack(); } else { //if not, leave the view Navigation.PopAsync(); } } private void forwardClicked(object sender, EventArgs e) { if (Browser.CanGoForward) { Browser.GoForward(); } } } 最后呈现效果如下： ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Events WebView 通过触发两个事件来帮助你响应状态变更： Navigating——当 WebView 开始加载一个新页面时触发。 Navigated——当一个页面加载完毕并且导航停止时触发。 如果你能预感到加载网页将会耗费比较长的时间，可以考虑使用这两个事件实现一个状态指示器。代码如下： 界面 XAML 代码： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"WebViewDemo.LoadingDemo\" Title=\"Loading Demo\"\u003e \u003cContentPage.Content\u003e \u003cStackLayout\u003e \u003cLabel x:Name=\"LoadingLabel\" Text=\"Loading...\" HorizontalOptions=\"Center\" isVisible=\"false\" /\u003e \u003cWebView x:Name=\"Browser\" HeightRequest=\"1000\" WidthRequest=\"1000\" Navigating=\"webOnNavigating\" Navigated=\"webOnEndNavigating\" /\u003e \u003c/StackLayout\u003e \u003c/ContentPage.Content\u003e \u003c/ContentPage\u003e 后台两个事件处理： void webOnNavigating (object sender, WebNavigatingEventArgs e) { LoadingLabel.IsVisible = true; } void webOnEndNavigating (object sender, WebNavigatedEventArgs e) { LoadingLabel.IsVisible = false; } 当页面加载中时输出结果如下： 当页面加载完成时输出如下： ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Performance 最近的各大 web 浏览器都已经采用了一些被世人所熟知的流行技术，如硬件加速渲染和 JavaScript 编译。不幸的是，出于安全限制，大多数高级功能在 iOS 的 WebView 和 UIWebView 里无法使用。Xamarin.Forms 里的 WebView 在 iOS 平台下实际上是使用的 UIWebView。如果这个限制对你的使用造成了困扰，你需要在平台内部使用支持快速浏览等功能的 WKWebView 进行重新渲染。但是需要注意 WKWebView 仅支持 iOS 8 以上的系统。 WebView 在 Android 的默认设置中跟内建浏览器一样快。 在 Windows Phone 8 和 Windows Phone 8.1 里的 WebBrowser 控件不支持最新的 HTML5 相关新特性，并且它常常出现性能问题。需要注意测试网站在 Windows Phone 的 WebView 中究竟会怎样呈现，如果仅在 IE 浏览器中测试是不够的。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Permissions 为了让 WebView 正常工作，你必须知道各个平台的权限设置。注意在一些平台，WebView 在 debug 模式下可以工作，但是在最后发布时的 release 模式下却不能。这就是权限造成的问题，比如 Android 上的 internet 访问权限，在 Xamarin Studio 的调试模式下默认是打开的。 Windows Phone 8.0——需要 ID_CAP_WEBBROWSERCOMPONENT 权限来使用控件，需要 ID_CAP_NETWORKING 来访问因特网。 Windows Phone 8.1——需要 Internet 才能访问网络内容。 Android——需要 Internet 才能访问网络内容，访问本地内容不需要特殊的权限。 iOS——不需要特殊的权限。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Layout 不像大多数其他 Xamarin.Forms 视图，在 StackLayout 和 RelativeLayout 中嵌套 WebView 时必须指明它的 HeightRequest 和 WidthRequest 属性。如果你没有指明这些属性，那么 WebView 将不会渲染。 下面的例子展示了 WebView 的渲染布局代码： 在 StackLayout 中指明 HeightRequest 和 WidthRequest： \u003cStackLayout\u003e \u003cLabel Text=\"test\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" HeightRequest=\"1000\" WidthRequest=\"1000\" /\u003e \u003c/StackLayout\u003e 在 RelativeLayout 中指明 HeightRequest 和 WidthRequest： \u003cRelativeLayout\u003e \u003cLabel Text=\"test\" RelativeLayout.XConstraint= \"{ConstraintExpression Type=Constant, Constant=10}\" RelativeLayout.YConstraint= \"{ConstraintExpression Type=Constant, Constant=20}\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" RelativeLayout.XConstraint=\"{ConstraintExpression Type=Constant, Constant=10}\" RelativeLayout.YConstraint=\"{ConstraintExpression Type=Constant, Constant=50}\" WidthRequest=\"1000\" HeightRequest=\"1000\" /\u003e \u003c/RelativeLayout\u003e 在 AbsoluteLayout 中不用指明 HeightRequest 和 WidthRequest： \u003cAbsoluteLayout\u003e \u003cLabel Text=\"test\" AbsoluteLayout.LayoutBounds=\"0,0,100,100\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" AbsoluteLayout.LayoutBounds=\"0,150,500,500\" /\u003e \u003c/AbsoluteLayout\u003e 在 Grid 中不用指明 HeightRequest 和 WidthRequest，Grid 是少数的几个不用指明宽和高的布局容器： \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"100\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003cLabel Text=\"test\" Grid.Row=\"0\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" Grid.Row=\"1\" /\u003e \u003c/Grid\u003e 原文链接： https://developer.xamarin.com/guides/xamarin-forms/user-interface/webview/ 相关 Demo：Working with WebView WebView 的简单演示：WebView WebView 的高级演示，包括平台自定义渲染 WebView 和 JavaScript 和 C# 代码交互： HybridWebView ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:6:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"如之前所见的大量可视化元素均有自己的尺寸大小： iOS 的状态栏高度为 20，所以我们需要调整 iOS 的页面的 Padding 值，留出这个高度。 BoxView 设置它的默认宽度和高度为 40。 Frame 的默认 Padding 为 20。 StackLayout 的默认 Spacing 属性值为 6。 还有 Device.GetNamedSize 方法，该方法将 Label 或 Button 等控件中使用的 NamedSize 枚举值转换为不同平台对应的数值，即不同控件中不同 NamedSize 枚举对应的 FontSize 值。 然后上面那些数值代表什么？它们的单位是什么？并且怎样精确的设置这些值获得指定的大小？ 好问题。尺寸大小同样会影响文本的显示效果，正如我们所看到，不同的平台显示的文本的数量也会不一样，那么可以在 Forms 程序中控制显示的文本数量吗？即使可以控制，那会是一种好的编程实践吗？程序应该通过调整尺寸大小来适应屏幕的显示密度吗？ 通常，当编写 Xamarin.Forms 应用程序时不要过于接近那些可视化元素的实际尺寸数值。最好的方式是充分信任 Xamarin.Forms 在三个不同平台下都会做出最好的默认选择。 然后，有时一个开发者还是需要知道部分可视化元素的尺寸大小以及它们所附着的屏幕的尺寸大小。 如你平时所知的一样，视频是由一大堆像素所组成的一个矩形。任何可以显示在屏幕上的可视化元素都有一个像素尺寸。在早期的个人电脑中，开发者都用像素来定位和布局那些可视化元素。但是，随着拥有更多元素的大小尺寸和像素密度的显示设备出现，在编写程序时直接使用像素的方式变得过时和不受开发者欢迎了，必须寻求另一种新的解决方案。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:0:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"Pixels，points，dps，DIPs，DIUs 这种控制像素的方式始于桌面电脑时代的操作系统，于是这种解决方案也自然而然的被用于移动设备。因此，我们将从桌面设备开始探讨这个问题。 桌面视频有大量不同的像素尺寸，从几乎要过时的 640x480 到上千像素。跟电影和电视一样，4:3 的纵宽比也曾经是电脑显示的标准，不过现在更常用高清晰纵宽比，如 16：9 或者 16：10。 桌面视频也有一个物理尺寸，这个物理尺寸通常是测量显示器对角线的英寸和厘米长度。通过像素尺寸和物理尺寸可以计算出这个视频的显示分辨率或者像素密度，像素密度使用 DPI（dots per inch 打印分辨率——即每英寸所打印点数）来描述，有时也可以使用 PPI（pixels per inch 图像的采样率——即每英寸的像素数量）。显示分辨率还可以通过 点距（dot pitch——即相邻像素间的距离，毫米为单位）来描述。 例如，使用毕达哥拉斯定律可以计算出一个 800x600 分辨率的对角线长度上可以容纳 1000 像素点，如果是 13 英寸的显示器，那么像素密度是 77 DPI，或者 0.33 毫米的点距。然后，如果现代笔记本上的 13 英寸显示器可能拥有 2560x1600 的像素尺寸，230 DPI 的像素密度，或者 0.11 毫米的点距。那么同样的一个 100 像素的正方形元素在高精度显示器上的大小可能只有老式显示器的三分之一大。 当开发者试图调整可视化元素到正确的大小就像一场战役一样。因此，Apple 和 Microsoft 计划为桌面电脑建立一套机制来允许开发者用一些设备无关的单位来描述视频显示的尺寸而不是直接使用像素。开发者遇到的大多数尺寸规格都能用这一系列的设备独立单位来描述，而操作系统就负责在这些设备独立单位和像素之间进行转换。 在 Apple 的世界里，桌面视频都假设每英寸拥有 72 单位元素。这一数字来源于印刷排版界，在传统的印刷排版里，每英寸大约有 72 个点，但是在数字排版印刷方面，这个点位的精度已经标准化为 1/72 英寸。使用点的数量来描述比直接使用像素更好，开发者能更直观的感受到屏幕上可视化元素和这个大小包括的尺寸点数之间的关系。 在 Microsoft 世界里，一个相似的技术已经成熟，被称为设备无关像素（device-independent pixels DIPs），或者设备无关单位（device-independent units DIUs）。作为一个 Windows 开发者，需要知道该平台下的桌面视频假定拥有一个 96 DIUs 的分辨率，比 72 DPI 高三分之一。 然而，移动设备拥有不同的规则：一个特点就是现代手机的像素密度比桌面设备高出很多。高像素密度意味着文本和其他可视化元素会收缩在一个很小的尺寸空间中。 手机的另一个特点就是比桌面设备或笔记本更贴近人的面部。这也意味着相同的可视化元素如果呈现在手机上，尺寸可以比桌面设备更小。因为手机的物理尺寸比桌面设备更小，所以缩小可视化元素来适应屏幕就变得十分可取。 Apple 继续在 iPhone 上使用 DIUs 来描述点数，直到最近，所有的苹果设备都采用来一种被叫做 Retina 的高清屏解决方案，该方案使单点的像素密度变成原来的两倍。这个规则适用于苹果的几乎所有设备，MacBook Pro，iPad 和 iPhone。直到 iPhone 6 Plus 的出现，将单点的像素密度变成了原来的三倍。 例如，iPhone 4 拥有 3.5 英寸屏幕，640x960 像素显示分辨率，320 DPI 的像素密度。由于单点有两倍的像素密度，所以当应用程序运行在 iPhone4 上当时候，将会在屏幕上呈现 320x480 个点。iPhone 3 有 320x480 的像素显示分辨率，点的数量等于像素的数量，所以，对于一个程序来说，呈现在 iPhone 3 和 iPhone 4 上的大小相同。尽管大小尺寸相同，但是 iPhone 4 上的文本和可视化元素将会显示在一个更高的分辨率之上。 对于 iPhone 3 和 iPhone 4，从屏幕尺寸和点数尺寸的关系上来说，它们拥有比桌面设备每英寸 72 点更大的一个密度，每英寸 160 点。 iPhone 5 拥有一个 4 英寸屏幕，但是它点像素尺寸达到了 640x1136。像素密度和 iPhone 4 一样，对于程序来说，屏幕上点数尺寸为 320x768。 iPhone 6 拥有 4.7 英寸屏幕，像素尺寸为 750x1334。像素密度同样也是 320 DPI，每单位点有两个像素，所以对于程序来说，屏幕上能呈现的点数尺寸为 375x667。 然而，iPhone 6 Plus 拥有 5.5 英寸屏幕，像素尺寸为 1080x1920，像素密度为 400DPI，更高的像素密度意味着一个点上有更多的像素，对于 iPhone 6 Plus，Apple 设定一个点等于三个像素点。给我们的感觉是屏幕的点数尺寸应该是 360x640，但是实际对于程序来说，iPhone 6 Plus 点屏幕点数尺寸是 414x736，每英寸 150 个点。 以上信息总结起来就如下面这个表： 型号 iPhone 2，3 iPhone 4 iPhone 5 iPhone 6 iPhone 6 Plus 像素尺寸 320x480 640x960 640x1136 750x1134 1080x1920 屏幕尺寸 3.5 英寸 3.5 英寸 4 英寸 4.7 英寸 5.5 英寸 像素密度 165 DPI 330 DPI 326 DPI 326 DPI 401 DPI 单位点包含像素数量 1 2 2 2 3 点数尺寸 320x480 320x480 320x568 375x667 414x736 每英寸包含点数量 165 165 163 163 154 Android 也十分相似，只是 Andorid 设备拥有更多的设备尺寸和显示尺寸，但是 Andorid 开发者在工作中通常不关心具体设备，而是关心密度无关像素这个单位（density-independent pixel dps）。像素密度和 dps 之间的关系是，每英寸呈现 160dps，即 Andorid 和 Apple 的单位很相似。 然而 Mircosoft 通过 Windows Phone 带来了一种不同的方式。Windows Phone 7 设备无论它的屏幕分辨率是 320x480（这种分辨率很稀有，可不做讨论）或者是 480x800（通常叫做 WVGA Wide Video Graphics Array），都拥有统一的像素尺寸。Windows Phone 7 程序工作在这种像素单位的基础上。假设一台最平常的 4 英寸 480x800 的 Windows Phone 7 设备，这意味着该设备的像素密度大约是 240DPI。而这是 iPhone 和 Android 设备的 1.5 倍。 当 Windows Phone 8 来临时，出现了很多更大屏幕的设备，768x1280（WXGA Wide Extended Graphics Array），720x1280（720P），1080x1920（1080P）。 对于这三种额外的尺寸，开发者同样使用设备无关的单位。此时，一个内部的缩放机制将会使所有设备在竖屏情况下宽度都呈现 480 像素。对应的比例因子如下表： 屏幕类型 WVGA WXGA 720P 1080P 像素尺寸 480x800 768x1280 720x1280 1080x1920 缩放比例 1 1.6 1.5 2.25 DIUs 尺寸 480x800 480x800 480x853 480x853 Xamarin.Forms 开发者通常使用设备无关的方式来处理手机显示，但是在具体三个平台上也有一些不一样： iOS：每英寸 160 单位 Android：每英寸 160 单位 Windows Phone：每英寸 240 单位 如果将相同物理大小的可视化元素放在三个平台，那么 Windows Phone 平台上看见的大小会比 iOS 和 Android 大 1.5 倍。 VisualElement 类定义了两个属性，Width 和 Height，这两个元素用设备无关的单位来描述 views，layouts 和 pages。这两个属性的初始值被设置为伪值 -1。只有当 page 上的所有元素都已经定位和调整大小完毕这两个属性的值才有效。同样，需要注意 HorizontalOptions 或 VerticalOptions 的默认值是 Fill，这个设置将会让视图尽可能的占据更多的空白地方。 Width 和 Height 的值也可以用来反映一些额外空间值，比如 Padding，设置后的区域会被 view 的 BackgroundColor 属性指定的颜色填充。 VisualElement 定义了一个 SizeChanged 事件，当一个可视化元素的 Width 或 Height 属性发生变化时触发。当 page 对内部的大量元素进行定位和调整大小时会触发一系列事件，SizeChanged 事件就是其中一个。这个构造的过程会在第一次定义这个 page 时出现（通常是在 page 的构造中），而任何一个对布局内容的影响都会使这一过程再次发生，例如将视图添加到 ContentPage 或者 StackLayout 中，或从它们中移除，或者改变可视化元素的大小。 当屏幕尺寸发生改变时同样也会触发新的布局过程，这种情况通常发生在设备在竖屏和横屏之间进行切换的","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"可测量尺寸（Metrical sizes） 这里再一次强调一下三个平台上的英寸和设备无关单位之间的关系： iOS：每英寸 160 单位 Android：每英寸 160 单位 Windows Phone：每英寸 240 单位 下面是尺寸以厘米为单位的情况： iOS：每厘米 64 单位 Android：每厘米 64 单位 Windows Phone：每厘米 96 单位 那么意味着 Xamarin.Forms 程序可以使用以上可测量尺寸来更改可视化元素大小，使用熟悉的英寸或厘米为单位。下面给出一个名叫 MetricalBoxView 的程序来展示这个问题，该程序在屏幕上显示了一个宽大约 1 厘米高大约 1 英寸的 BoxView。 public class MetricalBoxViewPage : ContentPage { public MetricalBoxViewPage() { Content = new BoxView { Color = Color.Accent, WidthRequest = Device.OnPlatform(64, 64, 96), HeightRequest = Device.OnPlatform(160, 160, 240), HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center }; } } 如果你使用直尺在手机屏幕上测量，你会发现结果跟我们希望的尺寸很接近。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"估计字体大小（Estimated font sizes） Label 和 Button 控件上的 FontSize 属性的类型是 double。FontSize 指的是文本字符从最下面到最上面到高度，也包括该字体对应的标点符号。在大多数情况下，你需要通过 Device.GetNamedSize 方法设置这个属性。该方法允许你使用一系列 NamedSize 相关到枚举值：Default，Micro，Small，Medium，Large。 你也可以使用字体大小的实际数字，但是这么做会引起一个小问题（稍后会谈到这个细节）。在大多数情况下，Xamarin.Forms 通过相同的设备无关单位来表示字体的大小，这意味着你可以基于不同的平台分辨率计算设备无关的字体大小。 例如，假设你想在程序中使用 12 号字体。首先，你必须要知道 12 号字体用于印刷材料或是桌面显示器的效果很好，但是如果用于手机就太大了。 如果移动设备上一英寸有 72 个点，那么 12 号字体大约是六分之一英寸，乘以分辨率的 DPI。结果是 iOS 和 Android 设备大约是 27 设备无关单位，Windows Phone 大约是 40 设备无关单位。 我们写一个名叫 FontSizes 的小程序，开头部分与第三章中的 NamedFontSizes 程序很相似，后面还列出了不同字体的点数大小，使用设备点分辨率转换为设备无关单位。 public class FontSizesPage : ContentPage { public FontSizesPage() { BackgroundColor = Color.White; StackLayout stackLayout = new StackLayout { HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center }; // Do the NamedSize values. NamedSize[] namedSizes = { NamedSize.Default, NamedSize.Micro, NamedSize.Small, NamedSize.Medium, NamedSize.Large }; foreach (NamedSize namedSize in namedSizes) { double fontSize = Device.GetNamedSize(namedSize, typeof(Label)); stackLayout.Children.Add(new Label { Text = String.Format(\"Named Size = {0} ({1:F2})\", namedSize, fontSize), FontSize = fontSize, TextColor = Color.Black }); } // Resolution in device-independent units per inch. double resolution = Device.OnPlatform(160, 160, 240); // Draw horizontal separator line. stackLayout.Children.Add( new BoxView { Color = Color.Accent, HeightRequest = resolution / 80 }); // Do some numeric point sizes. int[] ptSizes = { 4, 6, 8, 10, 12 }; foreach (double ptSize in ptSizes) { double fontSize = resolution * ptSize / 72; stackLayout.Children.Add(new Label { Text = String.Format(\"Point Size = {0} ({1:F2})\", ptSize, fontSize), FontSize = fontSize, TextColor = Color.Black }); } Content = stackLayout; } } 为便于在三个平台上面比较，背景已被统一设置为白色，文字设置为黑色。在 StackLayout 中间用一个高 1/8 英尺的 BoxView 将两部分分隔开。 这个程序提供了一个粗略的思路让你能够在三个平台上产生视觉上差不多大小的元素。括号中的数字是特定平台下的设备无关的 FontSize 数值。 然而在 Android 平台下有一个问题，运行 Android 的 Settings，进入 Display 页面，选择 Font size 项，可以看到，有 Small，Normal（默认），Large，Huge 这几个字号选择。这项设置可以给用户提供更广的字号选择，对于那些觉得字体太小感觉眼睛不舒服的用户可以将字号调大，对于那些眼睛很好想一次多看一些字的用户可以将字号设小。 在设置中修改字号，选择除 Normal 外的其他选项，然后重新运行 FontSizes 程序，可以看到程序里的所有文本都不一样里，根据你的设置，文本比之前都更大或更小了。你可以看到在水平线的上面部分，也就是 Device.GetNamedSize 方法返回的数值根据系统字号的不同发生了变化。对于 NamedSize.Default，Normal 的默认设置返回的字号是 14（就如上面的截图所展示的一样），如果设置为 Small 则返回 12，Large 返回 16，Huge 返回 18.33。 除了 Device.GetNamedSize 返回的值不一样以外，根据字号设置的不同，底层文本绘制的逻辑也不一样。继续看程序的下面部分，程序计算出的字体的点位值依然相同，虽然它们的文本大小已经发生了改变。这是用枚举值设置 Android 的 Label 的结果，Android 在内部会使用 ComplexUnitType.Sp（COMPLEX_UNIT_SP）计算字体大小，SP 代表缩放像素 scaled pixel，当文本超过使用的设备无关像素时会产生一个缩放。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"调整文本到合适的尺寸（Fitting text to available size） 也许你需要调整一堆文本到一定大小的矩形区域，你可以使用两个数值来计算，一个是矩形区域的实际尺寸，另一个是装载这些文本的 Label 控件的 FontSize 属性值（但是 Andorid 需要将 Font size 设置为 Normal）。 第一个需要的数值是行距，即 Label 视图里每一行文本间的垂直高度。下面展示了三个平台下的具体行高值： iOS：行距 = 1.2 * label.FontSize Android：行距 = 1.2 * label.FontSize Windows Phone：行距 = 1.3 * label.FontSize 第二个有帮助的数值是字符宽度，不管在哪个平台，一段混合了大小写的默认字体的字符宽度大约是 font size 的一半： 平均字符宽度 = 0.5 * label.FontSize 例如，假设你想在宽度为 320 的长度内容纳 80 个文本字符，并且你想让字体尽量的大。那么 320 除以 40（宽度大约占高度一半）得到字号为 8，这个数值就是我们可以给 Label 的 FontSize 属性赋的值。对于文本来说在真正测试之前还有一些不确定性，希望不要对你的计算结果产生太多惊喜。 下面这个程序展示了如何让行距以及字符宽更适合页面中的一段文本，当然这个页面是不包括 iPhone 的状态栏的。为了让 iPhone 排除状态栏更容易一些，这个程序使用了 ContentView。 ContentView 继承自 Layout，只添加了一个 Content 属性。ContentView 是 Frame 的基类，但是 Frame 没有添加过多的额外功能。然而，当你想在自定义页面中定义一组视图，并轻松的模拟它们间的外边距，它将变得很有用。 也许你注意到了，Xamarin.Forms 没有一个 margin 的概念，跟 padding 很相似，padding 定义了视图里的内边距，而 margin 定义了视图外面的外边距。ContentView 可以让我们模拟这个，如果你发现一个视图需要一个外边距，那么你可以将这个视图放在 ContentView 中，并且设置这个 ContentView 的 Padding 属性。ContentView 的 Padding 属性继承自 Layout。 这个 EstimatedFontSize 程序使用 ContentView 的方式略有不同：它通过设置整个页面的 padding 来避开 iOS 的状态栏，而不是将页面中的某一项内容设置到 ContentView 中。因此，此处的 ContentView 除了 iOS 的状态栏以外与页面有相同的尺寸。通过附加 ContentView 的 SizeChanged 事件来获取内容区的尺寸，通过这个尺寸来计算文本的字号。 SizeChanged 事件的处理方法中使用了第一个参数，这个参数通常是引发这次事件的对象（在这个程序里就是包含那个文本填充的 ContentView），代码如下： public class EstimatedFontSizePage : ContentPage { Label label; public EstimatedFontSizePage() { label = new Label(); Padding = new Thickness(0, Device.OnPlatform(20, 0, 0), 0, 0); ContentView contentView = new ContentView { Content = label }; contentView.SizeChanged += OnContentViewSizeChanged; Content = contentView; } void OnContentViewSizeChanged(object sender, EventArgs args) { string text = \"A default system font with a font size of S \" + \"has a line height of about ({0:F1} * S) and an \" + \"average character width of about ({1:F1} * S). \" + \"On this page, which has a width of {2:F0} and a \" + \"height of {3:F0}, a font size of ?1 should \" + \"comfortably render the ??2 characters in this \" + \"paragraph with ?3 lines and about ?4 characters \" + \"per line. Does it work?\"; // Get View whose size is changing. View view = (View)sender; // Define two values as multiples of font size. double lineHeight = Device.OnPlatform(1.2, 1.2, 1.3); double charWidth = 0.5; // Format the text and get its character length. text = String.Format(text, lineHeight, charWidth, view.Width, view.Height); int charCount = text.Length; // Because: // lineCount = view.Height / (lineHeight * fontSize) // charsPerLine = view.Width / (charWidth * fontSize) // charCount = lineCount * charsPerLine // Hence, solving for fontSize: int fontSize = (int)Math.Sqrt(view.Width * view.Height / (charCount * lineHeight * charWidth)); // Now these values can be calculated. int lineCount = (int)(view.Height / (lineHeight * fontSize)); int charsPerLine = (int)(view.Width / (charWidth * fontSize)); // Replace the placeholders with the values. text = text.Replace(\"?1\", fontSize.ToString()); text = text.Replace(\"??2\", charCount.ToString()); text = text.Replace(\"?3\", lineCount.ToString()); text = text.Replace(\"?4\", charsPerLine.ToString()); // Set the Label properties. label.Text = text; label.FontSize = fontSize; } } 这段文本中可以看到唯一名称为“?1”，“??2”，“?3”和“?4”的占位符，程序运行中会用文本的信息替换掉这些占位符。 如果我们的目标是让文本尽量的大但是又不会溢出一屏的范围，那么结果会跟下面的图很接近： 效果不错，虽然 iPhone 和 Android 实际上只显示了 14 行文本，但技术看起来还是可靠的。我们没必要让横屏模式计算出的 FontSize 值也相等，但有时候它也确实可以做到： ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"一个大小合适的计时器（A fit-to-size clock） Class 类中包含一个静态 StartTimer 方法让你能够设置一个计时器定期触发事件。这个可用的周期性事件可以保证这个计时器应用可行，虽然这个应用只是简单的展示一个时间文本。 此处 Device.StartTimer 方法的第一个参数使用一个 TimeSpan 类型的值表示一个时间间隔，这个时间间隔直接影响计时器的触发周期（你的设置可以低到 15 或 16 毫秒，大概等于每秒 60 帧的显示器的帧速率周期），计时器的事件处理函数没有参数，但是需要返回 true 让计时器继续。 程序 FitToSizeClock 创建了一个 Label 用于显示时间然后设置了两个事件：页面的 SizeChanged 事件用于改变字号，Device.StartTimer 事件用于每秒钟改变时间文本值。两个事件的处理代码都是只需要简单的改变 Label 的一个属性，所以可以使用 lambda 表达式来简化写法，就不需要将 Label 存成字段，直接在 lambda 表达式里就直接访问。 public class FitToSizeClockPage : ContentPage { public FitToSizeClockPage() { Label clockLabel = new Label { HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center }; Content = clockLabel; // Handle the SizeChanged event for the page. SizeChanged += (object sender, EventArgs args) =\u003e { // Scale the font size to the page width // (based on 11 characters in the displayed string). if (this.Width \u003e 0) clockLabel.FontSize = this.Width / 6; }; // Start the timer going. Device.StartTimer(TimeSpan.FromSeconds(1), () =\u003e { // Set the Text property of the Label. clockLabel.Text = DateTime.Now.ToString(\"h:mm:ss tt\"); return true; }); } } 在 StartTimer 的方法中指定了一个 DateTime 的自定义格式化字符串将文本格式化为一段 10 个或 11 个的文本字符，文本都是大写字符，并且宽度比平均宽度更宽。在 SizeChanged 处理函数中隐藏了一个逻辑，即假设要显示的文本字符数为 12 个，那么设置它的字号应该是页面宽度的 1/6： 当然，在横屏模式下文本会变得更大： 再次提醒，该技术在 Android 平台下只能用于系统设置中 Font size 的值设置为 Normal 的情况。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"凭经验使用恰当的文本（Empirically fitting text） 在一个特定的矩形框大小范围内填充合适的文本的另一个解决方法是：先凭经验设置文本的字号，然后在此基础上再调大或调小。该方法的优点是在 Android 设备上无论用户系统设置中的 Font size 是什么，都可以很好的工作。 但这个过程可能比较棘手：第一个问题是在字体大小和渲染文本的高度上没有一个清晰的线性关系。当文本在它的容器中宽度越大时，它在单词间就越容易出现分行，这种情况会造成更多的空间浪费。所以为了找到最佳字号往往会重复多次计算。 第二个问题涉及到 Label 渲染一个指定大小字号的文本时，获取 Label 尺寸的一个机制。你可以处理 Label 的 SizeChanged 事件，但是在处理函数里你不能做任何改变（如设置一个新的 FontSize 属性），因为这样做会引起这个事件处理函数的递归调用。 一个更好的方式是调用 GetSizeRequest 方法，这个方法定义在 VisualElement 类中， Label 和其他所有视图元素都继承自这个类。GetSizeRequest 方法需要两个参数，一个是宽度的限制，另一个是高度的限制。这两个值可以表示一个矩形范围，以此来限制你想让这个元素填充的一个范围，并且这两个值可以部分或全部都定义为无穷大。当调用 Label 的 GetSizeRequest 方法时，通常可以将宽度限制为 Label 元素容器的宽度，高度设置为 Double.PositiveInfinity。 GetSizeRequest 方法返回一个类型为 SizeRequest 的值，该类型为一个结构体，定义了两个属性 Minimum 和 Request，两个属性的类型都为 Size。Request 属性指出了这段渲染文本的尺寸大小（关于此类容更多的内容会在后面的章节讲到）。 下面的程序 EmpiricalFontSize 证明了这项技术。为了方便，定义了一个名叫 FontCalc 的结构体来专门针对特定的 Label（已初始化文本）、字号和文本宽度调用 GetSizeRequest 方法： struct FontCalc { public FontCalc(Label label, double fontSize, double containerWidth) : this() { // Save the font size. FontSize = fontSize; // Recalculate the Label height. label.FontSize = fontSize; SizeRequest sizeRequest = label.GetSizeRequest(containerWidth, Double.PositiveInfinity); // Save that height. TextHeight = sizeRequest.Request.Height; } public double FontSize { private set; get; } public double TextHeight { private set; get; } } 这段代码将渲染后的 Label 元素的高度存储在一个 TextHeight 属性中。 当你对一个 page 或是 layout 调用 GetSizeRequest 方法时，它们必须要获得所有包含在可视化树中的元素的尺寸大小。当然，这是有性能损失的，所以，除非有特别的必要，你应该尽量避免这样做。但是 Label 元素没有子元素，所以对 Label 调用 GetSizeRequest 方法的影响并不大。然而，你依然应该尽量尝试优化这个调用。尽量避免通过循环一列字号来找出那个不会导致文本溢出容器的最大字号值，能通过算法来找出合适的值那才更好。 GetSizeRequest 方法需要被调用的元素是可视化树的一部分，并且布局过程至少应该部分开始了。不要在 page 类的构造函数中调用 GetSizeRequest 方法，你不会从中获得任何信息。第一个可能获取到返回信息的时机是 OnAppearing 的重载方法。当然，此时你可能没有足够的信息给 GetSizeRequest 方法提供参数。 在 EmpiricalFontSizePage 类中，Label 的承载容器 ContentView 的 SizeChanged 事件处理函数中有使用 FontCalc 值的实例。（这里的事件处理函数与 EstimatedFontSize 程序相似）。每个 FontCalc 的构造函数对 Label 调用了 GetSizeRequest 方法并将结果存放在 TextHeight 中。SizeChanged 的处理函数在 10 和 100 的上下限字号之间尝试最佳值。因此变量的名称是 lowerFontCalc 和 upperFontCalc： public class EmpiricalFontSizePage : ContentPage { Label label; public EmpiricalFontSizePage() { label = new Label(); Padding = new Thickness(0, Device.OnPlatform(20, 0, 0), 0, 0); ContentView contentView = new ContentView { Content = label }; contentView.SizeChanged += OnContentViewSizeChanged; Content = contentView; } void OnContentViewSizeChanged(object sender, EventArgs args) { // Get View whose size is changing. View view = (View)sender; if (view.Width \u003c= 0 || view.Height \u003c= 0) return; label.Text = \"This is a paragraph of text displayed with \" + \"a FontSize value of ?? that is empirically \" + \"calculated in a loop within the SizeChanged \" + \"handler of the Label's container. This technique \" + \"can be tricky: You don't want to get into \" + \"an infinite loop by triggering a layout pass \" + \"with every calculation. Does it work?\"; // Calculate the height of the rendered text. FontCalc lowerFontCalc = new FontCalc(label, 10, view.Width); FontCalc upperFontCalc = new FontCalc(label, 100, view.Width); while (upperFontCalc.FontSize - lowerFontCalc.FontSize \u003e 1) { // Get the average font size of the upper and lower bounds. double fontSize = (lowerFontCalc.FontSize + upperFontCalc.FontSize) / 2; // Check the new text height against the container height. FontCalc newFontCalc = new FontCalc(label, fontSize, view.Width); if (newFontCalc.TextHeight \u003e view.Height) { upperFontCalc = newFontCalc; } else { lowerFontCalc = newFontCalc; } } // Set the final font size and the text with the embedded value. label.FontSize = lowerFontCalc.FontSize; label.Text = label.Text.Replace(\"??\", label.FontSize.ToString(\"F0\")); } } 在 while 循环的每一次迭代中，根据两个 FontCalc 值的平均值获取 Fontsize 的值并且获取一个新的 FontCalc 对象。依据渲染文本的高度用这个新对象来设置 lowerFontCalc 或者 upperFontCalc。当字体大小计算出最佳值时，循环结束。 大约七次循环之后，就能得到一个比之前那个程序估算出的值更合适的值： 旋转手机就能触发另一次重算，计算出的字号跟刚才相似（虽然没必要一样）： 似乎该算法通过 FontCalc 作为上下限能计算出更大平均值的字号。但是字号和渲染文本之间的高度过于复杂，有时最简单的方式得到的结果也一样的好。 原文链接：","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:6:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["dotnet"],"content":"在 .Net 4 中，Task.Factory.StartNew是启动一个新Task的首选方法。它有很多重载方法，使它在具体使用当中可以非常灵活，通过设置可选参数，可以传递任意状态，取消任务继续执行，甚至控制任务的调度行为。所有这些能力也带来了复杂性的提升，你必须知道何时应该使用何种重载方法，提供哪种调度方式等等。并且Task.Factory.StartNew这种写法也不够简洁明快，至少对它使用的主要场景不够快，一般它使用的主要场景只是将一个工作任务丢给一个后台线程执行而已。 于是，在 .NET Framework 4.5 开发者预览版 中，微软引进了新的Task.Run方法。新方法不是为了替代旧的Task.Factory.StartNew方法，只是提供了一种使用Task.Factory.StartNew方法的更简洁的形式，而不需要去指定那一系列参数。这是一个捷径，事实上，Task.Run的内部实现逻辑跟Task.Factory.StartNew一样，只是传递了一些默认参数。比如当你使用Task.Run： Task.Run(someAction); 实际上等价于： Task.Factory.StartNew(someAction, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default); 使用这些默认参数，Task.Run就能用于大多数情况——只是将任务简单的交给后台线程池去执行（这也是使用TaskScheduler.Default参数的目标）。这也并不意味着Task.Factory.StartNew方法就不必再使用了，它仍然有很多重要的用处。你可以通过控制TaskCreationOptions参数来控制任务的行为，你也可以通过控制TaskScheduler来控制任务应该如何排队如何运行，你也可以使用重载方法中的接受对象状态那个参数，对于一些性能敏感的代码，它可以用于避免闭包以及相应的资源分配。不过对于上面那个简单的例子，Task.Run是最友好。 Task.Run提供了八种重载方式，用于提供下面这几种组合情况： 普通任务（Task）和带返回值任务（Task\u003cTResult\u003e） 可取消任务（Cancelable）和不可取消任务（non-cancelabl） 同步委托（Synchronous）和异步委托（Asynchronous） 前两个很明显，对于第一点如果是用的Task做返回值的重载方法，那么该任务就没有返回值，如果是用的Task\u003cTResult\u003e做返回值的重载方法，那么该任务就有一个类型为TResult的返回值。对于第二点，也有接受CancellationToken参数的重载，可以在任务开始之前执行取消操作，然后并行任务（Task Parallel Library——TPL）就可以自然的过度到取消状态。 第三点要更有趣一些，它直接关系到 Visual studio 11 中的 C#和 Visual Basic 的异步语言支持。我们先使用Task.Factory.StartNew来展示下这个问题，如果有下面一段代码： var t = Task.Factory.StartNew(() =\u003e { Task inner = Task.Factory.StartNew(() =\u003e {}); return inner; }); 这里t的类型会被推断为Task\u003cTask\u003e，因为此处任务的委托类型是Func\u003cTResult\u003e，所以这里TResult的类型就是Task，于是StartNew方法就返回Task\u003cTask\u003e，类似的，我可以改变成下面这种写法： var t = Task.Factory.StartNew(() =\u003e { Task\u003cint\u003e inner = Task.Factory.StartNew(() =\u003e 42)); return inner; }); 此处的t的类型自然是Task\u003cTask\u003cint\u003e\u003e，任务的委托类型还是Func\u003cTResult\u003e，TResult的类型就是Task\u003cint\u003e，StartNew方法就返回Task\u003cTask\u003cint\u003e\u003e。这有什么关系呢？考虑下如果我们现在使用下面这种写法： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }); 这里使用了async关键词，编译器会将这个委托映射成Func\u003cTask\u003cint\u003e\u003e，调用这个委托最终会返回Task\u003cint\u003e。因为这个这个委托是Func\u003cTask\u003cint\u003e\u003e，TResult的类型就是Task\u003cint\u003e，所以最后t的类型应该是Task\u003cTask\u003cint\u003e\u003e，而不是Task\u003cint\u003e。 为了应对这几种情况，在 .Net 4 中引入了Unwrap方法。Unwrap方法有两种重载形式，均是扩展方法的形式，一种是针对类型Task\u003cTask\u003e，另一种是针对\u003cTask\u003cTResult\u003e\u003e。微软只所以要把这个方法命名为解包（Unwrap），是因为这个方法可以返回任务的实际结果。对Task\u003cTask\u003e调用Unwrap方法可以返回一个新的Task（就像内部任务的一个代理一样）代表它的内部任务。相似的，对Task\u003cTask\u003cTResult\u003e\u003e调用Unwrap返回一个新的Task\u003cTResult\u003e代表它的内部任务。但是，如果外部任务失败了或者取消了，就不会有内部任务了，因为没有任务运行完成，所以代理任务也就变成了外部任务的状态。回到前面的例子，如果想让t代表内部任务的返回值（在这个例子中，这个值是 42），那么应该像下面这样写： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }).Unwrap(); 现在，变量t的类型是Task\u003cint\u003e，代表异步调用的结果。 现在回到Task.Run，因为微软想让开发者尽可能的使用这个方法来启用后台任务，并且可以配合async/await使用，所以微软决定在Task.Run方法中内建unwrapping的功能。这也是上面第三点所指的内容，Task.Run的重载方法中有可以接受Action（没有返回值的任务）的，有接受Func\u003cTResult\u003e（返回TResult的任务）的，有接受Func\u003cTask\u003e（返回一个异步任务的任务）的，还有接受Func\u003cTask\u003cTResult\u003e\u003e（返回一个带TResult类型返回值的异步任务的任务）的。总的来说，Task.Run方法提供了上面Task.Factory.StartNew方法相同的unwrapping操作。于是，我们可以这样写： var t = Task.Run(async delegate { await Task.Delay(1000); return 42; }); t的类型是Task\u003cint\u003e，此处Task.Run执行的重载方法等价于： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default).Unwrap(); 如前所述，这是一个快捷方式。 上面讲的全部类容都意味着你可以使用Task.Run调用标准的lambdas/anonymous方法或是异步lambdas/anonymous方法，最后总会按你所期望的行为运行。如果我们想让任务在后台运行并且想等待它的结果，那么可以像下面这样写： int result = await Task.Run(async () =\u003e { await Task.Delay(1000); return 42; }); 此处变量result的类型正是你所期望的int，并且在该任务被调用大约 1 秒钟后，变量result的值被设置为 42。 有趣的是，新的await关键字被认为是等价于Unwrap方法的一种新语法形式。于是，如果我们回到上面那个Task.Factory.StartNew例子，我们可以先用Unwrap重写上面那个代码片段： int result = await Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default).Unwrap(); 或者，可以使用第二个await替换Unwrap： int result = await await Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default); 这里的await await虽然看着别扭，但是并没有问题。Task.Factory.StartNew方法返回一个Task\u003cTask\u003cint\u003e\u003e，对Task\u003cTa","date":"2016-03-05","objectID":"/task.run-vs-task.factory.startnew/:0:0","tags":["dotnet","async","translation"],"title":"Task.Run Vs Task.Factory.StartNew","uri":"/task.run-vs-task.factory.startnew/"},{"categories":["xamarin"],"content":"Xamarin 介绍 Xamarin 是一套跨平台解决方案，目的是使用 C# 语言创造原生的 iOS，Android，Mac 和 Windows 应用。 Xamarin 的三个优势： Xamarin App 拥有原生 App 的性能，因为最后生成的 App 中是使用的原生的控件和原生的 API，所以它的体验和效率与原生 App 相近。 使用熟悉的 C# 语法，在 Objective-C，Swift 或者 Java 中能做的任何事情都可以用 C# 做到。除此之外，C# 还有强大的 IDE 智能提示，lambdas 语法，更自然的异步语法（Task、Async），NuGet 快速获取组件。 在不同的平台上使用同样的语言还具有共享代码的优势，各个平台大约可以共享 75% 的 APIs 和数据结构代码。如果使用 Xamarin.Forms 来创建UI几乎可以共享 100% 的代码。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"最终的思想，共享代码 说白了，Xamarin 宣称的最大的优势就是在三个平台上使用同一种语言来共享代码，总体说来有三种技术实现： Shared Projects：可以在里面添加供三个平台公用的代码，图片和多媒体文件等，代码部分可使用#if __ANDROID__等条件编译符来指定哪一部分会编译输出到特定平台中。 Portable Class Libraries(PCLs)：使用更多的还是 PCLs，PCLs 库直接就能被各个平台所引用，一些流行的库如 SQLite，Json.NET,ReactiveUI 都支持 PCL。 Xamarin.Forms：支持你用 C# 代码来创建在三个平台上共享的 UI 界面，总共可以使用超过 40 个控件，它们都会在运行时映射为原生控件。 共享代码的关系就如下图： ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin 安装指南 工欲善其事，必先利其器。Xamarin的安装过程参考简书上的一篇文章，内容很齐全很详细：http://www.jianshu.com/p/c67c14b3110c 由于墙的原因，从官网下载的安装包无法直接安装，可以通过安装包中解析出配置文件，从中获取下载路径： Windows下载路径 Mac下载路径 Windows下的大体流程如下： Visual Studio 肯定是需要的，推荐 VS2013 安装 jdk，修改环境变量 安装 Android SDK，需要修改为国内镜像 安装 NDK 安装 GTK 安装 Xamarin.VisualStudio 安装 XamarinStudio（可选） 注意 6 和 7 的版本号很重要，必须要跟 Mac 端相匹配，跟破解补丁的版本也需要匹配。如果以后升级，通常只需要更新 6 和 7 就可以了。 关于 Android 模拟器，之前折腾过不少，最后推荐一款专用于游戏玩家的 Andorid 模拟器，海马玩模拟器，它的性能很好很流畅，不过游戏模拟器屏幕默认是横屏的，第一次要手动改成竖屏。 Mac 下的大体流程： 如果只考虑用 Mac 开发 iOS 程序，不考虑在 Mac 下开发 Android 程序，那么大体流程如下: 安装 MonoFramework 安装 monotouch 安装 XamarinStudio 需要注意三者之间的版本一一对应。 关于商业证书，Xamarin 的价格是很昂贵的： 上面看到的价格只是针对单用户单设备平台，通常我们使用 Xamarin 都希望至少能用于 Android 和 iOS 两个平台，所以价格还得乘以 2。 安装完毕后如果没有购买商业证书，那么可以按照上面那篇文章来破解试用，如果使用的版本号在 3.11 之前，那么只需要完成离线破解，IDE 不需要登陆 Xamarin 账号，如果版本号在 3.11 之后，而且要编译 iOS（目的是为了连接 Mac 端的 BuildHost，如果是在 Mac 上开发编译 iOS 则不需要），那么还需要完成在线破解，具体破解流程文章里有，大体流程如下，最后提醒一下试用完了别忘了购买官方的商业授权。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"离线破解流程 软件读取机器特征码； 将特征码通过邮件发给破解者，等待他回复授权证书，不付费证书有效期 1 个月，付费 20 元证书有效期 10 年； 将证书和对应版本的破解文件拷贝到指定目录。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"在线破解流程 邮件申请开通在线服务 修改 host 的 IP 地址 导入 SSL 证书 登陆 Xamarin 账号 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:2","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin.Forms 程序结构 程序的目录结构大致就可以参考这个图，最顶上一层表示三个特定平台的工程，第二层表示一个 PCL 或者 SAP 工程，通常也是 Forms 所在的工程，然后引用两个核心库 Xamarin.Forms.Core 和 Xamarin.Forms.Xaml，然后特定平台的工程还要引用两个特定平台的库，这个特定平台的库可以让程序集使用特定平台的 API。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin.Forms 官方 Demo Xamarin 提供了很多学习用的 Demo，地址是：https://developer.xamarin.com/samples-all/。不过官网的网速确实太慢，在 GitHub 上还有更多更全的 Forms 的 Demo：https://github.com/xamarin/xamarin-forms-samples。 其中我认为几个比较重要的 Demo 可以学习一下： CustomRenderers：教你怎样重写Forms里的一些原生控件的样式； Forms2Native：教你怎样从Forms页面跳转到Native页面； Native2Forms：教你怎样从Native页面跳转回Forms页面； FormsGallery：里面有几乎全部的Forms控件展示； Navigation：教你Forms的App页面导航跳转是怎么回事； UsingDependencyService：教你使用依赖服务在Forms里调用Native的方法； XamFormsImageResize：教你图片尺寸相关的东西； ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin.Forms 官方文档 Xamarin 官方提供了一套很全的在线学习指南，地址是：https://developer.xamarin.com/guides/xamarin-forms/getting-started/，这份指南目录结构良好，便于快速查看，从怎样开始第一个程序到后面怎样到商城发布一应俱全。 还有一个学习途径就是官网教材，可以免费下载离线版：https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/，教材的随书 Demo 地址：https://github.com/xamarin/xamarin-forms-book-preview-2。这本教材支持 Forms1.3 以上，并且章节一直在保持更新，截至 2016/02/25 已发布到 24 章，Demo 的核心库已更新到 2.0 并且加入了 UWP 工程。 如果说在线学习指南可以帮助你快速入门，那么这本教程可以帮助你更细化的理解 Forms 程序。 下面我将 24 章的官方教材的目录做个简单介绍，后面有时间也会对重要的几章做个更详尽的剖析： How Does Xamarin.Forms Fit In?（Forms适合什么场景） Anatomy of an App（剖析一个FormsApp） Deeper into Text（深入文本） Scrolling the Stack（滚动面板） Dealing with Sizes（处理尺寸大小） Button Clicks（按钮点击） XAML vs. Code（创建UI的两种方式） Code and XAML in Harmony（XAML和代码的协调合作） Platform-Specific API Calls（平台特定的API调用） XAML Markup Extensions（XAML扩展标记语言介绍） The Bindable Infrastructure（绑定的基础知识） Styles（样式） Bitmaps（位图） Absolute Layout（绝对布局） The Interactive Interface（交互控件） Data Binding（数据绑定） Mastering the Grid（熟练掌握Grid布局） MVVM（数据绑定开发模式Mvvm讲解） Collection Views（集合控件讲解–List） Async and File I/O（异步I/O操作文件） Transforms（变换—缩放、定位等） Animation（动画） Triggers and Behaviors（触发器和行为） Page Navigation（页面导航） 其中我感觉有几章比较重要，如果对 Xaml（WPF 主要用的界面标记语言）开发不太熟悉的同学需要看一下这几章： 7.XAML vs. Code：了解 Xaml 和 Code 两种方式来创建 UI 界面 8.Code and XAML in Harmony：了解 XAML 和后台代码如何协同工作 10.XAML Markup Extensions：了解扩展标记语言 11.The Bindable Infrastructure：了解绑定的基础知识 16.Data Binding：更深入的了解数据绑定 18.MVVM：了解基于数据绑定的 UI 开发模式 Mvvm 要对Forms的细节有深入理解看下面几章： 3.Deeper into Text：深入理解文本 5.Dealing with Sizes：深入理解如何处理尺寸大小，重点也是拿文本举例，教你如何理解移动开发里面像素、物理尺寸（英尺、厘米）、DPI、DIU，主要思想反正就是不要去关注表示大小的那些数值，字体应该使用字体枚举，布局应该是用比例去控制，要充分相信 Xamarin 平台能帮你控制好大小尺寸。 13.Bitmaps：了解怎样在 Forms 中使用图片，也是满满的都是坑，显示在界面上的图片体积一定要尽量的小，不要将一张原始尺寸的图片加载成缩略图然后放在列表中显示，否则程序一定会内存溢出，一定要对图片进行裁剪，将适合的体积的图片用在适合的地方。从这一章中还可以学习图片在具体平台下的用法和差异等。 19.Collection Views：了解集合控件，列表在 App 当中用得非常普遍，所以应当着重了解。 Async and File I/O：在 Xamarin 中只能使用异步 IO（或者说是 PCL 中只能使用异步IO），从趋势看未来的 .Net Core 可能也只支持异步 IO、异步 Http 请求等，感觉这种更重视性能的 IO 思想是未来框架的趋势，所以可以借此熟悉一下，C# 的异步语法应该算是众多编程语言中的佼佼者了。 下面对第五章 Dealing with Sizes 稍作讲解，这章重点介绍了移动平台下尺寸相关的一些知识，先看下下面两个表格： 型号 iPhone 2，3 iPhone 4 iPhone 5 iPhone 6 iPhone 6 Plus 像素尺寸 320x480 640x960 640x1136 750x1134 1080x1920 屏幕尺寸 3.5英寸 3.5英寸 4英寸 4.7英寸 5.5英寸 像素密度 165 DPI 330 DPI 326 DPI 326 DPI 401 DPI 单位点包含像素数量 1 2 2 2 3 点数尺寸 320x480 320x480 320x568 375x667 414x736 每英寸包含点数量 165 165 163 163 154 屏幕类型 WVGA WXGA 720P 1080P 像素尺寸 480x800 768x1280 720x1280 1080x1920 缩放比例 1 1.6 1.5 2.25 DIUs尺寸 480x800 480x800 480x853 480x853 第一张图是 iPhone 下的一些尺寸元素间的关系，第二张是 WinPhone 的，这里没有给出 Android 的，其实 Android 整体上说来跟 iPhone 的那些参数很相似。 Forms 中真正使用的不是像素，而是点数，点里面包含的像素数量是不一致的，像 iPhone2，3 基本上是一一对应，一个点包含一个像素，iPhone4，5，6 就是两倍像素，iPhone6Plus 就是三倍像素，所以 iPhone 的图片里出现 @2x，@3x 这些标识就是对应平台所使用的像素不同的图片。我们在 Forms 中使用的那些表示宽高的值就是这种点数单位，要知道设置的这些值可以获取整个页面的 Width 和 Height 值。 下面说下字号，Forms 提供了几种枚举字号：Default，Micro，Small，Medium，Large，在不同的设备，不同的用户系统字号设置，不同的控件中，相同的枚举返回的字号数值可能都不一样。通过 Device.GetNamedSize 方法获取的 FontSize 值的单位是 double，表示文本字符从最下面到最上面到高度，字体的宽度一般都是 FontSize 值的一半，字体的行距一般是 FontSize 值的 1.2 倍。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Forms 中 UI 布局细节 在 Forms 中设计各种元素布局等细节依然可以参考设计网页采用的盒模型的思想。从大的块元素的分离到小如一个文字，都可以想象成一个个小盒子。由内容区，内边距，边框，外边距组成。 Forms 中还有几个比较容易混淆的类：ContentView，Frame，BoxView。 虽然可以按照盒模型的思想来布局元素，但是 Forms 中没有标准的 margin 的概念，Forms 的做法是在一个内容视图外面再嵌套一个 ContentView，ContentView 继承自 Layout，只多了一个 Content 属性来存放内容视图。此时，ContentView 的 Padding 属性就可以想象成盒子的 Margin。 Frame 在布局中也比较常用，通常用于定义页面中一组视图的区块，它继承自 ContentView，多了些边框、阴影等属性。 BoxView 是一个矩形填充区，在 Forms 中用得最多的地方就是用它来绘制横线、竖线等分割线。虽然看起来很山寨，但它却是是 Forms 中的一个标准用法。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"APP 的发布 前面教程重点是介绍 Xamarin.Forms 相关的东西，对于平台特定的那些没有做介绍，比如平台和 Forms 之间的交互（依赖注入，前面的 Demo 介绍 PPT 有），比如最后 APP 的发布，发布相关的东西参考前面提到的在线教程： ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Android 发布教程 我们项目中的 Android 安装包没有发布进商城，是通过网址直接下载，所以发布教程没有验证：https://developer.xamarin.com/guides/android/deployment,_testing,_and_metrics/publishing_an_application/ ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"iOS 发布教程 iOS 需要发布，流程主要是有很多和 apple 打交道的地方比较麻烦，比如说开发者证书，AppStore 证书，用特定的证书打包你的 IPA，提交到 itunesconnect，审核等等，Xamarin 的教程如下：https://developer.xamarin.com/guides/ios/deployment,_testing,_and_metrics/app_distribution/ ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:2","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin 组件商店的使用 Xamarin 有自己的组件商店，里面有很多免费和收费的组件，刚开始就在这上面找东西，不过网速实在不可恭维，后来发现免费插件这上面有的 GitHub 上几乎都有，所以使用 GitHub 又快又方便。 如果要在组件商店中下载需要注意最后一步需要翻墙，因为网站用了 google 提供的 jquery 库：https://components.xamarin.com/ GitHub 上 Xamarin 提供的一个常用的免费插件目录，这个插件库里有 Xamarin 官方的也有第三方的。我们的项目所使用的插件大多来自这个目录，里面有插件的 NuGet 和 GitHub 地址： https://github.com/xamarin/plugins GitHub 上 Xamarin 官方插件库的源代码：https://github.com/jamesmontemagno/Xamarin.Plugins ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"GitHub 上去找东西 在 GitHub 上使用“Xamarin.Forms”为关键词进行搜索，可以快速找到相关资源。 Xamarin-Forms-Labs：这个库很大，包含的东西很多，IOC 容器、序列化组件、缓存组件、UI控件等，我们用得最多的还是 UI 控件。但是用法不是像其他插件一样直接引用它的相关 dll（之前尝试过很久，直接使用会导致莫名其妙的问题），而是直接拷贝代码到我们项目中直接用，但是这个库也正如它的名字一样，是实验性的，在 GitHub 介绍上也可以看到可用控件里几乎所有控件都是 beta 状态，我们在使用过程中也发现了不少 Bug，所以项目里的代码有所改动，跟以前应该不太一样了。我们项目里参考并使用的控件有Checkbox、RadioButton等。 XamarinFormsGestureRecognizers：这个没有使用过，从说明来看是一个手势功能相关的库。 XamarinForms 里的控件默认只有 Tap 点击事件，其他手势操作都在平台内部，这个库就是教你怎样将它们连接起来，然后在 PCL 中写针对控件的手势操作代码。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"IDE技巧 Android 很简单，在 Windows 上启动海马玩模拟器，模拟器启动时间比较长，但启动好之后就可以不用关了，然后只需要用 Visual Studio 设置 Android 项目为启动项，附加到模拟器进行调试即可；真机用 USB 连接使用同样的方式在 IDE 里调试。 iOS 比较麻烦，需要打开 Mac 电脑上的 BuildHost（如果 Mac 不在身边，可使用远程软件 tightvnc 操作，不过一台 Mac 同时只能供一人使用），然后 Visual Studio 设置 iOS 为启动项，可自动寻找局域网内的 Mac 电脑上的 BuildHost，然后输入配对码即可连接成功，如果失败请重启 BuildHost 再试；真机调试一样，不过真机只能连接在 Mac 电脑上。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"一些常用插件 Forms 中插件的使用也比较简单，基本上用一次就会了。首先，插件的使用方式都很统一，Forms 的 PCL 中一般引用两个库,两个库都是 PCL 的，一个带 Abstractions 后缀，里面只定义了接口和实体，不包含逻辑代码；另一个不带 Abstractions 后缀，就像工厂一样，只负责创建 Abstractions 程序集里定义的那些接口的实现者，创建的方式不是使用前面提到的 Xamarin 提供的依赖注入（ UsingDependencyService ），而是条件编译的方式直接 New 对应平台的实现者。在 Andorid 和 iOS（或者 WP）里引用了带 Abstractions 后缀的程序集，然后引用一个真正的属于该平台的程序集（非 PCL，可以调用平台特殊 API），这个程序集实现了 Abstractions 程序集里的接口，它的实例化对象在运行时被真正使用。如果我们自己写插件就可以使用 Xamarin 提供的依赖注入的方式，在特定平台内部写好功能类，然后在 PCL 中直接导出就可以使用了。 然后下面列出一些常用插件： Corcav.Behaviors：帮助你将列表的每一项绑定命令到这个列表的 BindingContext，而不是具体项的 BindingContext，帮助将事件转为命令，Xamarin 自身不带这个功能。 EZ-Compress-for-Xamarin ：压缩图片流的库。 MvvmLight：Mvvm 开发模式的支持库，还用到了里面的 Ioc 容器（SimpleIoc，我们系统里有两套 Ioc 容器，一个就是这个，另一个是 Xamarin 的依赖注入容器）；还用到了它提供的导航组件。 Xam.Plugins.Messaging：提供打电话、发短信、发 Email 等功能。 Media.Plugin：提供拍照、选照片的功能。 PCLStorage ：跨平台的异步 I/O 库。 Vibrate：提供了手机震动的功能。 Toasts.Forms.Plugin ：顶部的那个彩色浮动提示框。 然后一些用得比较多的 UI 组件有：圆形图片、Checkbox、RadioButton、图片选择器等，有自己写的，也有在Xamarin-Forms-Labs的基础上改的。 Andorid 使用插件时注意在工程的 Properties 的 AndroidManifest.xml 中写入对应的权限。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin 官方论坛 遇到疑难的问题，上 Xamarin 官方论坛搜索，大部分你遇到的问题上面应该都会有，基本用不着主动提问，这个地址我认为访问频率相当高，地址如下：http://forums.xamarin.com/ ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"没有涉及到的东西 本教程没有涉及到 GIS 相关的内容。 没有对特定平台内部相关知识介绍，我们团队的成员对平台特定API都了解太少，特别是涉及 UI 方面的，要掌握这些知识的难度跟学习原生开发无异，所以对一些难题解决起来比较费力，比如之前的 Android 和 iOS 的 Tab 页样式差异问题（Android 的 Tab 在屏幕上面，iOS 的 Tab 在屏幕底部）。因为 Tab 属于页面，跟控件不一样，不能使用 CustomRenderers 的技术重写样式，在论坛上搜索的结果如下： http://forums.xamarin.com/discussion/54668/bottom-tab-bar-menu-for-android https://forums.xamarin.com/discussion/10004/tabs-on-the-bottom-for-android-example-code http://forums.xamarin.com/discussion/56320/is-there-any-way-to-show-tabs-on-bottom-in-android-using-tabbedpagerenderer 主要意思先是从设计的角度强调不要进行这样通用的设计，如果一定是通用样式那么给出的解决方案也是平台内部的，首先不说技术门槛，这个实现方式跟 Forms 的思想就是有冲突的，所以最好的方案就是在新 APP 里用 Forms 纯手写 Tab 页面。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"资源汇总 官方Demo： https://developer.xamarin.com/samples-all/ https://github.com/xamarin/xamarin-forms-samples 官方程序安装地址： https://static.xamarin.com/installer_assets/v3/Windows/Universal/InstallationManifest.xml https://static.xamarin.com/installer_assets/v3/Mac/Universal/InstallationManifest.xml windows下的ios模拟器 最新的版本信息查询地址： https://developer.xamarin.com/releases/current/ 一个博客提供的最新下载地址： https://www.coderbusy.com/archives/256.html?from=groupmessage\u0026isappinstalled=0 可根据以上版本号手动构造下载地址如下： Win: http://dl.google.com/android/ndk/android-ndk-r10e-windows-x86_64.exe http://dl.google.com/android/installer_r24.4.1-windows.exe http://download.xamarin.com/GTKforWindows/Windows/gtk-sharp-2.12.30.msi https://dl.xamarin.com/XamarinforVisualStudio/Windows/Xamarin.VisualStudio_4.2.1.58.msi http://download.xamarin.com/studio/Windows/XamarinStudio-5.10.3.26-0.msi Mac: http://download.xamarin.com/Installer/MonoForAndroid/jdk-7u71-macosx-x64.dmg http://dl.google.com/android/android-sdk_r24.4.1-macosx.zip http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin http://dl.xamarin.com/MonoFrameworkMDK/Macx86/MonoFramework-MDK-4.6.2.7.macos10.xamarin.universal.pkg https://dl.xamarin.com/MonoDevelop/Mac/XamarinStudio-6.1.2.44.dmg https://dl.xamarin.com/MonoTouch/Mac/xamarin.ios-10.2.1.5.pkg http://dl.xamarin.com/MonoforAndroid/Mac/xamarin.android-7.0.2-37.pkg http://dl.xamarin.com/XamarinforMac/Mac/xamarin.mac-2.10.0.113.pkg 官方文档： https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/ 官方教材： https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/ https://github.com/xamarin/xamarin-forms-book-samples/ 官方论坛： http://forums.xamarin.com/ 常用插件： https://github.com/xamarin/plugins https://github.com/jamesmontemagno/Xamarin.Plugins https://components.xamarin.com/ https://github.com/XLabs/Xamarin-Forms-Labs MvvmCross https://github.com/MvvmCross/MvvmCross https://github.com/MvvmCross/MvvmCross-Plugins ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["dotnet"],"content":"Log4net 先说 Log4net，它是.net 平台上一个老牌的日志框架，我接触的时间也不长(因为公司有自己的日志库)，但是看着各开源库都在用这个于是前段时间也尝试去了解了一下。 首先让我认识到 Log4net 强大的地方就是它的多目标输出，可以输出到控制台、文件、数据库、系统事件、Email 等，几乎无所不能。然后它可以通过配置让日志系统实时生效，比如说在服务运行的过程中修改配置改变输出目标，改变日志等级等，均不用重启程序。但是 Log4net 也有一个让我比较头痛的地方就是感觉配置过于复杂，根本记不住，每次都必须去查阅资料，于是乎之前我也针对 Log4net 做了一个简单的封装，内嵌了一个默认使用文件存储的日志配置，提供静态日志方法，还提供一套性能统计的 API(貌似 Visual Studio 2015 后 IDE 已自带了)。以下是这个封装的源代码地址：github，nuget 地址：nuget。 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:1:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"NLog 下面说说为什么又关注起 NLog 了，Nlog 没有 Log4net 老牌，使用从 Nuget 下载量来看也没有 Log4net 用户量大，但是它却一直在保持高速的更新状态，从 github 主页上看它所支持的平台也相当广泛，从.net 环境到 mono 再到现在最新的 Xamarin 均支持： ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:2:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"比较 下面这个是一篇比较这两种日志的文章，应该是翻译的 StackOverFlow 再加上作者自己的一些见解: http://www.cnblogs.com/wanglee/archive/2013/05/22/3092474.html。 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:3:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"下面是总结的几点 项目 log4net nlog 流行程度 胜 负 易用性 负 胜 动态配置 平 平 输出目标 平 平 跨平台 负 胜 开源持续维护 负 胜 日志性能 负 胜 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:3:1","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"性能比较（不再有效，详见文末） 这是用这两款日志框架写的一个性能比较的 Demo，暂时只比较了文件记录日志的情况(因为相对来说这种情况应该是最多的)，附上源码地址。 性能比较结果如图，分别是 Debug 条件编译下的单线程和并行多线程以及独占锁和最小冲突锁的情况： ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:3:2","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"2017 年 9 月 1 日更新 以上性能测试不再有效，根据网友反馈，由于输出内容的略有差异导致上面性能测试出现不公平的情况，log4Net 在输出时可能会有更多的计算量。在优化测试代码情况下，仅让日志框架打印日志内容，其余的包括时间、日志等级、日志类名一律不打印，使用最新版 Dll，两个框架性能相差无几。 推荐阅读： NET 开源项目介绍及资源推荐：http://www.cnblogs.com/Terrylee/archive/2006/12/03/opensource_framework_and_resource_recommendation_Log.html 附加链接： log4net：https://logging.apache.org/log4net/ NLog：https://github.com/NLog/NLog ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:4:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["xamarin"],"content":"安装 使用标准安装流程(JDK1.6 -\u003e Android SDK -\u003e NDK -\u003e Xamarin Studio -\u003e Xamarin Visual Studio) Android SDK Manager 更改源，可时刻保持最新，一个镜像源地址：mirrors.neusoft.edu.cn；ubuntu.buct.cn；Port: 80，Android SDK的目录结构介绍，Android的一些相关资源 http://ubuntu.buct.edu.cn/android/repository/。 Windows 端破解流程两步：替换 IDE 的 Dll，两个位置，一个是 VS 的 Common 下，一个 Xamarin Studio 的 bin 下；替换对应版本的 mandroid.exe 和 mtouch.exe Mac 端破解流程，Mac 端只负责 iOS 相关的东西，不考虑在 Mac 端开发 Android，首先要安装的东西包括：MonoFramework-MDK-3.12.1.3.macos10.xamarin.x86.pkg； monotouch-8.8.2.4.pkg ；XamarinStudio-5.8.2.7-0.dmg；(版本号注意要匹配，现在这一系列的版本号匹配的是 Windows 端的 3.9.525) 装完之后主要要替换三个东西：/Developer/MonoTouch/usr/bin/mtouch-64； Mtouch-64 替换完毕后需要在终端执行命令：chmod a+x /Developer/MonoTouch/usr/bin/mtouch-64 然后替换/Applications/Xamarin Studio.app/Contents/Resources/lib/monodevelop/AddIns/Xamarin.Ide/Xamarin.Components.Ide.dll 最后替换 /Applications/Xamarin.iOS Build Host.app/Contents/MonoBundle/Xamarin.Components.Ide.dll ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"模拟器 可以不使用 android 的标准模拟器，使用 Xamarin Android Player，据说性能要好一些，但是版权原因还没测试。 如果使用标准模拟器，可配置硬件加速 首先，你的 CPU 必须支持 Intel 虚拟化技术，如果支持进 BIOS 打开 使用 Android SDK 下载对应的 x86架构的系统镜像 上Intel官网下载最新的HAXM虚拟引擎，或者直接用SDK下载 下载后需要手动安装，如果双击安装无效，使用管理员权限运行 CMD，执行安装目录下的那个 Bat 文件；如果提示不支持 Intel 虚拟化技术，但是我们确认是打开了的，可能是因为操作系统装了 Hyper 的原因，卸载 Hyper 重启再试一次 进 AVD 创建基于 X86 的虚拟机 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"安卓引用的文件结构 文件夹 作用 Components 登录 Xamarin 账户可下载它官方提供的一些组件直接使用 Assets 存放字体、本地数据库、配置文件等一系列本地资源 Properties 除了常规的程序集版本号等信息，含包括 Android 程序的权限描述文件AndroidManifest.xml Resources 包好 Strings，images，layout 等资源的文件夹，注意程序的视图界面也在该文件夹下，还包括一个 AboutResources.txt 资源描述文件 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"安卓应用的逻辑结构 安卓应用跟传统应用不一样，没有单点入口，应用和安卓操作系统紧密联系，操作系统可以随时将应用进程载入内存激活应用。因此应用中有一个 Activity 的概念，一个应用由很多 Activity 组成。 Activity 的特性： Label：告诉操作系统这个类属于哪个程序，它会去 AndroidManifest.xml 里去匹配。 MainLauncher：告诉操作系统打开程序后激活哪个页面。 Activity的生命周期：created, started and paused, resumed and destroyed, and so on。 通过重写基类的生命周期方法来实现自己的逻辑，如：OnCreate（应用程序被装载到内存中时调一次），OnResume（设备执行别的任务后，该 Activity 返回设备界面时触发），OnPause（设备将执行其他任务，该 Activity 离开设备界面时触发） ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"Xamarin.Forms相关 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"简介 可以跨平台的构建用户交互相关的东西，简而言之就是写一套代码三个平台通用，在此基础上也能够结合各平台特有的 Xamarin 本地代码混合一起。 Forms 除了跨平台的好处意外，还支持 Xaml 编写用户界面，不用借助 Goft.Mvvm.light 等第三方框架原生支持数据绑定等。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:1","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"使用前置条件 Android4.0 以上； IOS6.1 以上； 开发环境 VS2013； 解决方案必须是 .Net4.5 以上，PCL 模板，Vs2013update2 可使用 SharedProject。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:2","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"适用程序 Xamarin.Forms Xamarin.iOS \u0026 Xamarin.Android 以单纯数据展示为主 程序会用到特殊的交互 快速原型、概念类程序 界面 UI 经过精心设计的程序 只会用到很少的平台特殊功能(API) 会用到很多的平台特殊功能(API) 共享代码比用户UI更加重要 用户UI比共享代码更加重要 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:3","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"Xaml相关 Forms 要针对各个平台做界面微调时 OnPlatForm ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:4","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"FormsFQA 第一次运行 Forms 程序会提示“无法链接到远程服务器” Verify the project is selected to be deployed in the Solution Configuration Manager. ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:5","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"Mvvm相关 三套框架：MvvmCross、MvvmLight、XamarinFormsLab http://blog.galasoft.ch/posts/2014/05/mvvm-light-v4-4-with-xamarin-android-support/?utm_source=tuicool MvvmLight For Android要求Android版本在2.3(API10)以上 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:6","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"FQA 一个纠缠很久的问题，Android 设计界面中 Layout 无法加载，报什么网络错误，原因为 Android SDK 升级了最新的 Tools 到 24.3，最新版的 SDK 会引起 Xamarin 出现这个错误，如果使用最新的 Xamarin 则已修复这个错误，如果不想更新 Xamarin 则需要进行 SDK 降级操作 限制屏幕旋转功能，指定程序只能使用竖屏或横屏，参考《Xamarin Forms Preview Edition 2》第五章，88(PDF 101)页。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:7","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"其他资源 安装、破解：http://www.jianshu.com/p/c67c14b3110c ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:8","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"}]